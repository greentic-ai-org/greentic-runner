// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/arithmetic.isle
// - src/opts/bitops.isle
// - src/opts/cprop.isle
// - src/opts/extends.isle
// - src/opts/icmp.isle
// - src/opts/remat.isle
// - src/opts/selects.isle
// - src/opts/shifts.isle
// - src/opts/skeleton.isle
// - src/opts/spaceship.isle
// - src/opts/spectre.isle
// - src/opts/vector.isle
// - <OUT_DIR>/numerics.isle
// - <OUT_DIR>/clif_opt.isle

use super::*;  // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self, ) -> Unit;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> i32;
    fn checked_add_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> Option<u64>;
    fn add_overflows_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> bool;
    fn imm64_sdiv(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_srem(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn i64_sextend_u64(&mut self, arg0: Type, arg1: u64) -> i64;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn imm64_clz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn imm64_ctz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn u128_replicated_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_replicated_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u32_replicated_u16(&mut self, arg0: u64) -> Option<u64>;
    fn u16_replicated_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u128_low_bits(&mut self, arg0: u128) -> u64;
    fn u128_high_bits(&mut self, arg0: u128) -> u64;
    fn f16_min(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_max(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_neg(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_abs(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_copysign(&mut self, arg0: Ieee16, arg1: Ieee16) -> Ieee16;
    fn f32_add(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sub(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_mul(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_div(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sqrt(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_ceil(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_floor(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_trunc(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_nearest(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_min(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_max(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_neg(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_abs(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_copysign(&mut self, arg0: Ieee32, arg1: Ieee32) -> Ieee32;
    fn f64_add(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sub(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_mul(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_div(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sqrt(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_ceil(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_floor(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_trunc(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_nearest(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_min(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_max(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_neg(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_abs(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_copysign(&mut self, arg0: Ieee64, arg1: Ieee64) -> Ieee64;
    fn f128_min(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_max(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_neg(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_abs(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_copysign(&mut self, arg0: Ieee128, arg1: Ieee128) -> Ieee128;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_count(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn ty_half_lanes(&mut self, arg0: Type) -> Option<Type>;
    fn ty_half_width(&mut self, arg0: Type) -> Option<Type>;
    fn ty_equal(&mut self, arg0: Type, arg1: Type) -> bool;
    fn mem_flags_trusted(&mut self, ) -> MemFlags;
    fn little_or_native_endian(&mut self, arg0: MemFlags) -> Option<MemFlags>;
    fn intcc_swap_args(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_complement(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_without_eq(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_swap_args(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_complement(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16_or_32(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u16_from_ieee16(&mut self, arg0: Ieee16) -> u16;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_i32(&mut self, arg0: Offset32) -> i32;
    fn i32_to_offset32(&mut self, arg0: i32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self, ) -> TrapCode;
    fn trap_code_integer_overflow(&mut self, ) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self, ) -> TrapCode;
    type inst_data_value_etor_returns: Default + IntoContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_value_etor(&mut self, arg0: Value, returns: &mut Self::inst_data_value_etor_returns) -> ();
    fn inst_data_etor(&mut self, arg0: Inst) -> Option<InstructionData>;
    type inst_data_value_tupled_etor_returns: Default + IntoContextIter<Context = Self, Output = TypeAndInstructionData>;
    fn inst_data_value_tupled_etor(&mut self, arg0: Value, returns: &mut Self::inst_data_value_tupled_etor_returns) -> ();
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn make_skeleton_inst_ctor(&mut self, arg0: &InstructionData) -> Inst;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn iconst_sextend_etor(&mut self, arg0: TypeAndInstructionData) -> Option<(Type, i64)>;
    type sextend_maybe_etor_returns: Default + IntoContextIter<Context = Self, Output = (Type, Value)>;
    fn sextend_maybe_etor(&mut self, arg0: Value, returns: &mut Self::sextend_maybe_etor_returns) -> ();
    type uextend_maybe_etor_returns: Default + IntoContextIter<Context = Self, Output = (Type, Value)>;
    fn uextend_maybe_etor(&mut self, arg0: Value, returns: &mut Self::uextend_maybe_etor_returns) -> ();
    fn div_const_magic_u32(&mut self, arg0: u32) -> DivConstMagicU32;
    fn div_const_magic_u64(&mut self, arg0: u64) -> DivConstMagicU64;
    fn div_const_magic_s32(&mut self, arg0: i32) -> DivConstMagicS32;
    fn div_const_magic_s64(&mut self, arg0: i64) -> DivConstMagicS64;
    fn splat64(&mut self, arg0: u64) -> Constant;
    fn f32_from_uint(&mut self, arg0: u64) -> Ieee32;
    fn f64_from_uint(&mut self, arg0: u64) -> Ieee64;
    fn f32_from_sint(&mut self, arg0: i64) -> Ieee32;
    fn f64_from_sint(&mut self, arg0: i64) -> Ieee64;
    fn u64_bswap16(&mut self, arg0: u64) -> u64;
    fn u64_bswap32(&mut self, arg0: u64) -> u64;
    fn u64_bswap64(&mut self, arg0: u64) -> u64;
    fn ieee128_constant_extractor(&mut self, arg0: Constant) -> Option<Ieee128>;
    fn ieee128_constant(&mut self, arg0: Ieee128) -> Constant;
    fn i8_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_ne(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_checked_add(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_sub(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_mul(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_div(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_rem(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_rem(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_and(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_or(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_xor(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_not(&mut self, arg0: i8) -> i8;
    fn i8_checked_shl(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_checked_shr(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_is_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_non_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_non_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_odd(&mut self, arg0: i8) -> bool;
    fn i8_matches_odd(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_even(&mut self, arg0: i8) -> bool;
    fn i8_matches_even(&mut self, arg0: i8) -> Option<bool>;
    fn i8_checked_ilog2(&mut self, arg0: i8) -> Option<u32>;
    fn i8_ilog2(&mut self, arg0: i8) -> u32;
    fn i8_trailing_zeros(&mut self, arg0: i8) -> u32;
    fn i8_trailing_ones(&mut self, arg0: i8) -> u32;
    fn i8_leading_zeros(&mut self, arg0: i8) -> u32;
    fn i8_leading_ones(&mut self, arg0: i8) -> u32;
    fn i8_checked_neg(&mut self, arg0: i8) -> Option<i8>;
    fn i8_wrapping_neg(&mut self, arg0: i8) -> i8;
    fn i8_neg(&mut self, arg0: i8) -> i8;
    fn u8_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_ne(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_checked_add(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_sub(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_mul(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_div(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_rem(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_rem(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_or(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_xor(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_not(&mut self, arg0: u8) -> u8;
    fn u8_checked_shl(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_checked_shr(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_is_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_non_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_non_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_odd(&mut self, arg0: u8) -> bool;
    fn u8_matches_odd(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_even(&mut self, arg0: u8) -> bool;
    fn u8_matches_even(&mut self, arg0: u8) -> Option<bool>;
    fn u8_checked_ilog2(&mut self, arg0: u8) -> Option<u32>;
    fn u8_ilog2(&mut self, arg0: u8) -> u32;
    fn u8_trailing_zeros(&mut self, arg0: u8) -> u32;
    fn u8_trailing_ones(&mut self, arg0: u8) -> u32;
    fn u8_leading_zeros(&mut self, arg0: u8) -> u32;
    fn u8_leading_ones(&mut self, arg0: u8) -> u32;
    fn u8_is_power_of_two(&mut self, arg0: u8) -> bool;
    fn u8_matches_power_of_two(&mut self, arg0: u8) -> Option<bool>;
    fn i16_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_ne(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_checked_add(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_sub(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_mul(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_div(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_rem(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_rem(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_and(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_or(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_xor(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_not(&mut self, arg0: i16) -> i16;
    fn i16_checked_shl(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_checked_shr(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_is_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_non_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_non_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_odd(&mut self, arg0: i16) -> bool;
    fn i16_matches_odd(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_even(&mut self, arg0: i16) -> bool;
    fn i16_matches_even(&mut self, arg0: i16) -> Option<bool>;
    fn i16_checked_ilog2(&mut self, arg0: i16) -> Option<u32>;
    fn i16_ilog2(&mut self, arg0: i16) -> u32;
    fn i16_trailing_zeros(&mut self, arg0: i16) -> u32;
    fn i16_trailing_ones(&mut self, arg0: i16) -> u32;
    fn i16_leading_zeros(&mut self, arg0: i16) -> u32;
    fn i16_leading_ones(&mut self, arg0: i16) -> u32;
    fn i16_checked_neg(&mut self, arg0: i16) -> Option<i16>;
    fn i16_wrapping_neg(&mut self, arg0: i16) -> i16;
    fn i16_neg(&mut self, arg0: i16) -> i16;
    fn u16_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_ne(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_checked_add(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_sub(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_mul(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_div(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_rem(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_rem(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_and(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_or(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_xor(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_not(&mut self, arg0: u16) -> u16;
    fn u16_checked_shl(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_checked_shr(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_is_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_non_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_non_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_odd(&mut self, arg0: u16) -> bool;
    fn u16_matches_odd(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_even(&mut self, arg0: u16) -> bool;
    fn u16_matches_even(&mut self, arg0: u16) -> Option<bool>;
    fn u16_checked_ilog2(&mut self, arg0: u16) -> Option<u32>;
    fn u16_ilog2(&mut self, arg0: u16) -> u32;
    fn u16_trailing_zeros(&mut self, arg0: u16) -> u32;
    fn u16_trailing_ones(&mut self, arg0: u16) -> u32;
    fn u16_leading_zeros(&mut self, arg0: u16) -> u32;
    fn u16_leading_ones(&mut self, arg0: u16) -> u32;
    fn u16_is_power_of_two(&mut self, arg0: u16) -> bool;
    fn u16_matches_power_of_two(&mut self, arg0: u16) -> Option<bool>;
    fn i32_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_ne(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_checked_add(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_sub(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_mul(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_div(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_rem(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_rem(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_and(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_or(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_xor(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_not(&mut self, arg0: i32) -> i32;
    fn i32_checked_shl(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_checked_shr(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_is_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_non_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_non_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_odd(&mut self, arg0: i32) -> bool;
    fn i32_matches_odd(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_even(&mut self, arg0: i32) -> bool;
    fn i32_matches_even(&mut self, arg0: i32) -> Option<bool>;
    fn i32_checked_ilog2(&mut self, arg0: i32) -> Option<u32>;
    fn i32_ilog2(&mut self, arg0: i32) -> u32;
    fn i32_trailing_zeros(&mut self, arg0: i32) -> u32;
    fn i32_trailing_ones(&mut self, arg0: i32) -> u32;
    fn i32_leading_zeros(&mut self, arg0: i32) -> u32;
    fn i32_leading_ones(&mut self, arg0: i32) -> u32;
    fn i32_checked_neg(&mut self, arg0: i32) -> Option<i32>;
    fn i32_wrapping_neg(&mut self, arg0: i32) -> i32;
    fn i32_neg(&mut self, arg0: i32) -> i32;
    fn u32_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_ne(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_checked_add(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_sub(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_mul(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_div(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_rem(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_rem(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_or(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_xor(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_not(&mut self, arg0: u32) -> u32;
    fn u32_checked_shl(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_shr(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_is_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_non_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_non_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_odd(&mut self, arg0: u32) -> bool;
    fn u32_matches_odd(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_even(&mut self, arg0: u32) -> bool;
    fn u32_matches_even(&mut self, arg0: u32) -> Option<bool>;
    fn u32_checked_ilog2(&mut self, arg0: u32) -> Option<u32>;
    fn u32_ilog2(&mut self, arg0: u32) -> u32;
    fn u32_trailing_zeros(&mut self, arg0: u32) -> u32;
    fn u32_trailing_ones(&mut self, arg0: u32) -> u32;
    fn u32_leading_zeros(&mut self, arg0: u32) -> u32;
    fn u32_leading_ones(&mut self, arg0: u32) -> u32;
    fn u32_is_power_of_two(&mut self, arg0: u32) -> bool;
    fn u32_matches_power_of_two(&mut self, arg0: u32) -> Option<bool>;
    fn i64_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_ne(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_checked_add(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_sub(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_mul(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_div(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_rem(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_rem(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_and(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_or(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_xor(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_not(&mut self, arg0: i64) -> i64;
    fn i64_checked_shl(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_checked_shr(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_is_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_non_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_non_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_odd(&mut self, arg0: i64) -> bool;
    fn i64_matches_odd(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_even(&mut self, arg0: i64) -> bool;
    fn i64_matches_even(&mut self, arg0: i64) -> Option<bool>;
    fn i64_checked_ilog2(&mut self, arg0: i64) -> Option<u32>;
    fn i64_ilog2(&mut self, arg0: i64) -> u32;
    fn i64_trailing_zeros(&mut self, arg0: i64) -> u32;
    fn i64_trailing_ones(&mut self, arg0: i64) -> u32;
    fn i64_leading_zeros(&mut self, arg0: i64) -> u32;
    fn i64_leading_ones(&mut self, arg0: i64) -> u32;
    fn i64_checked_neg(&mut self, arg0: i64) -> Option<i64>;
    fn i64_wrapping_neg(&mut self, arg0: i64) -> i64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_ne(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_checked_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_mul(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_div(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_rem(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_rem(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_checked_shl(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_checked_shr(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_non_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_non_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn u64_matches_odd(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_even(&mut self, arg0: u64) -> bool;
    fn u64_matches_even(&mut self, arg0: u64) -> Option<bool>;
    fn u64_checked_ilog2(&mut self, arg0: u64) -> Option<u32>;
    fn u64_ilog2(&mut self, arg0: u64) -> u32;
    fn u64_trailing_zeros(&mut self, arg0: u64) -> u32;
    fn u64_trailing_ones(&mut self, arg0: u64) -> u32;
    fn u64_leading_zeros(&mut self, arg0: u64) -> u32;
    fn u64_leading_ones(&mut self, arg0: u64) -> u32;
    fn u64_is_power_of_two(&mut self, arg0: u64) -> bool;
    fn u64_matches_power_of_two(&mut self, arg0: u64) -> Option<bool>;
    fn i128_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_ne(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_checked_add(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_sub(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_mul(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_div(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_rem(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_rem(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_and(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_or(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_xor(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_not(&mut self, arg0: i128) -> i128;
    fn i128_checked_shl(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_checked_shr(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_is_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_non_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_non_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_odd(&mut self, arg0: i128) -> bool;
    fn i128_matches_odd(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_even(&mut self, arg0: i128) -> bool;
    fn i128_matches_even(&mut self, arg0: i128) -> Option<bool>;
    fn i128_checked_ilog2(&mut self, arg0: i128) -> Option<u32>;
    fn i128_ilog2(&mut self, arg0: i128) -> u32;
    fn i128_trailing_zeros(&mut self, arg0: i128) -> u32;
    fn i128_trailing_ones(&mut self, arg0: i128) -> u32;
    fn i128_leading_zeros(&mut self, arg0: i128) -> u32;
    fn i128_leading_ones(&mut self, arg0: i128) -> u32;
    fn i128_checked_neg(&mut self, arg0: i128) -> Option<i128>;
    fn i128_wrapping_neg(&mut self, arg0: i128) -> i128;
    fn i128_neg(&mut self, arg0: i128) -> i128;
    fn u128_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_ne(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_checked_add(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_sub(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_mul(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_div(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_rem(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_rem(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_and(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_or(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_xor(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_not(&mut self, arg0: u128) -> u128;
    fn u128_checked_shl(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_checked_shr(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_is_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_non_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_non_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_odd(&mut self, arg0: u128) -> bool;
    fn u128_matches_odd(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_even(&mut self, arg0: u128) -> bool;
    fn u128_matches_even(&mut self, arg0: u128) -> Option<bool>;
    fn u128_checked_ilog2(&mut self, arg0: u128) -> Option<u32>;
    fn u128_ilog2(&mut self, arg0: u128) -> u32;
    fn u128_trailing_zeros(&mut self, arg0: u128) -> u32;
    fn u128_trailing_ones(&mut self, arg0: u128) -> u32;
    fn u128_leading_zeros(&mut self, arg0: u128) -> u32;
    fn u128_leading_ones(&mut self, arg0: u128) -> u32;
    fn u128_is_power_of_two(&mut self, arg0: u128) -> bool;
    fn u128_matches_power_of_two(&mut self, arg0: u128) -> Option<bool>;
    fn i8_try_into_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_unwrap_into_u8(&mut self, arg0: i8) -> u8;
    fn i8_cast_unsigned(&mut self, arg0: i8) -> u8;
    fn i8_from_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_into_i16(&mut self, arg0: i8) -> i16;
    fn i8_from_i16(&mut self, arg0: i8) -> Option<i16>;
    fn i8_try_into_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_unwrap_into_u16(&mut self, arg0: i8) -> u16;
    fn i8_from_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_into_i32(&mut self, arg0: i8) -> i32;
    fn i8_from_i32(&mut self, arg0: i8) -> Option<i32>;
    fn i8_try_into_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_unwrap_into_u32(&mut self, arg0: i8) -> u32;
    fn i8_from_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_into_i64(&mut self, arg0: i8) -> i64;
    fn i8_from_i64(&mut self, arg0: i8) -> Option<i64>;
    fn i8_try_into_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_unwrap_into_u64(&mut self, arg0: i8) -> u64;
    fn i8_from_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_into_i128(&mut self, arg0: i8) -> i128;
    fn i8_from_i128(&mut self, arg0: i8) -> Option<i128>;
    fn i8_try_into_u128(&mut self, arg0: i8) -> Option<u128>;
    fn i8_unwrap_into_u128(&mut self, arg0: i8) -> u128;
    fn i8_from_u128(&mut self, arg0: i8) -> Option<u128>;
    fn u8_try_into_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_unwrap_into_i8(&mut self, arg0: u8) -> i8;
    fn u8_cast_signed(&mut self, arg0: u8) -> i8;
    fn u8_from_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_into_i16(&mut self, arg0: u8) -> i16;
    fn u8_from_i16(&mut self, arg0: u8) -> Option<i16>;
    fn u8_into_u16(&mut self, arg0: u8) -> u16;
    fn u8_from_u16(&mut self, arg0: u8) -> Option<u16>;
    fn u8_into_i32(&mut self, arg0: u8) -> i32;
    fn u8_from_i32(&mut self, arg0: u8) -> Option<i32>;
    fn u8_into_u32(&mut self, arg0: u8) -> u32;
    fn u8_from_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_into_i64(&mut self, arg0: u8) -> i64;
    fn u8_from_i64(&mut self, arg0: u8) -> Option<i64>;
    fn u8_into_u64(&mut self, arg0: u8) -> u64;
    fn u8_from_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u8_into_i128(&mut self, arg0: u8) -> i128;
    fn u8_from_i128(&mut self, arg0: u8) -> Option<i128>;
    fn u8_into_u128(&mut self, arg0: u8) -> u128;
    fn u8_from_u128(&mut self, arg0: u8) -> Option<u128>;
    fn i16_try_into_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_unwrap_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_truncate_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_from_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_try_into_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_unwrap_into_u8(&mut self, arg0: i16) -> u8;
    fn i16_from_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_try_into_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_unwrap_into_u16(&mut self, arg0: i16) -> u16;
    fn i16_cast_unsigned(&mut self, arg0: i16) -> u16;
    fn i16_from_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_into_i32(&mut self, arg0: i16) -> i32;
    fn i16_from_i32(&mut self, arg0: i16) -> Option<i32>;
    fn i16_try_into_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_unwrap_into_u32(&mut self, arg0: i16) -> u32;
    fn i16_from_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_into_i64(&mut self, arg0: i16) -> i64;
    fn i16_from_i64(&mut self, arg0: i16) -> Option<i64>;
    fn i16_try_into_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_unwrap_into_u64(&mut self, arg0: i16) -> u64;
    fn i16_from_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_into_i128(&mut self, arg0: i16) -> i128;
    fn i16_from_i128(&mut self, arg0: i16) -> Option<i128>;
    fn i16_try_into_u128(&mut self, arg0: i16) -> Option<u128>;
    fn i16_unwrap_into_u128(&mut self, arg0: i16) -> u128;
    fn i16_from_u128(&mut self, arg0: i16) -> Option<u128>;
    fn u16_try_into_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_unwrap_into_i8(&mut self, arg0: u16) -> i8;
    fn u16_from_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_try_into_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_unwrap_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_truncate_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_from_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_try_into_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_unwrap_into_i16(&mut self, arg0: u16) -> i16;
    fn u16_cast_signed(&mut self, arg0: u16) -> i16;
    fn u16_from_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_into_i32(&mut self, arg0: u16) -> i32;
    fn u16_from_i32(&mut self, arg0: u16) -> Option<i32>;
    fn u16_into_u32(&mut self, arg0: u16) -> u32;
    fn u16_from_u32(&mut self, arg0: u16) -> Option<u32>;
    fn u16_into_i64(&mut self, arg0: u16) -> i64;
    fn u16_from_i64(&mut self, arg0: u16) -> Option<i64>;
    fn u16_into_u64(&mut self, arg0: u16) -> u64;
    fn u16_from_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u16_into_i128(&mut self, arg0: u16) -> i128;
    fn u16_from_i128(&mut self, arg0: u16) -> Option<i128>;
    fn u16_into_u128(&mut self, arg0: u16) -> u128;
    fn u16_from_u128(&mut self, arg0: u16) -> Option<u128>;
    fn i32_try_into_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_unwrap_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_truncate_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_from_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_try_into_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_unwrap_into_u8(&mut self, arg0: i32) -> u8;
    fn i32_from_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_try_into_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_unwrap_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_truncate_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_from_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_try_into_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_unwrap_into_u16(&mut self, arg0: i32) -> u16;
    fn i32_from_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_try_into_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_unwrap_into_u32(&mut self, arg0: i32) -> u32;
    fn i32_cast_unsigned(&mut self, arg0: i32) -> u32;
    fn i32_from_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_into_i64(&mut self, arg0: i32) -> i64;
    fn i32_from_i64(&mut self, arg0: i32) -> Option<i64>;
    fn i32_try_into_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_unwrap_into_u64(&mut self, arg0: i32) -> u64;
    fn i32_from_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_into_i128(&mut self, arg0: i32) -> i128;
    fn i32_from_i128(&mut self, arg0: i32) -> Option<i128>;
    fn i32_try_into_u128(&mut self, arg0: i32) -> Option<u128>;
    fn i32_unwrap_into_u128(&mut self, arg0: i32) -> u128;
    fn i32_from_u128(&mut self, arg0: i32) -> Option<u128>;
    fn u32_try_into_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_unwrap_into_i8(&mut self, arg0: u32) -> i8;
    fn u32_from_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_try_into_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_unwrap_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_truncate_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_from_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_try_into_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_unwrap_into_i16(&mut self, arg0: u32) -> i16;
    fn u32_from_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_try_into_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_unwrap_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_truncate_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_from_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_try_into_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_unwrap_into_i32(&mut self, arg0: u32) -> i32;
    fn u32_cast_signed(&mut self, arg0: u32) -> i32;
    fn u32_from_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_into_i64(&mut self, arg0: u32) -> i64;
    fn u32_from_i64(&mut self, arg0: u32) -> Option<i64>;
    fn u32_into_u64(&mut self, arg0: u32) -> u64;
    fn u32_from_u64(&mut self, arg0: u32) -> Option<u64>;
    fn u32_into_i128(&mut self, arg0: u32) -> i128;
    fn u32_from_i128(&mut self, arg0: u32) -> Option<i128>;
    fn u32_into_u128(&mut self, arg0: u32) -> u128;
    fn u32_from_u128(&mut self, arg0: u32) -> Option<u128>;
    fn i64_try_into_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_unwrap_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_truncate_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_from_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_try_into_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_unwrap_into_u8(&mut self, arg0: i64) -> u8;
    fn i64_from_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_try_into_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_unwrap_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_truncate_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_from_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_try_into_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_unwrap_into_u16(&mut self, arg0: i64) -> u16;
    fn i64_from_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_try_into_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_unwrap_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_truncate_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_from_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_try_into_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_unwrap_into_u32(&mut self, arg0: i64) -> u32;
    fn i64_from_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_try_into_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_unwrap_into_u64(&mut self, arg0: i64) -> u64;
    fn i64_cast_unsigned(&mut self, arg0: i64) -> u64;
    fn i64_from_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_into_i128(&mut self, arg0: i64) -> i128;
    fn i64_from_i128(&mut self, arg0: i64) -> Option<i128>;
    fn i64_try_into_u128(&mut self, arg0: i64) -> Option<u128>;
    fn i64_unwrap_into_u128(&mut self, arg0: i64) -> u128;
    fn i64_from_u128(&mut self, arg0: i64) -> Option<u128>;
    fn u64_try_into_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_unwrap_into_i8(&mut self, arg0: u64) -> i8;
    fn u64_from_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_try_into_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_unwrap_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_truncate_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_from_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_try_into_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_unwrap_into_i16(&mut self, arg0: u64) -> i16;
    fn u64_from_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_try_into_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_unwrap_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_truncate_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_from_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_try_into_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_unwrap_into_i32(&mut self, arg0: u64) -> i32;
    fn u64_from_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_try_into_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_unwrap_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_truncate_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_from_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_try_into_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_unwrap_into_i64(&mut self, arg0: u64) -> i64;
    fn u64_cast_signed(&mut self, arg0: u64) -> i64;
    fn u64_from_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_into_i128(&mut self, arg0: u64) -> i128;
    fn u64_from_i128(&mut self, arg0: u64) -> Option<i128>;
    fn u64_into_u128(&mut self, arg0: u64) -> u128;
    fn u64_from_u128(&mut self, arg0: u64) -> Option<u128>;
    fn i128_try_into_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_unwrap_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_truncate_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_from_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_try_into_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_unwrap_into_u8(&mut self, arg0: i128) -> u8;
    fn i128_from_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_try_into_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_unwrap_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_truncate_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_from_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_try_into_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_unwrap_into_u16(&mut self, arg0: i128) -> u16;
    fn i128_from_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_try_into_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_unwrap_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_truncate_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_from_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_try_into_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_unwrap_into_u32(&mut self, arg0: i128) -> u32;
    fn i128_from_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_try_into_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_unwrap_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_truncate_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_from_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_try_into_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_unwrap_into_u64(&mut self, arg0: i128) -> u64;
    fn i128_from_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_try_into_u128(&mut self, arg0: i128) -> Option<u128>;
    fn i128_unwrap_into_u128(&mut self, arg0: i128) -> u128;
    fn i128_cast_unsigned(&mut self, arg0: i128) -> u128;
    fn i128_from_u128(&mut self, arg0: i128) -> Option<u128>;
    fn u128_try_into_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_unwrap_into_i8(&mut self, arg0: u128) -> i8;
    fn u128_from_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_try_into_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_unwrap_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_truncate_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_from_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_try_into_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_unwrap_into_i16(&mut self, arg0: u128) -> i16;
    fn u128_from_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_try_into_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_unwrap_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_truncate_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_from_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_try_into_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_unwrap_into_i32(&mut self, arg0: u128) -> i32;
    fn u128_from_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_try_into_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_unwrap_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_truncate_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_from_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_try_into_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_unwrap_into_i64(&mut self, arg0: u128) -> i64;
    fn u128_from_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_try_into_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_unwrap_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_truncate_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_from_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_try_into_i128(&mut self, arg0: u128) -> Option<i128>;
    fn u128_unwrap_into_i128(&mut self, arg0: u128) -> i128;
    fn u128_cast_signed(&mut self, arg0: u128) -> i128;
    fn u128_from_i128(&mut self, arg0: u128) -> Option<i128>;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
}

pub trait IntoContextIter {
    type Context;
    type Output;
    type IntoIter: ContextIter<Context = Self::Context, Output = Self::Output>;
    fn into_context_iter(self) -> Self::IntoIter;
}

pub trait Length {
    fn len(&self) -> usize;
}

impl<T> Length for std::vec::Vec<T> {
    fn len(&self) -> usize {
        std::vec::Vec::len(self)
    }
}

pub struct ContextIterWrapper<I, C> {
    iter: I,
    _ctx: std::marker::PhantomData<C>,
}
impl<I: Default, C> Default for ContextIterWrapper<I, C> {
    fn default() -> Self {
        ContextIterWrapper {
            iter: I::default(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<I, C> std::ops::Deref for ContextIterWrapper<I, C> {
    type Target = I;
    fn deref(&self) -> &I {
        &self.iter
    }
}
impl<I, C> std::ops::DerefMut for ContextIterWrapper<I, C> {
    fn deref_mut(&mut self) -> &mut I {
        &mut self.iter
    }
}
impl<I: Iterator, C: Context> From<I> for ContextIterWrapper<I, C> {
    fn from(iter: I) -> Self {
        Self { iter, _ctx: std::marker::PhantomData }
    }
}
impl<I: Iterator, C: Context> ContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}
impl<I: IntoIterator, C: Context> IntoContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    type IntoIter = ContextIterWrapper<I::IntoIter, C>;
    fn into_context_iter(self) -> Self::IntoIter {
        ContextIterWrapper {
            iter: self.iter.into_iter(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<T, E: Extend<T>, C> Extend<T> for ContextIterWrapper<E, C> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        self.iter.extend(iter);
    }
}
impl<L: Length, C> Length for ContextIterWrapper<L, C> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}
           

/// Internal type SkeletonInstSimplification: defined at src/prelude_opt.isle line 63.
#[derive(Clone, Debug)]
pub enum SkeletonInstSimplification {
    Remove,
    RemoveWithVal {
        val: Value,
    },
    Replace {
        inst: Inst,
    },
    ReplaceWithVal {
        inst: Inst,
        val: Value,
    },
}

/// Internal type DivConstMagicU32: defined at src/prelude_opt.isle line 229.
#[derive(Clone, Debug)]
pub enum DivConstMagicU32 {
    U32 {
        mul_by: u32,
        do_add: bool,
        shift_by: u32,
    },
}

/// Internal type DivConstMagicU64: defined at src/prelude_opt.isle line 232.
#[derive(Clone, Debug)]
pub enum DivConstMagicU64 {
    U64 {
        mul_by: u64,
        do_add: bool,
        shift_by: u32,
    },
}

/// Internal type DivConstMagicS32: defined at src/prelude_opt.isle line 235.
#[derive(Clone, Debug)]
pub enum DivConstMagicS32 {
    S32 {
        mul_by: i32,
        shift_by: u32,
    },
}

/// Internal type DivConstMagicS64: defined at src/prelude_opt.isle line 237.
#[derive(Clone, Debug)]
pub enum DivConstMagicS64 {
    S64 {
        mul_by: i64,
        shift_by: u32,
    },
}

// Generated as internal constructor for term ty_shift_mask.
pub fn constructor_ty_shift_mask<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> u64 {
    let v1 = C::lane_type(ctx, arg0);
    let v2 = C::ty_bits(ctx, v1);
    let v3 = C::u8_into_u64(ctx, v2);
    let v5 = C::u64_sub(ctx, v3, 0x1_u64);
    // Rule at src/prelude.isle line 293.
    return v5;
}

// Generated as internal constructor for term spaceship_s.
pub fn constructor_spaceship_s<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_sgt(ctx, arg0, arg1, arg2);
    let v5 = constructor_slt(ctx, arg0, arg1, arg2);
    let v6 = constructor_isub(ctx, I8, v4, v5);
    // Rule at src/prelude_opt.isle line 51.
    return v6;
}

// Generated as internal constructor for term spaceship_u.
pub fn constructor_spaceship_u<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_ugt(ctx, arg0, arg1, arg2);
    let v5 = constructor_ult(ctx, arg0, arg1, arg2);
    let v6 = constructor_isub(ctx, I8, v4, v5);
    // Rule at src/prelude_opt.isle line 54.
    return v6;
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
    returns: &mut (impl Extend<Value> + Length),
) -> () {
    let mut v1 = C::inst_data_value_etor_returns::default();
    C::inst_data_value_etor(ctx, arg0, &mut v1);
    let mut v1 = v1.into_context_iter();
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v5,
                args: ref v6,
            } => {
                match v5 {
                    &Opcode::Smin => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v26,
                                arg: v27,
                            } = &v11.1 {
                                if let &Opcode::Splat = v26 {
                                    if v2.0 == v11.0 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v29,
                                                arg: v30,
                                            } = &v19.1 {
                                                if let &Opcode::Splat = v29 {
                                                    if v2.0 == v19.0 {
                                                        let v1353 = C::lane_type(ctx, v2.0);
                                                        let v1497 = constructor_smin(ctx, v1353, v30, v27);
                                                        let v1498 = constructor_splat(ctx, v2.0, v1497);
                                                        // Rule at src/opts/vector.isle line 54.
                                                        returns.extend(Some(v1498));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Umin => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v26,
                                arg: v27,
                            } = &v11.1 {
                                if let &Opcode::Splat = v26 {
                                    if v2.0 == v11.0 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v29,
                                                arg: v30,
                                            } = &v19.1 {
                                                if let &Opcode::Splat = v29 {
                                                    if v2.0 == v19.0 {
                                                        let v1353 = C::lane_type(ctx, v2.0);
                                                        let v1499 = constructor_umin(ctx, v1353, v30, v27);
                                                        let v1500 = constructor_splat(ctx, v2.0, v1499);
                                                        // Rule at src/opts/vector.isle line 57.
                                                        returns.extend(Some(v1500));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Smax => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v26,
                                arg: v27,
                            } = &v11.1 {
                                if let &Opcode::Splat = v26 {
                                    if v2.0 == v11.0 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v29,
                                                arg: v30,
                                            } = &v19.1 {
                                                if let &Opcode::Splat = v29 {
                                                    if v2.0 == v19.0 {
                                                        let v1353 = C::lane_type(ctx, v2.0);
                                                        let v1501 = constructor_smax(ctx, v1353, v30, v27);
                                                        let v1502 = constructor_splat(ctx, v2.0, v1501);
                                                        // Rule at src/opts/vector.isle line 60.
                                                        returns.extend(Some(v1502));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Umax => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v26,
                                arg: v27,
                            } = &v11.1 {
                                if let &Opcode::Splat = v26 {
                                    if v2.0 == v11.0 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v29,
                                                arg: v30,
                                            } = &v19.1 {
                                                if let &Opcode::Splat = v29 {
                                                    if v2.0 == v19.0 {
                                                        let v1353 = C::lane_type(ctx, v2.0);
                                                        let v1503 = constructor_umax(ctx, v1353, v30, v27);
                                                        let v1504 = constructor_splat(ctx, v2.0, v1503);
                                                        // Rule at src/opts/vector.isle line 63.
                                                        returns.extend(Some(v1504));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Iadd => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    match v122 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    match &v11.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v104,
                                                            args: ref v105,
                                                        } => {
                                                            if let &Opcode::Iadd = v104 {
                                                                if v2.0 == v11.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let mut v109 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                    let mut v109 = v109.into_context_iter();
                                                                    while let Some(v110) = v109.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v756,
                                                                            imm: v757,
                                                                        } = &v110.1 {
                                                                            if let &Opcode::Iconst = v756 {
                                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                let mut v199 = v199.into_context_iter();
                                                                                while let Some(v200) = v199.next(ctx) {
                                                                                    if let &InstructionData::UnaryImm {
                                                                                        opcode: ref v248,
                                                                                        imm: v249,
                                                                                    } = &v200.1 {
                                                                                        if let &Opcode::Iconst = v248 {
                                                                                            let v758 = constructor_iadd(ctx, v2.0, v124.0, v106.0);
                                                                                            let v759 = constructor_iadd(ctx, v2.0, v124.1, v106.1);
                                                                                            let v760 = constructor_iadd(ctx, v2.0, v758, v759);
                                                                                            // Rule at src/opts/cprop.isle line 264.
                                                                                            returns.extend(Some(v760));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v14,
                                                            imm: v15,
                                                        } => {
                                                            if let &Opcode::Iconst = v14 {
                                                                if v2.0 == v11.0 {
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    let mut v199 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                    let mut v199 = v199.into_context_iter();
                                                                    while let Some(v200) = v199.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v248,
                                                                            imm: v249,
                                                                        } = &v200.1 {
                                                                            if let &Opcode::Iconst = v248 {
                                                                                if v2.0 == v200.0 {
                                                                                    let v646 = constructor_iadd(ctx, v2.0, v124.1, v7.1);
                                                                                    let v647 = constructor_iadd(ctx, v2.0, v124.0, v646);
                                                                                    // Rule at src/opts/cprop.isle line 146.
                                                                                    returns.extend(Some(v647));
                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                let mut v127 = v127.into_context_iter();
                                                while let Some(v128) = v127.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v131,
                                                        args: ref v132,
                                                    } = &v128.1 {
                                                        match v131 {
                                                            &Opcode::Iadd => {
                                                                if v2.0 == v128.0 {
                                                                    let v133 = C::unpack_value_array_2(ctx, v132);
                                                                    let v136 = constructor_iadd(ctx, v2.0, v133.0, v133.1);
                                                                    let v137 = constructor_iadd(ctx, v2.0, v124.1, v7.1);
                                                                    let v138 = constructor_iadd(ctx, v2.0, v136, v137);
                                                                    let v139 = C::subsume(ctx, v138);
                                                                    // Rule at src/opts/arithmetic.isle line 218.
                                                                    returns.extend(Some(v139));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            &Opcode::Isub => {
                                                                if v2.0 == v128.0 {
                                                                    let v133 = C::unpack_value_array_2(ctx, v132);
                                                                    let v180 = constructor_isub(ctx, v2.0, v133.0, v133.1);
                                                                    let v137 = constructor_iadd(ctx, v2.0, v124.1, v7.1);
                                                                    let v188 = constructor_iadd(ctx, v2.0, v180, v137);
                                                                    let v189 = C::subsume(ctx, v188);
                                                                    // Rule at src/opts/arithmetic.isle line 282.
                                                                    returns.extend(Some(v189));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                let mut v127 = v127.into_context_iter();
                                                while let Some(v128) = v127.next(ctx) {
                                                    match &v128.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v131,
                                                            args: ref v132,
                                                        } => {
                                                            match v131 {
                                                                &Opcode::Iadd => {
                                                                    if v2.0 == v128.0 {
                                                                        let v133 = C::unpack_value_array_2(ctx, v132);
                                                                        let v136 = constructor_iadd(ctx, v2.0, v133.0, v133.1);
                                                                        let v183 = constructor_isub(ctx, v2.0, v124.1, v7.1);
                                                                        let v192 = constructor_isub(ctx, v2.0, v136, v183);
                                                                        let v193 = C::subsume(ctx, v192);
                                                                        // Rule at src/opts/arithmetic.isle line 290.
                                                                        returns.extend(Some(v193));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                                &Opcode::Isub => {
                                                                    if v2.0 == v128.0 {
                                                                        let v133 = C::unpack_value_array_2(ctx, v132);
                                                                        let v180 = constructor_isub(ctx, v2.0, v133.0, v133.1);
                                                                        let v183 = constructor_isub(ctx, v2.0, v124.1, v7.1);
                                                                        let v184 = constructor_isub(ctx, v2.0, v180, v183);
                                                                        let v185 = C::subsume(ctx, v184);
                                                                        // Rule at src/opts/arithmetic.isle line 274.
                                                                        returns.extend(Some(v185));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                                _ => {}
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v652,
                                                            imm: v653,
                                                        } => {
                                                            if let &Opcode::Iconst = v652 {
                                                                if v2.0 == v128.0 {
                                                                    let mut v10 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                                    let mut v10 = v10.into_context_iter();
                                                                    while let Some(v11) = v10.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v14,
                                                                            imm: v15,
                                                                        } = &v11.1 {
                                                                            if let &Opcode::Iconst = v14 {
                                                                                if v2.0 == v11.0 {
                                                                                    let v654 = C::u64_from_imm64(ctx, v653);
                                                                                    let v16 = C::u64_from_imm64(ctx, v15);
                                                                                    let v664 = C::u64_wrapping_add(ctx, v654, v16);
                                                                                    let v665 = C::imm64_masked(ctx, v2.0, v664);
                                                                                    let v666 = constructor_iconst(ctx, v2.0, v665);
                                                                                    let v667 = constructor_isub(ctx, v2.0, v666, v124.1);
                                                                                    // Rule at src/opts/cprop.isle line 172.
                                                                                    returns.extend(Some(v667));
                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                if v7.1 == v124.1 {
                                                    // Rule at src/opts/arithmetic.isle line 339.
                                                    returns.extend(Some(v124.0));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1 {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            if v2.0 == v200.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v250 = C::u64_from_imm64(ctx, v249);
                                                                                let v659 = C::u64_wrapping_sub(ctx, v16, v250);
                                                                                let v660 = C::imm64_masked(ctx, v2.0, v659);
                                                                                let v661 = constructor_iconst(ctx, v2.0, v660);
                                                                                let v663 = constructor_iadd(ctx, v2.0, v124.0, v661);
                                                                                // Rule at src/opts/cprop.isle line 168.
                                                                                returns.extend(Some(v663));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Band => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v104,
                                                        args: ref v105,
                                                    } = &v11.1 {
                                                        match v104 {
                                                            &Opcode::Bor => {
                                                                if v2.0 == v11.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    if v106.0 == v124.0 {
                                                                        if v106.1 == v124.1 {
                                                                            let v560 = constructor_iadd(ctx, v2.0, v124.0, v124.1);
                                                                            // Rule at src/opts/bitops.isle line 217.
                                                                            returns.extend(Some(v560));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            &Opcode::Bxor => {
                                                                if v2.0 == v11.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    if v106.0 == v124.0 {
                                                                        if v106.1 == v124.1 {
                                                                            let v241 = constructor_bor(ctx, v2.0, v124.0, v124.1);
                                                                            // Rule at src/opts/bitops.isle line 212.
                                                                            returns.extend(Some(v241));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v104,
                                                        args: ref v105,
                                                    } = &v11.1 {
                                                        if let &Opcode::Band = v104 {
                                                            if v2.0 == v11.0 {
                                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                if v106.0 == v124.0 {
                                                                    if v106.1 == v124.1 {
                                                                        let v560 = constructor_iadd(ctx, v2.0, v124.0, v124.1);
                                                                        // Rule at src/opts/bitops.isle line 216.
                                                                        returns.extend(Some(v560));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let mut v58 = C::inst_data_value_tupled_etor_returns::default();
                                                C::inst_data_value_tupled_etor(ctx, v7.1, &mut v58);
                                                let mut v58 = v58.into_context_iter();
                                                while let Some(v59) = v58.next(ctx) {
                                                    let v60 = C::iconst_sextend_etor(ctx, v59);
                                                    if let Some(v61) = v60 {
                                                        if v2.0 == v61.0 {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let mut v217 = C::inst_data_value_tupled_etor_returns::default();
                                                            C::inst_data_value_tupled_etor(ctx, v124.1, &mut v217);
                                                            let mut v217 = v217.into_context_iter();
                                                            while let Some(v218) = v217.next(ctx) {
                                                                let v219 = C::iconst_sextend_etor(ctx, v218);
                                                                if let Some(v220) = v219 {
                                                                    let v223 = C::i64_checked_neg(ctx, v220.1);
                                                                    if let Some(v224) = v223 {
                                                                        if v2.0 == v220.0 {
                                                                            if v61.1 == v224 {
                                                                                let v225 = C::i64_not(ctx, v220.1);
                                                                                let v226 = C::i64_cast_unsigned(ctx, v225);
                                                                                let v227 = C::imm64_masked(ctx, v2.0, v226);
                                                                                let v228 = constructor_iconst(ctx, v2.0, v227);
                                                                                let v229 = constructor_band(ctx, v2.0, v124.0, v228);
                                                                                // Rule at src/opts/arithmetic.isle line 326.
                                                                                returns.extend(Some(v229));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bxor => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v104,
                                                        args: ref v105,
                                                    } = &v11.1 {
                                                        if let &Opcode::Band = v104 {
                                                            if v2.0 == v11.0 {
                                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                if v106.0 == v124.0 {
                                                                    if v106.1 == v124.1 {
                                                                        let v241 = constructor_bor(ctx, v2.0, v124.0, v124.1);
                                                                        // Rule at src/opts/bitops.isle line 213.
                                                                        returns.extend(Some(v241));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ishl => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v104,
                                                        args: ref v105,
                                                    } = &v11.1 {
                                                        if let &Opcode::Ishl = v104 {
                                                            if v2.0 == v11.0 {
                                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                if v106.1 == v124.1 {
                                                                    let v758 = constructor_iadd(ctx, v2.0, v124.0, v106.0);
                                                                    let v1388 = constructor_ishl(ctx, v2.0, v758, v124.1);
                                                                    // Rule at src/opts/shifts.isle line 310.
                                                                    returns.extend(Some(v1388));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Ternary {
                                    opcode: ref v1262,
                                    args: ref v1263,
                                } => {
                                    if let &Opcode::Select = v1262 {
                                        if v2.0 == v19.0 {
                                            let mut v10 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                            let mut v10 = v10.into_context_iter();
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1 {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v1264 = C::unpack_value_array_3(ctx, v1263);
                                                            let mut v1268 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v1264.1, &mut v1268);
                                                            let mut v1268 = v1268.into_context_iter();
                                                            while let Some(v1269) = v1268.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v1272,
                                                                    imm: v1273,
                                                                } = &v1269.1 {
                                                                    if let &Opcode::Iconst = v1272 {
                                                                        if v2.0 == v1269.0 {
                                                                            let mut v1275 = C::inst_data_value_etor_returns::default();
                                                                            C::inst_data_value_etor(ctx, v1264.2, &mut v1275);
                                                                            let mut v1275 = v1275.into_context_iter();
                                                                            while let Some(v1276) = v1275.next(ctx) {
                                                                                if let &InstructionData::UnaryImm {
                                                                                    opcode: ref v1279,
                                                                                    imm: v1280,
                                                                                } = &v1276.1 {
                                                                                    if let &Opcode::Iconst = v1279 {
                                                                                        if v2.0 == v1276.0 {
                                                                                            let v1274 = C::u64_from_imm64(ctx, v1273);
                                                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                                                            let v1282 = C::u64_wrapping_add(ctx, v1274, v16);
                                                                                            let v1283 = C::imm64_masked(ctx, v2.0, v1282);
                                                                                            let v1284 = constructor_iconst(ctx, v2.0, v1283);
                                                                                            let v1281 = C::u64_from_imm64(ctx, v1280);
                                                                                            let v1285 = C::u64_wrapping_add(ctx, v1281, v16);
                                                                                            let v1286 = C::imm64_masked(ctx, v2.0, v1285);
                                                                                            let v1287 = constructor_iconst(ctx, v2.0, v1286);
                                                                                            let v1288 = constructor_select(ctx, v2.0, v1264.0, v1284, v1287);
                                                                                            // Rule at src/opts/selects.isle line 95.
                                                                                            returns.extend(Some(v1288));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    match v29 {
                                        &Opcode::Splat => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v26,
                                                        arg: v27,
                                                    } = &v11.1 {
                                                        if let &Opcode::Splat = v26 {
                                                            if v2.0 == v11.0 {
                                                                let v1353 = C::lane_type(ctx, v2.0);
                                                                let v1481 = constructor_iadd(ctx, v1353, v30, v27);
                                                                let v1482 = constructor_splat(ctx, v2.0, v1481);
                                                                // Rule at src/opts/vector.isle line 30.
                                                                returns.extend(Some(v1482));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ineg => {
                                            if v2.0 == v19.0 {
                                                let v31 = constructor_isub(ctx, v2.0, v7.1, v30);
                                                // Rule at src/opts/arithmetic.isle line 25.
                                                returns.extend(Some(v31));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1 {
                                                        if let &Opcode::Iconst = v14 {
                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                            if v16 == 0x1_u64 {
                                                                if v2.0 == v11.0 {
                                                                    let v65 = constructor_ineg(ctx, v2.0, v30);
                                                                    // Rule at src/opts/arithmetic.isle line 68.
                                                                    returns.extend(Some(v65));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            if v19.0 == v566 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1 {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 = C::u64_from_imm64(ctx, v23);
                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                let v575 = C::u64_wrapping_add(ctx, v24, v16);
                                                                let v576 = C::imm64_masked(ctx, v566, v575);
                                                                let v577 = constructor_iconst(ctx, v566, v576);
                                                                let v578 = C::subsume(ctx, v577);
                                                                // Rule at src/opts/cprop.isle line 13.
                                                                returns.extend(Some(v578));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if v2.0 == v19.0 {
                                            let v637 = constructor_iadd(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 115.
                                            returns.extend(Some(v637));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 3.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    match v104 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v113,
                                                        args: ref v114,
                                                    } = &v110.1 {
                                                        match v113 {
                                                            &Opcode::Iadd => {
                                                                if v2.0 == v110.0 {
                                                                    let v118 = constructor_iadd(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v119 = constructor_iadd(ctx, v2.0, v115.0, v115.1);
                                                                    let v120 = constructor_iadd(ctx, v2.0, v118, v119);
                                                                    let v121 = C::subsume(ctx, v120);
                                                                    // Rule at src/opts/arithmetic.isle line 216.
                                                                    returns.extend(Some(v121));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            &Opcode::Isub => {
                                                                if v2.0 == v110.0 {
                                                                    let v118 = constructor_iadd(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v165 = constructor_isub(ctx, v2.0, v115.0, v115.1);
                                                                    let v178 = constructor_iadd(ctx, v2.0, v118, v165);
                                                                    let v179 = C::subsume(ctx, v178);
                                                                    // Rule at src/opts/arithmetic.isle line 264.
                                                                    returns.extend(Some(v179));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v113,
                                                        args: ref v114,
                                                    } = &v110.1 {
                                                        match v113 {
                                                            &Opcode::Iadd => {
                                                                if v2.0 == v110.0 {
                                                                    let v118 = constructor_iadd(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v119 = constructor_iadd(ctx, v2.0, v115.0, v115.1);
                                                                    let v176 = constructor_isub(ctx, v2.0, v118, v119);
                                                                    let v177 = C::subsume(ctx, v176);
                                                                    // Rule at src/opts/arithmetic.isle line 260.
                                                                    returns.extend(Some(v177));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            &Opcode::Isub => {
                                                                if v2.0 == v110.0 {
                                                                    let v118 = constructor_iadd(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v165 = constructor_isub(ctx, v2.0, v115.0, v115.1);
                                                                    let v174 = constructor_isub(ctx, v2.0, v118, v165);
                                                                    let v175 = C::subsume(ctx, v174);
                                                                    // Rule at src/opts/arithmetic.isle line 256.
                                                                    returns.extend(Some(v175));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                if v7.0 == v106.1 {
                                                    // Rule at src/opts/arithmetic.isle line 340.
                                                    returns.extend(Some(v106.0));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    if let &Opcode::Ineg = v26 {
                                        if v2.0 == v11.0 {
                                            let v28 = constructor_isub(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/arithmetic.isle line 23.
                                            returns.extend(Some(v28));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/arithmetic.isle line 7.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 5.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    match v122 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    match &v11.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v104,
                                                            args: ref v105,
                                                        } => {
                                                            if let &Opcode::Bor = v104 {
                                                                if v2.0 == v11.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    if v106.0 == v124.0 {
                                                                        if v106.1 == v124.1 {
                                                                            let v230 = constructor_band(ctx, v2.0, v124.0, v124.1);
                                                                            // Rule at src/opts/arithmetic.isle line 333.
                                                                            returns.extend(Some(v230));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v14,
                                                            imm: v15,
                                                        } => {
                                                            if let &Opcode::Iconst = v14 {
                                                                if v2.0 == v11.0 {
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    let mut v199 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                    let mut v199 = v199.into_context_iter();
                                                                    while let Some(v200) = v199.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v248,
                                                                            imm: v249,
                                                                        } = &v200.1 {
                                                                            if let &Opcode::Iconst = v248 {
                                                                                if v2.0 == v200.0 {
                                                                                    let v16 = C::u64_from_imm64(ctx, v15);
                                                                                    let v250 = C::u64_from_imm64(ctx, v249);
                                                                                    let v659 = C::u64_wrapping_sub(ctx, v16, v250);
                                                                                    let v660 = C::imm64_masked(ctx, v2.0, v659);
                                                                                    let v661 = constructor_iconst(ctx, v2.0, v660);
                                                                                    let v662 = constructor_isub(ctx, v2.0, v124.0, v661);
                                                                                    // Rule at src/opts/cprop.isle line 164.
                                                                                    returns.extend(Some(v662));
                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                let mut v127 = v127.into_context_iter();
                                                while let Some(v128) = v127.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v131,
                                                        args: ref v132,
                                                    } = &v128.1 {
                                                        match v131 {
                                                            &Opcode::Iadd => {
                                                                if v2.0 == v128.0 {
                                                                    let v133 = C::unpack_value_array_2(ctx, v132);
                                                                    let v136 = constructor_iadd(ctx, v2.0, v133.0, v133.1);
                                                                    let v183 = constructor_isub(ctx, v2.0, v124.1, v7.1);
                                                                    let v194 = constructor_iadd(ctx, v2.0, v136, v183);
                                                                    let v195 = C::subsume(ctx, v194);
                                                                    // Rule at src/opts/arithmetic.isle line 294.
                                                                    returns.extend(Some(v195));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            &Opcode::Isub => {
                                                                if v2.0 == v128.0 {
                                                                    let v133 = C::unpack_value_array_2(ctx, v132);
                                                                    let v180 = constructor_isub(ctx, v2.0, v133.0, v133.1);
                                                                    let v183 = constructor_isub(ctx, v2.0, v124.1, v7.1);
                                                                    let v186 = constructor_iadd(ctx, v2.0, v180, v183);
                                                                    let v187 = C::subsume(ctx, v186);
                                                                    // Rule at src/opts/arithmetic.isle line 278.
                                                                    returns.extend(Some(v187));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                if v7.1 == v124.0 {
                                                    // Rule at src/opts/arithmetic.isle line 343.
                                                    returns.extend(Some(v124.1));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                if v7.1 == v124.1 {
                                                    // Rule at src/opts/arithmetic.isle line 344.
                                                    returns.extend(Some(v124.0));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                let mut v127 = v127.into_context_iter();
                                                while let Some(v128) = v127.next(ctx) {
                                                    match &v128.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v131,
                                                            args: ref v132,
                                                        } => {
                                                            match v131 {
                                                                &Opcode::Iadd => {
                                                                    if v2.0 == v128.0 {
                                                                        let v133 = C::unpack_value_array_2(ctx, v132);
                                                                        let v136 = constructor_iadd(ctx, v2.0, v133.0, v133.1);
                                                                        let v137 = constructor_iadd(ctx, v2.0, v124.1, v7.1);
                                                                        let v190 = constructor_isub(ctx, v2.0, v136, v137);
                                                                        let v191 = C::subsume(ctx, v190);
                                                                        // Rule at src/opts/arithmetic.isle line 286.
                                                                        returns.extend(Some(v191));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                                &Opcode::Isub => {
                                                                    if v2.0 == v128.0 {
                                                                        let v133 = C::unpack_value_array_2(ctx, v132);
                                                                        let v180 = constructor_isub(ctx, v2.0, v133.0, v133.1);
                                                                        let v137 = constructor_iadd(ctx, v2.0, v124.1, v7.1);
                                                                        let v181 = constructor_isub(ctx, v2.0, v180, v137);
                                                                        let v182 = C::subsume(ctx, v181);
                                                                        // Rule at src/opts/arithmetic.isle line 270.
                                                                        returns.extend(Some(v182));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                                _ => {}
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v652,
                                                            imm: v653,
                                                        } => {
                                                            if let &Opcode::Iconst = v652 {
                                                                if v2.0 == v128.0 {
                                                                    let mut v10 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                                    let mut v10 = v10.into_context_iter();
                                                                    while let Some(v11) = v10.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v14,
                                                                            imm: v15,
                                                                        } = &v11.1 {
                                                                            if let &Opcode::Iconst = v14 {
                                                                                if v2.0 == v11.0 {
                                                                                    let v654 = C::u64_from_imm64(ctx, v653);
                                                                                    let v16 = C::u64_from_imm64(ctx, v15);
                                                                                    let v655 = C::u64_wrapping_sub(ctx, v654, v16);
                                                                                    let v656 = C::imm64_masked(ctx, v2.0, v655);
                                                                                    let v657 = constructor_iconst(ctx, v2.0, v656);
                                                                                    let v658 = constructor_isub(ctx, v2.0, v657, v124.1);
                                                                                    // Rule at src/opts/cprop.isle line 160.
                                                                                    returns.extend(Some(v658));
                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1 {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            if v2.0 == v200.0 {
                                                                                let v250 = C::u64_from_imm64(ctx, v249);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v648 = C::u64_wrapping_add(ctx, v250, v16);
                                                                                let v649 = C::imm64_masked(ctx, v2.0, v648);
                                                                                let v650 = constructor_iconst(ctx, v2.0, v649);
                                                                                let v651 = constructor_isub(ctx, v2.0, v124.0, v650);
                                                                                // Rule at src/opts/cprop.isle line 156.
                                                                                returns.extend(Some(v651));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ishl => {
                                            if v2.0 == v19.0 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v104,
                                                        args: ref v105,
                                                    } = &v11.1 {
                                                        if let &Opcode::Ishl = v104 {
                                                            if v2.0 == v11.0 {
                                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                if v106.1 == v124.1 {
                                                                    let v1386 = constructor_isub(ctx, v2.0, v124.0, v106.0);
                                                                    let v1387 = constructor_ishl(ctx, v2.0, v1386, v124.1);
                                                                    // Rule at src/opts/shifts.isle line 309.
                                                                    returns.extend(Some(v1387));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    if let &Opcode::Splat = v29 {
                                        if v2.0 == v19.0 {
                                            let mut v10 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                            let mut v10 = v10.into_context_iter();
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v26,
                                                    arg: v27,
                                                } = &v11.1 {
                                                    if let &Opcode::Splat = v26 {
                                                        if v2.0 == v11.0 {
                                                            let v1353 = C::lane_type(ctx, v2.0);
                                                            let v1483 = constructor_isub(ctx, v1353, v30, v27);
                                                            let v1484 = constructor_splat(ctx, v2.0, v1483);
                                                            // Rule at src/opts/vector.isle line 33.
                                                            returns.extend(Some(v1484));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0_u64 {
                                                let v25 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 17.
                                                returns.extend(Some(v25));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            let v638 = constructor_isub(ctx, v2.0, v7.1, v7.0);
                                            let v639 = constructor_ineg(ctx, v2.0, v638);
                                            // Rule at src/opts/cprop.isle line 120.
                                            returns.extend(Some(v639));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            if v19.0 == v566 {
                                                let mut v10 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                                let mut v10 = v10.into_context_iter();
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1 {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 = C::u64_from_imm64(ctx, v23);
                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                let v579 = C::u64_wrapping_sub(ctx, v24, v16);
                                                                let v580 = C::imm64_masked(ctx, v566, v579);
                                                                let v581 = constructor_iconst(ctx, v566, v580);
                                                                let v582 = C::subsume(ctx, v581);
                                                                // Rule at src/opts/cprop.isle line 19.
                                                                returns.extend(Some(v582));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 7.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    match v104 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v113,
                                                        args: ref v114,
                                                    } = &v110.1 {
                                                        match v113 {
                                                            &Opcode::Iadd => {
                                                                if v2.0 == v110.0 {
                                                                    let v164 = constructor_isub(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v119 = constructor_iadd(ctx, v2.0, v115.0, v115.1);
                                                                    let v172 = constructor_isub(ctx, v2.0, v164, v119);
                                                                    let v173 = C::subsume(ctx, v172);
                                                                    // Rule at src/opts/arithmetic.isle line 252.
                                                                    returns.extend(Some(v173));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            &Opcode::Isub => {
                                                                if v2.0 == v110.0 {
                                                                    let v164 = constructor_isub(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v165 = constructor_isub(ctx, v2.0, v115.0, v115.1);
                                                                    let v170 = constructor_isub(ctx, v2.0, v164, v165);
                                                                    let v171 = C::subsume(ctx, v170);
                                                                    // Rule at src/opts/arithmetic.isle line 248.
                                                                    returns.extend(Some(v171));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v113,
                                                        args: ref v114,
                                                    } = &v110.1 {
                                                        match v113 {
                                                            &Opcode::Iadd => {
                                                                if v2.0 == v110.0 {
                                                                    let v164 = constructor_isub(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v119 = constructor_iadd(ctx, v2.0, v115.0, v115.1);
                                                                    let v168 = constructor_iadd(ctx, v2.0, v164, v119);
                                                                    let v169 = C::subsume(ctx, v168);
                                                                    // Rule at src/opts/arithmetic.isle line 244.
                                                                    returns.extend(Some(v169));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            &Opcode::Isub => {
                                                                if v2.0 == v110.0 {
                                                                    let v164 = constructor_isub(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v165 = constructor_isub(ctx, v2.0, v115.0, v115.1);
                                                                    let v166 = constructor_iadd(ctx, v2.0, v164, v165);
                                                                    let v167 = C::subsume(ctx, v166);
                                                                    // Rule at src/opts/arithmetic.isle line 240.
                                                                    returns.extend(Some(v167));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    if let &Opcode::Ineg = v26 {
                                        if v2.0 == v11.0 {
                                            let v44 = constructor_iadd(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/arithmetic.isle line 30.
                                            returns.extend(Some(v44));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/arithmetic.isle line 12.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 9.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                let v56 = C::subsume(ctx, v55);
                                // Rule at src/opts/arithmetic.isle line 49.
                                returns.extend(Some(v56));
                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                            }
                        }
                        let mut v58 = C::inst_data_value_tupled_etor_returns::default();
                        C::inst_data_value_tupled_etor(ctx, v7.1, &mut v58);
                        let mut v58 = v58.into_context_iter();
                        while let Some(v59) = v58.next(ctx) {
                            let v60 = C::iconst_sextend_etor(ctx, v59);
                            if let Some(v61) = v60 {
                                let v715 = C::i64_wrapping_neg(ctx, v61.1);
                                let v716 = C::i64_cast_unsigned(ctx, v715);
                                let v717 = C::i64_cast_unsigned(ctx, v61.1);
                                let v718 = C::u64_lt(ctx, v716, v717);
                                if v718 == true {
                                    if v2.0 == v61.0 {
                                        let v719 = C::imm64_masked(ctx, v2.0, v716);
                                        let v720 = constructor_iconst(ctx, v2.0, v719);
                                        let v721 = constructor_iadd(ctx, v2.0, v7.0, v720);
                                        // Rule at src/opts/cprop.isle line 219.
                                        returns.extend(Some(v721));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    match v104 {
                                        &Opcode::Imul => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    match &v110.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v113,
                                                            args: ref v114,
                                                        } => {
                                                            if let &Opcode::Imul = v113 {
                                                                if v2.0 == v110.0 {
                                                                    let v140 = constructor_imul(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v141 = constructor_imul(ctx, v2.0, v115.0, v115.1);
                                                                    let v142 = constructor_imul(ctx, v2.0, v140, v141);
                                                                    let v143 = C::subsume(ctx, v142);
                                                                    // Rule at src/opts/arithmetic.isle line 221.
                                                                    returns.extend(Some(v143));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v756,
                                                            imm: v757,
                                                        } => {
                                                            if let &Opcode::Iconst = v756 {
                                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                                let mut v18 = v18.into_context_iter();
                                                                while let Some(v19) = v18.next(ctx) {
                                                                    if let &InstructionData::Binary {
                                                                        opcode: ref v122,
                                                                        args: ref v123,
                                                                    } = &v19.1 {
                                                                        if let &Opcode::Imul = v122 {
                                                                            if v2.0 == v19.0 {
                                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                let mut v199 = v199.into_context_iter();
                                                                                while let Some(v200) = v199.next(ctx) {
                                                                                    if let &InstructionData::UnaryImm {
                                                                                        opcode: ref v248,
                                                                                        imm: v249,
                                                                                    } = &v200.1 {
                                                                                        if let &Opcode::Iconst = v248 {
                                                                                            let v761 = constructor_imul(ctx, v2.0, v124.0, v106.0);
                                                                                            let v762 = constructor_imul(ctx, v2.0, v124.1, v106.1);
                                                                                            let v763 = constructor_imul(ctx, v2.0, v761, v762);
                                                                                            // Rule at src/opts/cprop.isle line 268.
                                                                                            returns.extend(Some(v763));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ishl => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                let mut v231 = C::inst_data_value_tupled_etor_returns::default();
                                                C::inst_data_value_tupled_etor(ctx, v106.0, &mut v231);
                                                let mut v231 = v231.into_context_iter();
                                                while let Some(v232) = v231.next(ctx) {
                                                    let v233 = C::iconst_sextend_etor(ctx, v232);
                                                    if let Some(v234) = v233 {
                                                        if v234.1 == 1_i64 {
                                                            if v2.0 == v234.0 {
                                                                let v237 = constructor_ishl(ctx, v2.0, v7.0, v106.1);
                                                                // Rule at src/opts/arithmetic.isle line 336.
                                                                returns.extend(Some(v237));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Splat => {
                                            if v2.0 == v11.0 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v29,
                                                        arg: v30,
                                                    } = &v19.1 {
                                                        if let &Opcode::Splat = v29 {
                                                            if v2.0 == v19.0 {
                                                                let v1353 = C::lane_type(ctx, v2.0);
                                                                let v1485 = constructor_imul(ctx, v1353, v30, v27);
                                                                let v1486 = constructor_splat(ctx, v2.0, v1485);
                                                                // Rule at src/opts/vector.isle line 36.
                                                                returns.extend(Some(v1486));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ineg => {
                                            if v2.0 == v11.0 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v29,
                                                        arg: v30,
                                                    } = &v19.1 {
                                                        if let &Opcode::Ineg = v29 {
                                                            if v2.0 == v19.0 {
                                                                let v48 = constructor_imul(ctx, v2.0, v30, v27);
                                                                let v49 = C::subsume(ctx, v48);
                                                                // Rule at src/opts/arithmetic.isle line 37.
                                                                returns.extend(Some(v49));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        match v16 {
                                            0x0_u64 => {
                                                if v2.0 == v11.0 {
                                                    let v57 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/arithmetic.isle line 58.
                                                    returns.extend(Some(v57));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                            0x1_u64 => {
                                                if v2.0 == v11.0 {
                                                    let v17 = C::subsume(ctx, v7.0);
                                                    // Rule at src/opts/arithmetic.isle line 52.
                                                    returns.extend(Some(v17));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                            0x2_u64 => {
                                                let v73 = constructor_iadd(ctx, v2.0, v7.0, v7.0);
                                                // Rule at src/opts/arithmetic.isle line 172.
                                                returns.extend(Some(v73));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            _ => {}
                                        }
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v122,
                                                    args: ref v123,
                                                } => {
                                                    if let &Opcode::Imul = v122 {
                                                        if v2.0 == v11.0 {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            if v2.0 == v200.0 {
                                                                                let v668 = constructor_imul(ctx, v2.0, v124.1, v7.1);
                                                                                let v669 = constructor_imul(ctx, v2.0, v124.0, v668);
                                                                                // Rule at src/opts/cprop.isle line 177.
                                                                                returns.extend(Some(v669));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v565 = C::fits_in_64(ctx, v2.0);
                                                        if let Some(v566) = v565 {
                                                            if v11.0 == v19.0 {
                                                                if v11.0 == v566 {
                                                                    let v24 = C::u64_from_imm64(ctx, v23);
                                                                    let v583 = C::u64_wrapping_mul(ctx, v24, v16);
                                                                    let v584 = C::imm64_masked(ctx, v566, v583);
                                                                    let v585 = constructor_iconst(ctx, v566, v584);
                                                                    let v586 = C::subsume(ctx, v585);
                                                                    // Rule at src/opts/cprop.isle line 25.
                                                                    returns.extend(Some(v586));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        let v74 = C::imm64_power_of_two(ctx, v15);
                                        if let Some(v75) = v74 {
                                            let v76 = C::imm64(ctx, v75);
                                            let v77 = constructor_iconst(ctx, v2.0, v76);
                                            let v78 = constructor_ishl(ctx, v2.0, v7.0, v77);
                                            // Rule at src/opts/arithmetic.isle line 180.
                                            returns.extend(Some(v78));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    if let &Opcode::Imul = v122 {
                                        if v2.0 == v19.0 {
                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                            let mut v127 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                            let mut v127 = v127.into_context_iter();
                                            while let Some(v128) = v127.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v131,
                                                    args: ref v132,
                                                } = &v128.1 {
                                                    if let &Opcode::Imul = v131 {
                                                        if v2.0 == v128.0 {
                                                            let v133 = C::unpack_value_array_2(ctx, v132);
                                                            let v144 = constructor_imul(ctx, v2.0, v133.0, v133.1);
                                                            let v145 = constructor_imul(ctx, v2.0, v124.1, v7.1);
                                                            let v146 = constructor_imul(ctx, v2.0, v144, v145);
                                                            let v147 = C::subsume(ctx, v146);
                                                            // Rule at src/opts/arithmetic.isle line 223.
                                                            returns.extend(Some(v147));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        let v79 = C::imm64_power_of_two(ctx, v23);
                                        if let Some(v80) = v79 {
                                            let v81 = C::imm64(ctx, v80);
                                            let v82 = constructor_iconst(ctx, v2.0, v81);
                                            let v83 = constructor_ishl(ctx, v2.0, v7.1, v82);
                                            // Rule at src/opts/arithmetic.isle line 182.
                                            returns.extend(Some(v83));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        if v2.0 == v19.0 {
                                            let v640 = constructor_imul(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 123.
                                            returns.extend(Some(v640));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v58 = C::inst_data_value_tupled_etor_returns::default();
                        C::inst_data_value_tupled_etor(ctx, v7.1, &mut v58);
                        let mut v58 = v58.into_context_iter();
                        while let Some(v59) = v58.next(ctx) {
                            let v60 = C::iconst_sextend_etor(ctx, v59);
                            if let Some(v61) = v60 {
                                if v61.1 == -1_i64 {
                                    if v2.0 == v61.0 {
                                        let v64 = constructor_ineg(ctx, v2.0, v7.0);
                                        // Rule at src/opts/arithmetic.isle line 64.
                                        returns.extend(Some(v64));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Umulhi => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v26,
                                arg: v27,
                            } = &v11.1 {
                                if let &Opcode::Splat = v26 {
                                    if v2.0 == v11.0 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v29,
                                                arg: v30,
                                            } = &v19.1 {
                                                if let &Opcode::Splat = v29 {
                                                    if v2.0 == v19.0 {
                                                        let v1353 = C::lane_type(ctx, v2.0);
                                                        let v1489 = constructor_umulhi(ctx, v1353, v30, v27);
                                                        let v1490 = constructor_splat(ctx, v2.0, v1489);
                                                        // Rule at src/opts/vector.isle line 42.
                                                        returns.extend(Some(v1490));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Smulhi => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v26,
                                arg: v27,
                            } = &v11.1 {
                                if let &Opcode::Splat = v26 {
                                    if v2.0 == v11.0 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v29,
                                                arg: v30,
                                            } = &v19.1 {
                                                if let &Opcode::Splat = v29 {
                                                    if v2.0 == v19.0 {
                                                        let v1353 = C::lane_type(ctx, v2.0);
                                                        let v1487 = constructor_smulhi(ctx, v1353, v30, v27);
                                                        let v1488 = constructor_splat(ctx, v2.0, v1487);
                                                        // Rule at src/opts/vector.isle line 39.
                                                        returns.extend(Some(v1488));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    match v104 {
                                        &Opcode::Band => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    match &v110.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v113,
                                                            args: ref v114,
                                                        } => {
                                                            if let &Opcode::Band = v113 {
                                                                if v2.0 == v110.0 {
                                                                    let v148 = constructor_band(ctx, v2.0, v7.0, v106.0);
                                                                    let v115 = C::unpack_value_array_2(ctx, v114);
                                                                    let v149 = constructor_band(ctx, v2.0, v115.0, v115.1);
                                                                    let v150 = constructor_band(ctx, v2.0, v148, v149);
                                                                    let v151 = C::subsume(ctx, v150);
                                                                    // Rule at src/opts/arithmetic.isle line 226.
                                                                    returns.extend(Some(v151));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v756,
                                                            imm: v757,
                                                        } => {
                                                            if let &Opcode::Iconst = v756 {
                                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                                let mut v18 = v18.into_context_iter();
                                                                while let Some(v19) = v18.next(ctx) {
                                                                    if let &InstructionData::Binary {
                                                                        opcode: ref v122,
                                                                        args: ref v123,
                                                                    } = &v19.1 {
                                                                        if let &Opcode::Band = v122 {
                                                                            if v2.0 == v19.0 {
                                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                let mut v199 = v199.into_context_iter();
                                                                                while let Some(v200) = v199.next(ctx) {
                                                                                    if let &InstructionData::UnaryImm {
                                                                                        opcode: ref v248,
                                                                                        imm: v249,
                                                                                    } = &v200.1 {
                                                                                        if let &Opcode::Iconst = v248 {
                                                                                            let v764 = constructor_band(ctx, v2.0, v124.0, v106.0);
                                                                                            let v765 = constructor_band(ctx, v2.0, v124.1, v106.1);
                                                                                            let v766 = constructor_band(ctx, v2.0, v764, v765);
                                                                                            // Rule at src/opts/cprop.isle line 272.
                                                                                            returns.extend(Some(v766));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                if v7.0 == v106.0 {
                                                    let v550 = constructor_band(ctx, v2.0, v7.0, v106.1);
                                                    // Rule at src/opts/bitops.isle line 202.
                                                    returns.extend(Some(v550));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                if v7.0 == v106.1 {
                                                    let v551 = constructor_band(ctx, v2.0, v106.0, v7.0);
                                                    // Rule at src/opts/bitops.isle line 203.
                                                    returns.extend(Some(v551));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        &Opcode::Bxor => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                if v7.0 == v106.0 {
                                                    let mut v109 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                    let mut v109 = v109.into_context_iter();
                                                    while let Some(v110) = v109.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v554,
                                                            arg: v555,
                                                        } = &v110.1 {
                                                            if let &Opcode::Bnot = v554 {
                                                                if v2.0 == v110.0 {
                                                                    let v556 = constructor_band(ctx, v2.0, v7.0, v555);
                                                                    // Rule at src/opts/bitops.isle line 208.
                                                                    returns.extend(Some(v556));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if v7.0 == v106.1 {
                                                    let mut v331 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v106.0, &mut v331);
                                                    let mut v331 = v331.into_context_iter();
                                                    while let Some(v332) = v331.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v557,
                                                            arg: v558,
                                                        } = &v332.1 {
                                                            if let &Opcode::Bnot = v557 {
                                                                if v2.0 == v332.0 {
                                                                    let v559 = constructor_band(ctx, v2.0, v7.0, v558);
                                                                    // Rule at src/opts/bitops.isle line 209.
                                                                    returns.extend(Some(v559));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ishl => {
                                            if v2.0 == v11.0 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v122,
                                                        args: ref v123,
                                                    } = &v19.1 {
                                                        if let &Opcode::Ishl = v122 {
                                                            if v2.0 == v19.0 {
                                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                if v106.1 == v124.1 {
                                                                    let v764 = constructor_band(ctx, v2.0, v124.0, v106.0);
                                                                    let v1385 = constructor_ishl(ctx, v2.0, v764, v124.1);
                                                                    // Rule at src/opts/shifts.isle line 308.
                                                                    returns.extend(Some(v1385));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v1109,
                                    args: ref v1110,
                                    cond: ref v1111,
                                } => {
                                    if let &Opcode::Icmp = v1109 {
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            if v11.0 == v566 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::IntCompare {
                                                        opcode: ref v1079,
                                                        args: ref v1080,
                                                        cond: ref v1081,
                                                    } = &v19.1 {
                                                        if let &Opcode::Icmp = v1079 {
                                                            let v1115 = constructor_intcc_comparable(ctx, v1081, v1111);
                                                            if let Some(v1116) = v1115 {
                                                                if v11.0 == v19.0 {
                                                                    let v1082 = C::unpack_value_array_2(ctx, v1080);
                                                                    let v1112 = C::unpack_value_array_2(ctx, v1110);
                                                                    if v1082.0 == v1112.0 {
                                                                        if v1082.1 == v1112.1 {
                                                                            let v1117 = constructor_decompose_intcc(ctx, v1081);
                                                                            let v1118 = constructor_decompose_intcc(ctx, v1111);
                                                                            let v1119 = C::u64_and(ctx, v1117, v1118);
                                                                            let v1120 = constructor_compose_icmp(ctx, v566, v1119, v1116, v1082.0, v1082.1);
                                                                            // Rule at src/opts/icmp.isle line 175.
                                                                            returns.extend(Some(v1120));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Splat => {
                                            let v1471 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v1472) = v1471 {
                                                if v2.0 == v11.0 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v29,
                                                            arg: v30,
                                                        } = &v19.1 {
                                                            if let &Opcode::Splat = v29 {
                                                                if v2.0 == v19.0 {
                                                                    let v1353 = C::lane_type(ctx, v2.0);
                                                                    let v1473 = constructor_band(ctx, v1353, v30, v27);
                                                                    let v1474 = constructor_splat(ctx, v2.0, v1473);
                                                                    // Rule at src/opts/vector.isle line 14.
                                                                    returns.extend(Some(v1474));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v7.0 == v27 {
                                                    if v11.0 == v53 {
                                                        let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                                        let v56 = C::subsume(ctx, v55);
                                                        // Rule at src/opts/bitops.isle line 34.
                                                        returns.extend(Some(v56));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let mut v18 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                            let mut v18 = v18.into_context_iter();
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v29,
                                                    arg: v30,
                                                } = &v19.1 {
                                                    if let &Opcode::Uextend = v29 {
                                                        let v971 = C::value_type(ctx, v30);
                                                        let v1006 = C::value_type(ctx, v27);
                                                        if v971 == v1006 {
                                                            let v1007 = constructor_band(ctx, v971, v30, v27);
                                                            let v1008 = constructor_uextend(ctx, v2.0, v1007);
                                                            // Rule at src/opts/extends.isle line 70.
                                                            returns.extend(Some(v1008));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v122,
                                                    args: ref v123,
                                                } => {
                                                    if let &Opcode::Band = v122 {
                                                        if v2.0 == v11.0 {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            if v2.0 == v200.0 {
                                                                                let v672 = constructor_band(ctx, v2.0, v124.1, v7.1);
                                                                                let v673 = constructor_band(ctx, v2.0, v124.0, v672);
                                                                                // Rule at src/opts/cprop.isle line 183.
                                                                                returns.extend(Some(v673));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::IntCompare {
                                                    opcode: ref v1079,
                                                    args: ref v1080,
                                                    cond: ref v1081,
                                                } => {
                                                    if let &Opcode::Icmp = v1079 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1_u64 {
                                                            let v52 = C::ty_int(ctx, v2.0);
                                                            if let Some(v53) = v52 {
                                                                // Rule at src/opts/icmp.isle line 86.
                                                                returns.extend(Some(v7.0));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::Unary {
                                                    opcode: ref v29,
                                                    arg: v30,
                                                } => {
                                                    match v29 {
                                                        &Opcode::Uextend => {
                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                            if v16 == 0x1_u64 {
                                                                let v52 = C::ty_int(ctx, v2.0);
                                                                if let Some(v53) = v52 {
                                                                    let mut v1085 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v30, &mut v1085);
                                                                    let mut v1085 = v1085.into_context_iter();
                                                                    while let Some(v1086) = v1085.next(ctx) {
                                                                        if let &InstructionData::IntCompare {
                                                                            opcode: ref v1089,
                                                                            args: ref v1090,
                                                                            cond: ref v1091,
                                                                        } = &v1086.1 {
                                                                            if let &Opcode::Icmp = v1089 {
                                                                                // Rule at src/opts/icmp.isle line 91.
                                                                                returns.extend(Some(v7.0));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            let v971 = C::value_type(ctx, v30);
                                                            let v972 = C::ty_mask(ctx, v971);
                                                            let v973 = C::u64_and(ctx, v16, v972);
                                                            let v974 = C::u64_eq(ctx, v972, v973);
                                                            if v974 == true {
                                                                // Rule at src/opts/extends.isle line 16.
                                                                returns.extend(Some(v7.0));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                        &Opcode::Sextend => {
                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                            let v971 = C::value_type(ctx, v30);
                                                            let v972 = C::ty_mask(ctx, v971);
                                                            let v975 = C::u64_eq(ctx, v16, v972);
                                                            if v975 == true {
                                                                let v976 = constructor_uextend(ctx, v2.0, v30);
                                                                // Rule at src/opts/extends.isle line 22.
                                                                returns.extend(Some(v976));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v565 = C::fits_in_64(ctx, v2.0);
                                                        if let Some(v566) = v565 {
                                                            if v11.0 == v19.0 {
                                                                if v11.0 == v566 {
                                                                    let v24 = C::u64_from_imm64(ctx, v23);
                                                                    let v16 = C::u64_from_imm64(ctx, v15);
                                                                    let v591 = C::u64_and(ctx, v24, v16);
                                                                    let v592 = C::imm64_masked(ctx, v566, v591);
                                                                    let v593 = constructor_iconst(ctx, v566, v592);
                                                                    let v594 = C::subsume(ctx, v593);
                                                                    // Rule at src/opts/cprop.isle line 61.
                                                                    returns.extend(Some(v594));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v57 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 33.
                                                returns.extend(Some(v57));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 13.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    match v122 {
                                        &Opcode::Band => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                if v7.1 == v124.0 {
                                                    let v230 = constructor_band(ctx, v2.0, v124.0, v124.1);
                                                    // Rule at src/opts/bitops.isle line 200.
                                                    returns.extend(Some(v230));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                if v7.1 == v124.1 {
                                                    let v230 = constructor_band(ctx, v2.0, v124.0, v124.1);
                                                    // Rule at src/opts/bitops.isle line 201.
                                                    returns.extend(Some(v230));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                let mut v127 = v127.into_context_iter();
                                                while let Some(v128) = v127.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v131,
                                                        args: ref v132,
                                                    } = &v128.1 {
                                                        if let &Opcode::Band = v131 {
                                                            if v2.0 == v128.0 {
                                                                let v133 = C::unpack_value_array_2(ctx, v132);
                                                                let v152 = constructor_band(ctx, v2.0, v133.0, v133.1);
                                                                let v153 = constructor_band(ctx, v2.0, v124.1, v7.1);
                                                                let v154 = constructor_band(ctx, v2.0, v152, v153);
                                                                let v155 = C::subsume(ctx, v154);
                                                                // Rule at src/opts/arithmetic.isle line 228.
                                                                returns.extend(Some(v155));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bxor => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                if v7.1 == v124.0 {
                                                    let mut v199 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                    let mut v199 = v199.into_context_iter();
                                                    while let Some(v200) = v199.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v203,
                                                            arg: v204,
                                                        } = &v200.1 {
                                                            if let &Opcode::Bnot = v203 {
                                                                if v2.0 == v200.0 {
                                                                    let v552 = constructor_band(ctx, v2.0, v124.0, v204);
                                                                    // Rule at src/opts/bitops.isle line 206.
                                                                    returns.extend(Some(v552));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if v7.1 == v124.1 {
                                                    let mut v127 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                    let mut v127 = v127.into_context_iter();
                                                    while let Some(v128) = v127.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v196,
                                                            arg: v197,
                                                        } = &v128.1 {
                                                            if let &Opcode::Bnot = v196 {
                                                                if v2.0 == v128.0 {
                                                                    let v553 = constructor_band(ctx, v2.0, v124.1, v197);
                                                                    // Rule at src/opts/bitops.isle line 207.
                                                                    returns.extend(Some(v553));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    if let &Opcode::Bnot = v29 {
                                        if v7.1 == v30 {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v19.0 == v53 {
                                                    let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                                    let v56 = C::subsume(ctx, v55);
                                                    // Rule at src/opts/bitops.isle line 35.
                                                    returns.extend(Some(v56));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v642 = constructor_band(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 130.
                                            returns.extend(Some(v642));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 11.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 28.
                            returns.extend(Some(v17));
                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                        }
                        let mut v58 = C::inst_data_value_tupled_etor_returns::default();
                        C::inst_data_value_tupled_etor(ctx, v7.1, &mut v58);
                        let mut v58 = v58.into_context_iter();
                        while let Some(v59) = v58.next(ctx) {
                            let v60 = C::iconst_sextend_etor(ctx, v59);
                            if let Some(v61) = v60 {
                                if v61.1 == -1_i64 {
                                    if v2.0 == v61.0 {
                                        let v17 = C::subsume(ctx, v7.0);
                                        // Rule at src/opts/bitops.isle line 29.
                                        returns.extend(Some(v17));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    match v104 {
                                        &Opcode::Band => {
                                            let mut v18 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                            let mut v18 = v18.into_context_iter();
                                            while let Some(v19) = v18.next(ctx) {
                                                match &v19.1 {
                                                    &InstructionData::Binary {
                                                        opcode: ref v122,
                                                        args: ref v123,
                                                    } => {
                                                        if let &Opcode::Band = v122 {
                                                            let v722 = C::ty_vec128(ctx, v2.0);
                                                            if let Some(v723) = v722 {
                                                                if v11.0 == v19.0 {
                                                                    if v11.0 == v723 {
                                                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                                                        let mut v109 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                        let mut v109 = v109.into_context_iter();
                                                                        while let Some(v110) = v109.next(ctx) {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v554,
                                                                                arg: v555,
                                                                            } = &v110.1 {
                                                                                if let &Opcode::Bnot = v554 {
                                                                                    if v11.0 == v110.0 {
                                                                                        let v124 = C::unpack_value_array_2(ctx, v123);
                                                                                        if v124.0 == v555 {
                                                                                            let v1239 = constructor_bitselect(ctx, v723, v124.0, v124.1, v106.0);
                                                                                            // Rule at src/opts/selects.isle line 70.
                                                                                            returns.extend(Some(v1239));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                        if v124.1 == v555 {
                                                                                            let v1241 = constructor_bitselect(ctx, v723, v124.1, v124.0, v106.0);
                                                                                            // Rule at src/opts/selects.isle line 72.
                                                                                            returns.extend(Some(v1241));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        let v124 = C::unpack_value_array_2(ctx, v123);
                                                                        let mut v127 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                        let mut v127 = v127.into_context_iter();
                                                                        while let Some(v128) = v127.next(ctx) {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v196,
                                                                                arg: v197,
                                                                            } = &v128.1 {
                                                                                if let &Opcode::Bnot = v196 {
                                                                                    if v11.0 == v128.0 {
                                                                                        if v106.1 == v197 {
                                                                                            let v1243 = constructor_bitselect(ctx, v723, v197, v106.0, v124.1);
                                                                                            // Rule at src/opts/selects.isle line 74.
                                                                                            returns.extend(Some(v1243));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                        if v106.0 == v197 {
                                                                                            let v1242 = constructor_bitselect(ctx, v723, v197, v106.1, v124.1);
                                                                                            // Rule at src/opts/selects.isle line 73.
                                                                                            returns.extend(Some(v1242));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        let mut v199 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                        let mut v199 = v199.into_context_iter();
                                                                        while let Some(v200) = v199.next(ctx) {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v203,
                                                                                arg: v204,
                                                                            } = &v200.1 {
                                                                                if let &Opcode::Bnot = v203 {
                                                                                    if v11.0 == v200.0 {
                                                                                        if v106.1 == v204 {
                                                                                            let v1245 = constructor_bitselect(ctx, v723, v204, v106.0, v124.0);
                                                                                            // Rule at src/opts/selects.isle line 76.
                                                                                            returns.extend(Some(v1245));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                        if v106.0 == v204 {
                                                                                            let v1244 = constructor_bitselect(ctx, v723, v204, v106.1, v124.0);
                                                                                            // Rule at src/opts/selects.isle line 75.
                                                                                            returns.extend(Some(v1244));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        let mut v331 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v106.0, &mut v331);
                                                                        let mut v331 = v331.into_context_iter();
                                                                        while let Some(v332) = v331.next(ctx) {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v557,
                                                                                arg: v558,
                                                                            } = &v332.1 {
                                                                                if let &Opcode::Bnot = v557 {
                                                                                    if v11.0 == v332.0 {
                                                                                        if v124.0 == v558 {
                                                                                            let v1238 = constructor_bitselect(ctx, v723, v124.0, v124.1, v106.1);
                                                                                            // Rule at src/opts/selects.isle line 69.
                                                                                            returns.extend(Some(v1238));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                        if v124.1 == v558 {
                                                                                            let v1240 = constructor_bitselect(ctx, v723, v124.1, v124.0, v106.1);
                                                                                            // Rule at src/opts/selects.isle line 71.
                                                                                            returns.extend(Some(v1240));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    &InstructionData::Unary {
                                                        opcode: ref v29,
                                                        arg: v30,
                                                    } => {
                                                        if let &Opcode::Bnot = v29 {
                                                            if v2.0 == v11.0 {
                                                                if v2.0 == v19.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    if v30 == v106.0 {
                                                                        let v563 = constructor_bnot(ctx, v2.0, v30);
                                                                        let v564 = constructor_bor(ctx, v2.0, v106.1, v563);
                                                                        // Rule at src/opts/bitops.isle line 229.
                                                                        returns.extend(Some(v564));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                    if v30 == v106.1 {
                                                                        let v247 = constructor_bor(ctx, v2.0, v106.0, v7.0);
                                                                        // Rule at src/opts/bitops.isle line 61.
                                                                        returns.extend(Some(v247));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                            }
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                if v7.0 == v106.0 {
                                                    // Rule at src/opts/bitops.isle line 221.
                                                    returns.extend(Some(v7.0));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v11.0 {
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                if v7.0 == v106.0 {
                                                    let v549 = constructor_bor(ctx, v2.0, v7.0, v106.1);
                                                    // Rule at src/opts/bitops.isle line 197.
                                                    returns.extend(Some(v549));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                if v7.0 == v106.1 {
                                                    let v247 = constructor_bor(ctx, v2.0, v106.0, v7.0);
                                                    // Rule at src/opts/bitops.isle line 198.
                                                    returns.extend(Some(v247));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v122,
                                                        args: ref v123,
                                                    } = &v19.1 {
                                                        if let &Opcode::Bor = v122 {
                                                            if v2.0 == v19.0 {
                                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                let mut v109 = v109.into_context_iter();
                                                                while let Some(v110) = v109.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v756,
                                                                        imm: v757,
                                                                    } = &v110.1 {
                                                                        if let &Opcode::Iconst = v756 {
                                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                                            let mut v199 = C::inst_data_value_etor_returns::default();
                                                                            C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                            let mut v199 = v199.into_context_iter();
                                                                            while let Some(v200) = v199.next(ctx) {
                                                                                if let &InstructionData::UnaryImm {
                                                                                    opcode: ref v248,
                                                                                    imm: v249,
                                                                                } = &v200.1 {
                                                                                    if let &Opcode::Iconst = v248 {
                                                                                        let v767 = constructor_bor(ctx, v2.0, v124.0, v106.0);
                                                                                        let v768 = constructor_bor(ctx, v2.0, v124.1, v106.1);
                                                                                        let v769 = constructor_bor(ctx, v2.0, v767, v768);
                                                                                        // Rule at src/opts/cprop.isle line 276.
                                                                                        returns.extend(Some(v769));
                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            match v2.0 {
                                                I32 => {
                                                    if v11.0 == I32 {
                                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                        let mut v18 = v18.into_context_iter();
                                                        while let Some(v19) = v18.next(ctx) {
                                                            if v19.0 == I32 {
                                                                if let &InstructionData::Binary {
                                                                    opcode: ref v122,
                                                                    args: ref v123,
                                                                } = &v19.1 {
                                                                    if let &Opcode::Bor = v122 {
                                                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                                                        let mut v109 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                        let mut v109 = v109.into_context_iter();
                                                                        while let Some(v110) = v109.next(ctx) {
                                                                            if v110.0 == I32 {
                                                                                if let &InstructionData::Binary {
                                                                                    opcode: ref v113,
                                                                                    args: ref v114,
                                                                                } = &v110.1 {
                                                                                    if let &Opcode::Ushr = v113 {
                                                                                        let v124 = C::unpack_value_array_2(ctx, v123);
                                                                                        let mut v127 = C::inst_data_value_etor_returns::default();
                                                                                        C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                                        let mut v127 = v127.into_context_iter();
                                                                                        while let Some(v128) = v127.next(ctx) {
                                                                                            if v128.0 == I32 {
                                                                                                if let &InstructionData::Binary {
                                                                                                    opcode: ref v131,
                                                                                                    args: ref v132,
                                                                                                } = &v128.1 {
                                                                                                    if let &Opcode::Ishl = v131 {
                                                                                                        let v115 = C::unpack_value_array_2(ctx, v114);
                                                                                                        let v133 = C::unpack_value_array_2(ctx, v132);
                                                                                                        if v115.0 == v133.0 {
                                                                                                            let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                                            C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                                            let mut v199 = v199.into_context_iter();
                                                                                                            while let Some(v200) = v199.next(ctx) {
                                                                                                                if v200.0 == I32 {
                                                                                                                    if let &InstructionData::Binary {
                                                                                                                        opcode: ref v303,
                                                                                                                        args: ref v304,
                                                                                                                    } = &v200.1 {
                                                                                                                        if let &Opcode::Ishl = v303 {
                                                                                                                            let mut v296 = C::inst_data_value_etor_returns::default();
                                                                                                                            C::inst_data_value_etor(ctx, v133.1, &mut v296);
                                                                                                                            let mut v296 = v296.into_context_iter();
                                                                                                                            while let Some(v297) = v296.next(ctx) {
                                                                                                                                if v297.0 == I32 {
                                                                                                                                    if let &InstructionData::UnaryImm {
                                                                                                                                        opcode: ref v300,
                                                                                                                                        imm: v301,
                                                                                                                                    } = &v297.1 {
                                                                                                                                        if let &Opcode::Iconst = v300 {
                                                                                                                                            let v302 = C::u64_from_imm64(ctx, v301);
                                                                                                                                            if v302 == 0x18_u64 {
                                                                                                                                                let v305 = C::unpack_value_array_2(ctx, v304);
                                                                                                                                                let mut v308 = C::inst_data_value_etor_returns::default();
                                                                                                                                                C::inst_data_value_etor(ctx, v305.0, &mut v308);
                                                                                                                                                let mut v308 = v308.into_context_iter();
                                                                                                                                                while let Some(v309) = v308.next(ctx) {
                                                                                                                                                    if v309.0 == I32 {
                                                                                                                                                        if let &InstructionData::Binary {
                                                                                                                                                            opcode: ref v312,
                                                                                                                                                            args: ref v313,
                                                                                                                                                        } = &v309.1 {
                                                                                                                                                            if let &Opcode::Band = v312 {
                                                                                                                                                                let v314 = C::unpack_value_array_2(ctx, v313);
                                                                                                                                                                if v115.0 == v314.0 {
                                                                                                                                                                    let mut v317 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                    C::inst_data_value_etor(ctx, v314.1, &mut v317);
                                                                                                                                                                    let mut v317 = v317.into_context_iter();
                                                                                                                                                                    while let Some(v318) = v317.next(ctx) {
                                                                                                                                                                        if v318.0 == I32 {
                                                                                                                                                                            if let &InstructionData::UnaryImm {
                                                                                                                                                                                opcode: ref v321,
                                                                                                                                                                                imm: v322,
                                                                                                                                                                            } = &v318.1 {
                                                                                                                                                                                if let &Opcode::Iconst = v321 {
                                                                                                                                                                                    let v323 = C::u64_from_imm64(ctx, v322);
                                                                                                                                                                                    if v323 == 0xff00_u64 {
                                                                                                                                                                                        let mut v324 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                        C::inst_data_value_etor(ctx, v305.1, &mut v324);
                                                                                                                                                                                        let mut v324 = v324.into_context_iter();
                                                                                                                                                                                        while let Some(v325) = v324.next(ctx) {
                                                                                                                                                                                            if v325.0 == I32 {
                                                                                                                                                                                                if let &InstructionData::UnaryImm {
                                                                                                                                                                                                    opcode: ref v328,
                                                                                                                                                                                                    imm: v329,
                                                                                                                                                                                                } = &v325.1 {
                                                                                                                                                                                                    if let &Opcode::Iconst = v328 {
                                                                                                                                                                                                        let v330 = C::u64_from_imm64(ctx, v329);
                                                                                                                                                                                                        if v330 == 0x8_u64 {
                                                                                                                                                                                                            let mut v331 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v106.0, &mut v331);
                                                                                                                                                                                                            let mut v331 = v331.into_context_iter();
                                                                                                                                                                                                            while let Some(v332) = v331.next(ctx) {
                                                                                                                                                                                                                if v332.0 == I32 {
                                                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                                                        opcode: ref v335,
                                                                                                                                                                                                                        args: ref v336,
                                                                                                                                                                                                                    } = &v332.1 {
                                                                                                                                                                                                                        if let &Opcode::Band = v335 {
                                                                                                                                                                                                                            let v337 = C::unpack_value_array_2(ctx, v336);
                                                                                                                                                                                                                            let mut v340 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v337.0, &mut v340);
                                                                                                                                                                                                                            let mut v340 = v340.into_context_iter();
                                                                                                                                                                                                                            while let Some(v341) = v340.next(ctx) {
                                                                                                                                                                                                                                if v341.0 == I32 {
                                                                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                                                                        opcode: ref v344,
                                                                                                                                                                                                                                        args: ref v345,
                                                                                                                                                                                                                                    } = &v341.1 {
                                                                                                                                                                                                                                        if let &Opcode::Ushr = v344 {
                                                                                                                                                                                                                                            let v346 = C::unpack_value_array_2(ctx, v345);
                                                                                                                                                                                                                                            if v115.0 == v346.0 {
                                                                                                                                                                                                                                                let mut v349 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v346.1, &mut v349);
                                                                                                                                                                                                                                                let mut v349 = v349.into_context_iter();
                                                                                                                                                                                                                                                while let Some(v350) = v349.next(ctx) {
                                                                                                                                                                                                                                                    if v350.0 == I32 {
                                                                                                                                                                                                                                                        if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                            opcode: ref v353,
                                                                                                                                                                                                                                                            imm: v354,
                                                                                                                                                                                                                                                        } = &v350.1 {
                                                                                                                                                                                                                                                            if let &Opcode::Iconst = v353 {
                                                                                                                                                                                                                                                                let v355 = C::u64_from_imm64(ctx, v354);
                                                                                                                                                                                                                                                                if v355 == 0x8_u64 {
                                                                                                                                                                                                                                                                    let mut v356 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                    C::inst_data_value_etor(ctx, v337.1, &mut v356);
                                                                                                                                                                                                                                                                    let mut v356 = v356.into_context_iter();
                                                                                                                                                                                                                                                                    while let Some(v357) = v356.next(ctx) {
                                                                                                                                                                                                                                                                        if v357.0 == I32 {
                                                                                                                                                                                                                                                                            if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                opcode: ref v360,
                                                                                                                                                                                                                                                                                imm: v361,
                                                                                                                                                                                                                                                                            } = &v357.1 {
                                                                                                                                                                                                                                                                                if let &Opcode::Iconst = v360 {
                                                                                                                                                                                                                                                                                    let v362 = C::u64_from_imm64(ctx, v361);
                                                                                                                                                                                                                                                                                    if v362 == 0xff00_u64 {
                                                                                                                                                                                                                                                                                        let mut v363 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                        C::inst_data_value_etor(ctx, v115.1, &mut v363);
                                                                                                                                                                                                                                                                                        let mut v363 = v363.into_context_iter();
                                                                                                                                                                                                                                                                                        while let Some(v364) = v363.next(ctx) {
                                                                                                                                                                                                                                                                                            if v364.0 == I32 {
                                                                                                                                                                                                                                                                                                if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                    opcode: ref v367,
                                                                                                                                                                                                                                                                                                    imm: v368,
                                                                                                                                                                                                                                                                                                } = &v364.1 {
                                                                                                                                                                                                                                                                                                    if let &Opcode::Iconst = v367 {
                                                                                                                                                                                                                                                                                                        let v369 = C::u64_from_imm64(ctx, v368);
                                                                                                                                                                                                                                                                                                        if v369 == 0x18_u64 {
                                                                                                                                                                                                                                                                                                            let v370 = constructor_bswap(ctx, v2.0, v133.0);
                                                                                                                                                                                                                                                                                                            // Rule at src/opts/bitops.isle line 150.
                                                                                                                                                                                                                                                                                                            returns.extend(Some(v370));
                                                                                                                                                                                                                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                I64 => {
                                                    if v11.0 == I64 {
                                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                        let mut v18 = v18.into_context_iter();
                                                        while let Some(v19) = v18.next(ctx) {
                                                            if v19.0 == I64 {
                                                                if let &InstructionData::Binary {
                                                                    opcode: ref v122,
                                                                    args: ref v123,
                                                                } = &v19.1 {
                                                                    if let &Opcode::Bor = v122 {
                                                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                                                        let mut v109 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                        let mut v109 = v109.into_context_iter();
                                                                        while let Some(v110) = v109.next(ctx) {
                                                                            if v110.0 == I64 {
                                                                                if let &InstructionData::Binary {
                                                                                    opcode: ref v113,
                                                                                    args: ref v114,
                                                                                } = &v110.1 {
                                                                                    if let &Opcode::Bor = v113 {
                                                                                        let v124 = C::unpack_value_array_2(ctx, v123);
                                                                                        let mut v127 = C::inst_data_value_etor_returns::default();
                                                                                        C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                                        let mut v127 = v127.into_context_iter();
                                                                                        while let Some(v128) = v127.next(ctx) {
                                                                                            if v128.0 == I64 {
                                                                                                if let &InstructionData::Binary {
                                                                                                    opcode: ref v131,
                                                                                                    args: ref v132,
                                                                                                } = &v128.1 {
                                                                                                    if let &Opcode::Bor = v131 {
                                                                                                        let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                                        C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                                        let mut v199 = v199.into_context_iter();
                                                                                                        while let Some(v200) = v199.next(ctx) {
                                                                                                            if v200.0 == I64 {
                                                                                                                if let &InstructionData::Binary {
                                                                                                                    opcode: ref v303,
                                                                                                                    args: ref v304,
                                                                                                                } = &v200.1 {
                                                                                                                    if let &Opcode::Bor = v303 {
                                                                                                                        let v133 = C::unpack_value_array_2(ctx, v132);
                                                                                                                        let mut v296 = C::inst_data_value_etor_returns::default();
                                                                                                                        C::inst_data_value_etor(ctx, v133.1, &mut v296);
                                                                                                                        let mut v296 = v296.into_context_iter();
                                                                                                                        while let Some(v297) = v296.next(ctx) {
                                                                                                                            if v297.0 == I64 {
                                                                                                                                if let &InstructionData::Binary {
                                                                                                                                    opcode: ref v387,
                                                                                                                                    args: ref v388,
                                                                                                                                } = &v297.1 {
                                                                                                                                    if let &Opcode::Ishl = v387 {
                                                                                                                                        let v305 = C::unpack_value_array_2(ctx, v304);
                                                                                                                                        let mut v308 = C::inst_data_value_etor_returns::default();
                                                                                                                                        C::inst_data_value_etor(ctx, v305.0, &mut v308);
                                                                                                                                        let mut v308 = v308.into_context_iter();
                                                                                                                                        while let Some(v309) = v308.next(ctx) {
                                                                                                                                            if v309.0 == I64 {
                                                                                                                                                if let &InstructionData::Binary {
                                                                                                                                                    opcode: ref v312,
                                                                                                                                                    args: ref v313,
                                                                                                                                                } = &v309.1 {
                                                                                                                                                    if let &Opcode::Ishl = v312 {
                                                                                                                                                        let v314 = C::unpack_value_array_2(ctx, v313);
                                                                                                                                                        let mut v317 = C::inst_data_value_etor_returns::default();
                                                                                                                                                        C::inst_data_value_etor(ctx, v314.1, &mut v317);
                                                                                                                                                        let mut v317 = v317.into_context_iter();
                                                                                                                                                        while let Some(v318) = v317.next(ctx) {
                                                                                                                                                            if v318.0 == I64 {
                                                                                                                                                                if let &InstructionData::UnaryImm {
                                                                                                                                                                    opcode: ref v321,
                                                                                                                                                                    imm: v322,
                                                                                                                                                                } = &v318.1 {
                                                                                                                                                                    if let &Opcode::Iconst = v321 {
                                                                                                                                                                        let v323 = C::u64_from_imm64(ctx, v322);
                                                                                                                                                                        if v323 == 0x18_u64 {
                                                                                                                                                                            let mut v324 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                            C::inst_data_value_etor(ctx, v305.1, &mut v324);
                                                                                                                                                                            let mut v324 = v324.into_context_iter();
                                                                                                                                                                            while let Some(v325) = v324.next(ctx) {
                                                                                                                                                                                if v325.0 == I64 {
                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                        opcode: ref v431,
                                                                                                                                                                                        args: ref v432,
                                                                                                                                                                                    } = &v325.1 {
                                                                                                                                                                                        if let &Opcode::Ishl = v431 {
                                                                                                                                                                                            let mut v331 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                            C::inst_data_value_etor(ctx, v106.0, &mut v331);
                                                                                                                                                                                            let mut v331 = v331.into_context_iter();
                                                                                                                                                                                            while let Some(v332) = v331.next(ctx) {
                                                                                                                                                                                                if v332.0 == I64 {
                                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                                        opcode: ref v335,
                                                                                                                                                                                                        args: ref v336,
                                                                                                                                                                                                    } = &v332.1 {
                                                                                                                                                                                                        if let &Opcode::Bor = v335 {
                                                                                                                                                                                                            let v337 = C::unpack_value_array_2(ctx, v336);
                                                                                                                                                                                                            let mut v340 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v337.0, &mut v340);
                                                                                                                                                                                                            let mut v340 = v340.into_context_iter();
                                                                                                                                                                                                            while let Some(v341) = v340.next(ctx) {
                                                                                                                                                                                                                if v341.0 == I64 {
                                                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                                                        opcode: ref v344,
                                                                                                                                                                                                                        args: ref v345,
                                                                                                                                                                                                                    } = &v341.1 {
                                                                                                                                                                                                                        if let &Opcode::Band = v344 {
                                                                                                                                                                                                                            let v346 = C::unpack_value_array_2(ctx, v345);
                                                                                                                                                                                                                            let mut v349 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v346.1, &mut v349);
                                                                                                                                                                                                                            let mut v349 = v349.into_context_iter();
                                                                                                                                                                                                                            while let Some(v350) = v349.next(ctx) {
                                                                                                                                                                                                                                if v350.0 == I64 {
                                                                                                                                                                                                                                    if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                        opcode: ref v353,
                                                                                                                                                                                                                                        imm: v354,
                                                                                                                                                                                                                                    } = &v350.1 {
                                                                                                                                                                                                                                        if let &Opcode::Iconst = v353 {
                                                                                                                                                                                                                                            let v355 = C::u64_from_imm64(ctx, v354);
                                                                                                                                                                                                                                            if v355 == 0xff000000_u64 {
                                                                                                                                                                                                                                                let mut v356 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v337.1, &mut v356);
                                                                                                                                                                                                                                                let mut v356 = v356.into_context_iter();
                                                                                                                                                                                                                                                while let Some(v357) = v356.next(ctx) {
                                                                                                                                                                                                                                                    if v357.0 == I64 {
                                                                                                                                                                                                                                                        if let &InstructionData::Binary {
                                                                                                                                                                                                                                                            opcode: ref v475,
                                                                                                                                                                                                                                                            args: ref v476,
                                                                                                                                                                                                                                                        } = &v357.1 {
                                                                                                                                                                                                                                                            if let &Opcode::Band = v475 {
                                                                                                                                                                                                                                                                let v115 = C::unpack_value_array_2(ctx, v114);
                                                                                                                                                                                                                                                                let mut v363 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v115.1, &mut v363);
                                                                                                                                                                                                                                                                let mut v363 = v363.into_context_iter();
                                                                                                                                                                                                                                                                while let Some(v364) = v363.next(ctx) {
                                                                                                                                                                                                                                                                    if v364.0 == I64 {
                                                                                                                                                                                                                                                                        if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                            opcode: ref v535,
                                                                                                                                                                                                                                                                            args: ref v536,
                                                                                                                                                                                                                                                                        } = &v364.1 {
                                                                                                                                                                                                                                                                            if let &Opcode::Ushr = v535 {
                                                                                                                                                                                                                                                                                let mut v371 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v133.0, &mut v371);
                                                                                                                                                                                                                                                                                let mut v371 = v371.into_context_iter();
                                                                                                                                                                                                                                                                                while let Some(v372) = v371.next(ctx) {
                                                                                                                                                                                                                                                                                    if v372.0 == I64 {
                                                                                                                                                                                                                                                                                        if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                            opcode: ref v375,
                                                                                                                                                                                                                                                                                            args: ref v376,
                                                                                                                                                                                                                                                                                        } = &v372.1 {
                                                                                                                                                                                                                                                                                            if let &Opcode::Ishl = v375 {
                                                                                                                                                                                                                                                                                                let v377 = C::unpack_value_array_2(ctx, v376);
                                                                                                                                                                                                                                                                                                let v537 = C::unpack_value_array_2(ctx, v536);
                                                                                                                                                                                                                                                                                                if v377.0 == v537.0 {
                                                                                                                                                                                                                                                                                                    let mut v380 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                    C::inst_data_value_etor(ctx, v377.1, &mut v380);
                                                                                                                                                                                                                                                                                                    let mut v380 = v380.into_context_iter();
                                                                                                                                                                                                                                                                                                    while let Some(v381) = v380.next(ctx) {
                                                                                                                                                                                                                                                                                                        if v381.0 == I64 {
                                                                                                                                                                                                                                                                                                            if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                opcode: ref v384,
                                                                                                                                                                                                                                                                                                                imm: v385,
                                                                                                                                                                                                                                                                                                            } = &v381.1 {
                                                                                                                                                                                                                                                                                                                if let &Opcode::Iconst = v384 {
                                                                                                                                                                                                                                                                                                                    let v386 = C::u64_from_imm64(ctx, v385);
                                                                                                                                                                                                                                                                                                                    if v386 == 0x38_u64 {
                                                                                                                                                                                                                                                                                                                        let v389 = C::unpack_value_array_2(ctx, v388);
                                                                                                                                                                                                                                                                                                                        let mut v392 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                        C::inst_data_value_etor(ctx, v389.0, &mut v392);
                                                                                                                                                                                                                                                                                                                        let mut v392 = v392.into_context_iter();
                                                                                                                                                                                                                                                                                                                        while let Some(v393) = v392.next(ctx) {
                                                                                                                                                                                                                                                                                                                            if v393.0 == I64 {
                                                                                                                                                                                                                                                                                                                                if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                                                                    opcode: ref v396,
                                                                                                                                                                                                                                                                                                                                    args: ref v397,
                                                                                                                                                                                                                                                                                                                                } = &v393.1 {
                                                                                                                                                                                                                                                                                                                                    if let &Opcode::Band = v396 {
                                                                                                                                                                                                                                                                                                                                        let v398 = C::unpack_value_array_2(ctx, v397);
                                                                                                                                                                                                                                                                                                                                        if v377.0 == v398.0 {
                                                                                                                                                                                                                                                                                                                                            let mut v401 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v398.1, &mut v401);
                                                                                                                                                                                                                                                                                                                                            let mut v401 = v401.into_context_iter();
                                                                                                                                                                                                                                                                                                                                            while let Some(v402) = v401.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                if v402.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                    if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                        opcode: ref v405,
                                                                                                                                                                                                                                                                                                                                                        imm: v406,
                                                                                                                                                                                                                                                                                                                                                    } = &v402.1 {
                                                                                                                                                                                                                                                                                                                                                        if let &Opcode::Iconst = v405 {
                                                                                                                                                                                                                                                                                                                                                            let v407 = C::u64_from_imm64(ctx, v406);
                                                                                                                                                                                                                                                                                                                                                            if v407 == 0xff00_u64 {
                                                                                                                                                                                                                                                                                                                                                                let mut v408 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v389.1, &mut v408);
                                                                                                                                                                                                                                                                                                                                                                let mut v408 = v408.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                while let Some(v409) = v408.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                    if v409.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                        if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                            opcode: ref v412,
                                                                                                                                                                                                                                                                                                                                                                            imm: v413,
                                                                                                                                                                                                                                                                                                                                                                        } = &v409.1 {
                                                                                                                                                                                                                                                                                                                                                                            if let &Opcode::Iconst = v412 {
                                                                                                                                                                                                                                                                                                                                                                                let v414 = C::u64_from_imm64(ctx, v413);
                                                                                                                                                                                                                                                                                                                                                                                if v414 == 0x28_u64 {
                                                                                                                                                                                                                                                                                                                                                                                    let mut v415 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                    C::inst_data_value_etor(ctx, v314.0, &mut v415);
                                                                                                                                                                                                                                                                                                                                                                                    let mut v415 = v415.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                    while let Some(v416) = v415.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                        if v416.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                            if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                                                                                                                                opcode: ref v419,
                                                                                                                                                                                                                                                                                                                                                                                                args: ref v420,
                                                                                                                                                                                                                                                                                                                                                                                            } = &v416.1 {
                                                                                                                                                                                                                                                                                                                                                                                                if let &Opcode::Band = v419 {
                                                                                                                                                                                                                                                                                                                                                                                                    let v421 = C::unpack_value_array_2(ctx, v420);
                                                                                                                                                                                                                                                                                                                                                                                                    if v377.0 == v421.0 {
                                                                                                                                                                                                                                                                                                                                                                                                        let mut v424 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                        C::inst_data_value_etor(ctx, v421.1, &mut v424);
                                                                                                                                                                                                                                                                                                                                                                                                        let mut v424 = v424.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                        while let Some(v425) = v424.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                            if v425.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                    opcode: ref v428,
                                                                                                                                                                                                                                                                                                                                                                                                                    imm: v429,
                                                                                                                                                                                                                                                                                                                                                                                                                } = &v425.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                    if let &Opcode::Iconst = v428 {
                                                                                                                                                                                                                                                                                                                                                                                                                        let v430 = C::u64_from_imm64(ctx, v429);
                                                                                                                                                                                                                                                                                                                                                                                                                        if v430 == 0xff0000_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                            let v433 = C::unpack_value_array_2(ctx, v432);
                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v436 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v433.0, &mut v436);
                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v436 = v436.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                            while let Some(v437) = v436.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                if v437.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                                                                                                                                                                        opcode: ref v440,
                                                                                                                                                                                                                                                                                                                                                                                                                                        args: ref v441,
                                                                                                                                                                                                                                                                                                                                                                                                                                    } = &v437.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                        if let &Opcode::Band = v440 {
                                                                                                                                                                                                                                                                                                                                                                                                                                            let v442 = C::unpack_value_array_2(ctx, v441);
                                                                                                                                                                                                                                                                                                                                                                                                                                            if v377.0 == v442.0 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                let mut v445 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v442.1, &mut v445);
                                                                                                                                                                                                                                                                                                                                                                                                                                                let mut v445 = v445.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                while let Some(v446) = v445.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                    if v446.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                        if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                            opcode: ref v449,
                                                                                                                                                                                                                                                                                                                                                                                                                                                            imm: v450,
                                                                                                                                                                                                                                                                                                                                                                                                                                                        } = &v446.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                            if let &Opcode::Iconst = v449 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                let v451 = C::u64_from_imm64(ctx, v450);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                if v451 == 0xff000000_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let mut v452 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    C::inst_data_value_etor(ctx, v433.1, &mut v452);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let mut v452 = v452.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    while let Some(v453) = v452.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if v453.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                opcode: ref v456,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                imm: v457,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            } = &v453.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if let &Opcode::Iconst = v456 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let v458 = C::u64_from_imm64(ctx, v457);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if v458 == 0x8_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let mut v459 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        C::inst_data_value_etor(ctx, v346.0, &mut v459);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let mut v459 = v459.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        while let Some(v460) = v459.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if v460.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    opcode: ref v463,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    args: ref v464,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                } = &v460.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if let &Opcode::Ushr = v463 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let v465 = C::unpack_value_array_2(ctx, v464);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if v377.0 == v465.0 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v468 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v465.1, &mut v468);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v468 = v468.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            while let Some(v469) = v468.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if v469.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        opcode: ref v472,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        imm: v473,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    } = &v469.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if let &Opcode::Iconst = v472 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let v474 = C::u64_from_imm64(ctx, v473);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if v474 == 0x8_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                let v477 = C::unpack_value_array_2(ctx, v476);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                let mut v480 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v477.0, &mut v480);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                let mut v480 = v480.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                while let Some(v481) = v480.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if v481.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            opcode: ref v484,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            args: ref v485,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        } = &v481.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if let &Opcode::Ushr = v484 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                let v486 = C::unpack_value_array_2(ctx, v485);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if v377.0 == v486.0 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let mut v489 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    C::inst_data_value_etor(ctx, v486.1, &mut v489);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let mut v489 = v489.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    while let Some(v490) = v489.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if v490.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                opcode: ref v493,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                imm: v494,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            } = &v490.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if let &Opcode::Iconst = v493 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let v495 = C::u64_from_imm64(ctx, v494);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if v495 == 0x18_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let mut v496 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        C::inst_data_value_etor(ctx, v477.1, &mut v496);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let mut v496 = v496.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        while let Some(v497) = v496.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if v497.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    opcode: ref v500,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    imm: v501,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                } = &v497.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if let &Opcode::Iconst = v500 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let v502 = C::u64_from_imm64(ctx, v501);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if v502 == 0xff0000_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v503 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v115.0, &mut v503);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v503 = v503.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            while let Some(v504) = v503.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if v504.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        opcode: ref v507,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        args: ref v508,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    } = &v504.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if let &Opcode::Band = v507 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let v509 = C::unpack_value_array_2(ctx, v508);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v512 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            C::inst_data_value_etor(ctx, v509.0, &mut v512);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let mut v512 = v512.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            while let Some(v513) = v512.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if v513.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if let &InstructionData::Binary {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        opcode: ref v516,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        args: ref v517,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    } = &v513.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if let &Opcode::Ushr = v516 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let v518 = C::unpack_value_array_2(ctx, v517);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if v377.0 == v518.0 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                let mut v521 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                C::inst_data_value_etor(ctx, v518.1, &mut v521);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                let mut v521 = v521.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                while let Some(v522) = v521.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if v522.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            opcode: ref v525,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            imm: v526,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        } = &v522.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if let &Opcode::Iconst = v525 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                let v527 = C::u64_from_imm64(ctx, v526);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if v527 == 0x28_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let mut v528 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    C::inst_data_value_etor(ctx, v509.1, &mut v528);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let mut v528 = v528.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    while let Some(v529) = v528.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if v529.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                opcode: ref v532,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                imm: v533,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            } = &v529.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if let &Opcode::Iconst = v532 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let v534 = C::u64_from_imm64(ctx, v533);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if v534 == 0xff00_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let mut v540 = C::inst_data_value_etor_returns::default();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        C::inst_data_value_etor(ctx, v537.1, &mut v540);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let mut v540 = v540.into_context_iter();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        while let Some(v541) = v540.next(ctx) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if v541.0 == I64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if let &InstructionData::UnaryImm {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    opcode: ref v544,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    imm: v545,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                } = &v541.1 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if let &Opcode::Iconst = v544 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        let v546 = C::u64_from_imm64(ctx, v545);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if v546 == 0x38_u64 {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            let v547 = constructor_bswap(ctx, v2.0, v377.0);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            // Rule at src/opts/bitops.isle line 163.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            returns.extend(Some(v547));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        &Opcode::Ishl => {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v11.0 == v53 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if let &InstructionData::Binary {
                                                            opcode: ref v122,
                                                            args: ref v123,
                                                        } = &v19.1 {
                                                            if let &Opcode::Ushr = v122 {
                                                                if v11.0 == v19.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    if v106.0 == v124.0 {
                                                                        let mut v109 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                        let mut v109 = v109.into_context_iter();
                                                                        while let Some(v110) = v109.next(ctx) {
                                                                            if let &InstructionData::UnaryImm {
                                                                                opcode: ref v756,
                                                                                imm: v757,
                                                                            } = &v110.1 {
                                                                                if let &Opcode::Iconst = v756 {
                                                                                    let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                    C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                    let mut v199 = v199.into_context_iter();
                                                                                    while let Some(v200) = v199.next(ctx) {
                                                                                        if let &InstructionData::UnaryImm {
                                                                                            opcode: ref v248,
                                                                                            imm: v249,
                                                                                        } = &v200.1 {
                                                                                            if let &Opcode::Iconst = v248 {
                                                                                                let v250 = C::u64_from_imm64(ctx, v249);
                                                                                                let v1370 = C::lane_type(ctx, v53);
                                                                                                let v1371 = C::ty_bits_u64(ctx, v1370);
                                                                                                let v1026 = C::u64_from_imm64(ctx, v757);
                                                                                                let v1375 = C::u64_wrapping_sub(ctx, v1371, v1026);
                                                                                                let v1376 = C::u64_eq(ctx, v250, v1375);
                                                                                                if v1376 == true {
                                                                                                    let v1377 = constructor_rotl(ctx, v53, v124.0, v106.1);
                                                                                                    // Rule at src/opts/shifts.isle line 280.
                                                                                                    returns.extend(Some(v1377));
                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Ushr => {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v11.0 == v53 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if let &InstructionData::Binary {
                                                            opcode: ref v122,
                                                            args: ref v123,
                                                        } = &v19.1 {
                                                            if let &Opcode::Ishl = v122 {
                                                                if v11.0 == v19.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    if v106.0 == v124.0 {
                                                                        let mut v109 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                        let mut v109 = v109.into_context_iter();
                                                                        while let Some(v110) = v109.next(ctx) {
                                                                            if let &InstructionData::UnaryImm {
                                                                                opcode: ref v756,
                                                                                imm: v757,
                                                                            } = &v110.1 {
                                                                                if let &Opcode::Iconst = v756 {
                                                                                    let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                    C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                    let mut v199 = v199.into_context_iter();
                                                                                    while let Some(v200) = v199.next(ctx) {
                                                                                        if let &InstructionData::UnaryImm {
                                                                                            opcode: ref v248,
                                                                                            imm: v249,
                                                                                        } = &v200.1 {
                                                                                            if let &Opcode::Iconst = v248 {
                                                                                                let v1026 = C::u64_from_imm64(ctx, v757);
                                                                                                let v1370 = C::lane_type(ctx, v53);
                                                                                                let v1371 = C::ty_bits_u64(ctx, v1370);
                                                                                                let v250 = C::u64_from_imm64(ctx, v249);
                                                                                                let v1372 = C::u64_wrapping_sub(ctx, v1371, v250);
                                                                                                let v1373 = C::u64_eq(ctx, v1026, v1372);
                                                                                                if v1373 == true {
                                                                                                    let v1374 = constructor_rotl(ctx, v53, v124.0, v124.1);
                                                                                                    // Rule at src/opts/shifts.isle line 275.
                                                                                                    returns.extend(Some(v1374));
                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v1109,
                                    args: ref v1110,
                                    cond: ref v1111,
                                } => {
                                    if let &Opcode::Icmp = v1109 {
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            if v11.0 == v566 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::IntCompare {
                                                        opcode: ref v1079,
                                                        args: ref v1080,
                                                        cond: ref v1081,
                                                    } = &v19.1 {
                                                        if let &Opcode::Icmp = v1079 {
                                                            let v1115 = constructor_intcc_comparable(ctx, v1081, v1111);
                                                            if let Some(v1116) = v1115 {
                                                                if v11.0 == v19.0 {
                                                                    let v1082 = C::unpack_value_array_2(ctx, v1080);
                                                                    let v1112 = C::unpack_value_array_2(ctx, v1110);
                                                                    if v1082.0 == v1112.0 {
                                                                        if v1082.1 == v1112.1 {
                                                                            let v1117 = constructor_decompose_intcc(ctx, v1081);
                                                                            let v1118 = constructor_decompose_intcc(ctx, v1111);
                                                                            let v1121 = C::u64_or(ctx, v1117, v1118);
                                                                            let v1122 = constructor_compose_icmp(ctx, v566, v1121, v1116, v1082.0, v1082.1);
                                                                            // Rule at src/opts/icmp.isle line 179.
                                                                            returns.extend(Some(v1122));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Splat => {
                                            let v1471 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v1472) = v1471 {
                                                if v2.0 == v11.0 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v29,
                                                            arg: v30,
                                                        } = &v19.1 {
                                                            if let &Opcode::Splat = v29 {
                                                                if v2.0 == v19.0 {
                                                                    let v1353 = C::lane_type(ctx, v2.0);
                                                                    let v1475 = constructor_bor(ctx, v1353, v30, v27);
                                                                    let v1476 = constructor_splat(ctx, v2.0, v1475);
                                                                    // Rule at src/opts/vector.isle line 18.
                                                                    returns.extend(Some(v1476));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            if v2.0 == v11.0 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v122,
                                                        args: ref v123,
                                                    } = &v19.1 {
                                                        if let &Opcode::Band = v122 {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                if v27 == v124.0 {
                                                                    let v561 = constructor_bnot(ctx, v2.0, v124.0);
                                                                    let v562 = constructor_bor(ctx, v2.0, v124.1, v561);
                                                                    // Rule at src/opts/bitops.isle line 228.
                                                                    returns.extend(Some(v562));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                if v27 == v124.1 {
                                                                    let v246 = constructor_bor(ctx, v2.0, v124.0, v7.1);
                                                                    // Rule at src/opts/bitops.isle line 52.
                                                                    returns.extend(Some(v246));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v11.0 == v53 {
                                                    if v7.0 == v27 {
                                                        let v239 = constructor_iconst_s(ctx, v53, -1_i64);
                                                        let v240 = C::subsume(ctx, v239);
                                                        // Rule at src/opts/bitops.isle line 24.
                                                        returns.extend(Some(v240));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let mut v18 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                            let mut v18 = v18.into_context_iter();
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v29,
                                                    arg: v30,
                                                } = &v19.1 {
                                                    if let &Opcode::Uextend = v29 {
                                                        let v971 = C::value_type(ctx, v30);
                                                        let v1006 = C::value_type(ctx, v27);
                                                        if v971 == v1006 {
                                                            let v1009 = constructor_bor(ctx, v971, v30, v27);
                                                            let v1010 = constructor_uextend(ctx, v2.0, v1009);
                                                            // Rule at src/opts/extends.isle line 72.
                                                            returns.extend(Some(v1010));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let mut v18 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                            let mut v18 = v18.into_context_iter();
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v122,
                                                    args: ref v123,
                                                } = &v19.1 {
                                                    match v122 {
                                                        &Opcode::Band => {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            let v251 = C::ty_mask(ctx, v2.0);
                                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                                            let v252 = C::u64_and(ctx, v251, v16);
                                                                            let v250 = C::u64_from_imm64(ctx, v249);
                                                                            let v253 = C::u64_not(ctx, v250);
                                                                            let v254 = C::u64_and(ctx, v251, v253);
                                                                            let v255 = C::u64_eq(ctx, v252, v254);
                                                                            if v255 == true {
                                                                                if v2.0 == v200.0 {
                                                                                    let v246 = constructor_bor(ctx, v2.0, v124.0, v7.1);
                                                                                    // Rule at src/opts/bitops.isle line 72.
                                                                                    returns.extend(Some(v246));
                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Bor => {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            if v2.0 == v200.0 {
                                                                                let v670 = constructor_bor(ctx, v2.0, v124.1, v7.1);
                                                                                let v671 = constructor_bor(ctx, v2.0, v124.0, v670);
                                                                                // Rule at src/opts/cprop.isle line 180.
                                                                                returns.extend(Some(v671));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0_u64 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 3.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            if v11.0 == v566 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v22,
                                                        imm: v23,
                                                    } = &v19.1 {
                                                        if let &Opcode::Iconst = v22 {
                                                            if v11.0 == v19.0 {
                                                                let v24 = C::u64_from_imm64(ctx, v23);
                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                let v587 = C::u64_or(ctx, v24, v16);
                                                                let v588 = C::imm64_masked(ctx, v566, v587);
                                                                let v589 = constructor_iconst(ctx, v566, v588);
                                                                let v590 = C::subsume(ctx, v589);
                                                                // Rule at src/opts/cprop.isle line 55.
                                                                returns.extend(Some(v590));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 17.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    match v122 {
                                        &Opcode::Band => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                if v7.1 == v124.0 {
                                                    // Rule at src/opts/bitops.isle line 220.
                                                    returns.extend(Some(v124.0));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                if v7.1 == v124.0 {
                                                    let v241 = constructor_bor(ctx, v2.0, v124.0, v124.1);
                                                    // Rule at src/opts/bitops.isle line 195.
                                                    returns.extend(Some(v241));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                if v7.1 == v124.1 {
                                                    let v241 = constructor_bor(ctx, v2.0, v124.0, v124.1);
                                                    // Rule at src/opts/bitops.isle line 196.
                                                    returns.extend(Some(v241));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    if let &Opcode::Bnot = v29 {
                                        if v7.1 == v30 {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v19.0 == v53 {
                                                    let v239 = constructor_iconst_s(ctx, v53, -1_i64);
                                                    let v240 = C::subsume(ctx, v239);
                                                    // Rule at src/opts/bitops.isle line 25.
                                                    returns.extend(Some(v240));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v641 = constructor_bor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 127.
                                            returns.extend(Some(v641));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 15.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 7.
                            returns.extend(Some(v17));
                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                        }
                    }
                    &Opcode::Bxor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    match v104 {
                                        &Opcode::Band => {
                                            if v2.0 == v11.0 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v122,
                                                        args: ref v123,
                                                    } = &v19.1 {
                                                        if let &Opcode::Bor = v122 {
                                                            if v2.0 == v19.0 {
                                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                if v106.0 == v124.0 {
                                                                    if v106.1 == v124.1 {
                                                                        let v548 = constructor_bxor(ctx, v2.0, v124.0, v124.1);
                                                                        // Rule at src/opts/bitops.isle line 192.
                                                                        returns.extend(Some(v548));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bxor => {
                                            if v2.0 == v11.0 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v122,
                                                        args: ref v123,
                                                    } = &v19.1 {
                                                        match v122 {
                                                            &Opcode::Band => {
                                                                if v2.0 == v19.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    if v106.0 == v124.0 {
                                                                        if v106.1 == v124.1 {
                                                                            let v241 = constructor_bor(ctx, v2.0, v124.0, v124.1);
                                                                            // Rule at src/opts/bitops.isle line 38.
                                                                            returns.extend(Some(v241));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            &Opcode::Bxor => {
                                                                if v2.0 == v19.0 {
                                                                    let v106 = C::unpack_value_array_2(ctx, v105);
                                                                    let mut v109 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                                    let mut v109 = v109.into_context_iter();
                                                                    while let Some(v110) = v109.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v756,
                                                                            imm: v757,
                                                                        } = &v110.1 {
                                                                            if let &Opcode::Iconst = v756 {
                                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                let mut v199 = v199.into_context_iter();
                                                                                while let Some(v200) = v199.next(ctx) {
                                                                                    if let &InstructionData::UnaryImm {
                                                                                        opcode: ref v248,
                                                                                        imm: v249,
                                                                                    } = &v200.1 {
                                                                                        if let &Opcode::Iconst = v248 {
                                                                                            let v770 = constructor_bxor(ctx, v2.0, v124.0, v106.0);
                                                                                            let v771 = constructor_bxor(ctx, v2.0, v124.1, v106.1);
                                                                                            let v772 = constructor_bxor(ctx, v2.0, v770, v771);
                                                                                            // Rule at src/opts/cprop.isle line 280.
                                                                                            returns.extend(Some(v772));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                let v106 = C::unpack_value_array_2(ctx, v105);
                                                if v7.0 == v106.1 {
                                                    // Rule at src/opts/bitops.isle line 225.
                                                    returns.extend(Some(v106.0));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v113,
                                                        args: ref v114,
                                                    } = &v110.1 {
                                                        if let &Opcode::Bxor = v113 {
                                                            if v2.0 == v110.0 {
                                                                let v156 = constructor_bxor(ctx, v2.0, v7.0, v106.0);
                                                                let v115 = C::unpack_value_array_2(ctx, v114);
                                                                let v157 = constructor_bxor(ctx, v2.0, v115.0, v115.1);
                                                                let v158 = constructor_bxor(ctx, v2.0, v156, v157);
                                                                let v159 = C::subsume(ctx, v158);
                                                                // Rule at src/opts/arithmetic.isle line 231.
                                                                returns.extend(Some(v159));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Splat => {
                                            let v1471 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v1472) = v1471 {
                                                if v2.0 == v11.0 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v29,
                                                            arg: v30,
                                                        } = &v19.1 {
                                                            if let &Opcode::Splat = v29 {
                                                                if v2.0 == v19.0 {
                                                                    let v1353 = C::lane_type(ctx, v2.0);
                                                                    let v1477 = constructor_bxor(ctx, v1353, v30, v27);
                                                                    let v1478 = constructor_splat(ctx, v2.0, v1477);
                                                                    // Rule at src/opts/vector.isle line 22.
                                                                    returns.extend(Some(v1478));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v7.0 == v27 {
                                                    if v11.0 == v53 {
                                                        let v239 = constructor_iconst_s(ctx, v53, -1_i64);
                                                        let v240 = C::subsume(ctx, v239);
                                                        // Rule at src/opts/bitops.isle line 22.
                                                        returns.extend(Some(v240));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let mut v18 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                            let mut v18 = v18.into_context_iter();
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v29,
                                                    arg: v30,
                                                } = &v19.1 {
                                                    if let &Opcode::Uextend = v29 {
                                                        let v971 = C::value_type(ctx, v30);
                                                        let v1006 = C::value_type(ctx, v27);
                                                        if v971 == v1006 {
                                                            let v1011 = constructor_bxor(ctx, v971, v30, v27);
                                                            let v1012 = constructor_uextend(ctx, v2.0, v1011);
                                                            // Rule at src/opts/extends.isle line 74.
                                                            returns.extend(Some(v1012));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0_u64 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 11.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            let mut v18 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                            let mut v18 = v18.into_context_iter();
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v122,
                                                    args: ref v123,
                                                } = &v19.1 {
                                                    if let &Opcode::Bxor = v122 {
                                                        if v2.0 == v19.0 {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let mut v199 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                            let mut v199 = v199.into_context_iter();
                                                            while let Some(v200) = v199.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v248,
                                                                    imm: v249,
                                                                } = &v200.1 {
                                                                    if let &Opcode::Iconst = v248 {
                                                                        if v2.0 == v200.0 {
                                                                            let v674 = constructor_bxor(ctx, v2.0, v124.1, v7.1);
                                                                            let v675 = constructor_bxor(ctx, v2.0, v124.0, v674);
                                                                            // Rule at src/opts/cprop.isle line 186.
                                                                            returns.extend(Some(v675));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            if v11.0 == v566 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v22,
                                                        imm: v23,
                                                    } = &v19.1 {
                                                        if let &Opcode::Iconst = v22 {
                                                            if v11.0 == v19.0 {
                                                                let v24 = C::u64_from_imm64(ctx, v23);
                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                let v595 = C::u64_xor(ctx, v24, v16);
                                                                let v596 = C::imm64_masked(ctx, v566, v595);
                                                                let v597 = constructor_iconst(ctx, v566, v596);
                                                                let v598 = C::subsume(ctx, v597);
                                                                // Rule at src/opts/cprop.isle line 67.
                                                                returns.extend(Some(v598));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 21.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    if let &Opcode::Bxor = v122 {
                                        if v2.0 == v19.0 {
                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                            if v7.1 == v124.1 {
                                                // Rule at src/opts/bitops.isle line 224.
                                                returns.extend(Some(v124.0));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            let mut v127 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                            let mut v127 = v127.into_context_iter();
                                            while let Some(v128) = v127.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v131,
                                                    args: ref v132,
                                                } = &v128.1 {
                                                    if let &Opcode::Bxor = v131 {
                                                        if v2.0 == v128.0 {
                                                            let v133 = C::unpack_value_array_2(ctx, v132);
                                                            let v160 = constructor_bxor(ctx, v2.0, v133.0, v133.1);
                                                            let v161 = constructor_bxor(ctx, v2.0, v124.1, v7.1);
                                                            let v162 = constructor_bxor(ctx, v2.0, v160, v161);
                                                            let v163 = C::subsume(ctx, v162);
                                                            // Rule at src/opts/arithmetic.isle line 233.
                                                            returns.extend(Some(v163));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    if let &Opcode::Bnot = v29 {
                                        if v7.1 == v30 {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                if v19.0 == v53 {
                                                    let v239 = constructor_iconst_s(ctx, v53, -1_i64);
                                                    let v240 = C::subsume(ctx, v239);
                                                    // Rule at src/opts/bitops.isle line 23.
                                                    returns.extend(Some(v240));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v643 = constructor_bxor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 133.
                                            returns.extend(Some(v643));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        let v1198 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 19.
                                        returns.extend(Some(v1198));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                let v56 = C::subsume(ctx, v55);
                                // Rule at src/opts/bitops.isle line 17.
                                returns.extend(Some(v56));
                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                            }
                        }
                        let mut v58 = C::inst_data_value_tupled_etor_returns::default();
                        C::inst_data_value_tupled_etor(ctx, v7.1, &mut v58);
                        let mut v58 = v58.into_context_iter();
                        while let Some(v59) = v58.next(ctx) {
                            let v60 = C::iconst_sextend_etor(ctx, v59);
                            if let Some(v61) = v60 {
                                if v61.1 == -1_i64 {
                                    if v2.0 == v61.0 {
                                        let v256 = constructor_bnot(ctx, v2.0, v7.0);
                                        // Rule at src/opts/bitops.isle line 80.
                                        returns.extend(Some(v256));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    if let &Opcode::Iconcat = v104 {
                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                        let v1349 = constructor_rotl(ctx, v2.0, v7.0, v106.0);
                                        // Rule at src/opts/shifts.isle line 142.
                                        returns.extend(Some(v1349));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Ireduce => {
                                            let v1006 = C::value_type(ctx, v27);
                                            let v1338 = C::fits_in_64(ctx, v1006);
                                            if let Some(v1339) = v1338 {
                                                let v1344 = constructor_rotl(ctx, v2.0, v7.0, v27);
                                                // Rule at src/opts/shifts.isle line 126.
                                                returns.extend(Some(v1344));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v1344 = constructor_rotl(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 127.
                                            returns.extend(Some(v1344));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Sextend => {
                                            let v1344 = constructor_rotl(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 128.
                                            returns.extend(Some(v1344));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Binary {
                                                opcode: ref v122,
                                                args: ref v123,
                                            } = &v19.1 {
                                                match v122 {
                                                    &Opcode::Rotl => {
                                                        if v2.0 == v19.0 {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let v1362 = constructor_iadd_uextend(ctx, v124.1, v7.1);
                                                            let v1363 = constructor_rotl(ctx, v2.0, v124.0, v1362);
                                                            // Rule at src/opts/shifts.isle line 239.
                                                            returns.extend(Some(v1363));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                    &Opcode::Rotr => {
                                                        if v2.0 == v19.0 {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let v1365 = constructor_isub_uextend(ctx, v124.1, v7.1);
                                                            let v1367 = constructor_rotr(ctx, v2.0, v124.0, v1365);
                                                            // Rule at src/opts/shifts.isle line 246.
                                                            returns.extend(Some(v1367));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                            }
                                        }
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/shifts.isle line 19.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                        let v1351 = C::u64_and(ctx, v16, v257);
                                        let v1378 = C::u64_eq(ctx, v16, v1351);
                                        if v1378 == false {
                                            let v1379 = constructor_iconst_u(ctx, v11.0, v1351);
                                            let v1384 = constructor_rotl(ctx, v2.0, v7.0, v1379);
                                            // Rule at src/opts/shifts.isle line 304.
                                            returns.extend(Some(v1384));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    match v122 {
                                        &Opcode::Rotl => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                let v1368 = C::value_type(ctx, v124.1);
                                                let v1369 = C::value_type(ctx, v7.1);
                                                if v1368 == v1369 {
                                                    let v1362 = constructor_iadd_uextend(ctx, v124.1, v7.1);
                                                    let v1363 = constructor_rotl(ctx, v2.0, v124.0, v1362);
                                                    // Rule at src/opts/shifts.isle line 260.
                                                    returns.extend(Some(v1363));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                let mut v199 = v199.into_context_iter();
                                                while let Some(v200) = v199.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v248,
                                                        imm: v249,
                                                    } = &v200.1 {
                                                        if let &Opcode::Iconst = v248 {
                                                            let v1362 = constructor_iadd_uextend(ctx, v124.1, v7.1);
                                                            let v1363 = constructor_rotl(ctx, v2.0, v124.0, v1362);
                                                            // Rule at src/opts/shifts.isle line 238.
                                                            returns.extend(Some(v1363));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Rotr => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                if v7.1 == v124.1 {
                                                    let v1361 = C::subsume(ctx, v124.0);
                                                    // Rule at src/opts/shifts.isle line 203.
                                                    returns.extend(Some(v1361));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1368 = C::value_type(ctx, v124.1);
                                                let v1369 = C::value_type(ctx, v7.1);
                                                if v1368 == v1369 {
                                                    let v1365 = constructor_isub_uextend(ctx, v124.1, v7.1);
                                                    let v1367 = constructor_rotr(ctx, v2.0, v124.0, v1365);
                                                    // Rule at src/opts/shifts.isle line 265.
                                                    returns.extend(Some(v1367));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                let mut v199 = v199.into_context_iter();
                                                while let Some(v200) = v199.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v248,
                                                        imm: v249,
                                                    } = &v200.1 {
                                                        if let &Opcode::Iconst = v248 {
                                                            let v1365 = constructor_isub_uextend(ctx, v124.1, v7.1);
                                                            let v1367 = constructor_rotr(ctx, v2.0, v124.0, v1365);
                                                            // Rule at src/opts/shifts.isle line 245.
                                                            returns.extend(Some(v1367));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    if let &Opcode::Splat = v29 {
                                        if v2.0 == v19.0 {
                                            let v1353 = C::lane_type(ctx, v2.0);
                                            let v1505 = constructor_rotl(ctx, v1353, v30, v7.1);
                                            let v1506 = constructor_splat(ctx, v2.0, v1505);
                                            // Rule at src/opts/vector.isle line 68.
                                            returns.extend(Some(v1506));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    if let &Opcode::Iconcat = v104 {
                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                        let v1348 = constructor_rotr(ctx, v2.0, v7.0, v106.0);
                                        // Rule at src/opts/shifts.isle line 141.
                                        returns.extend(Some(v1348));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Ireduce => {
                                            let v1006 = C::value_type(ctx, v27);
                                            let v1338 = C::fits_in_64(ctx, v1006);
                                            if let Some(v1339) = v1338 {
                                                let v1343 = constructor_rotr(ctx, v2.0, v7.0, v27);
                                                // Rule at src/opts/shifts.isle line 123.
                                                returns.extend(Some(v1343));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v1343 = constructor_rotr(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 124.
                                            returns.extend(Some(v1343));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Sextend => {
                                            let v1343 = constructor_rotr(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 125.
                                            returns.extend(Some(v1343));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Binary {
                                                opcode: ref v122,
                                                args: ref v123,
                                            } = &v19.1 {
                                                match v122 {
                                                    &Opcode::Rotl => {
                                                        if v2.0 == v19.0 {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let v1365 = constructor_isub_uextend(ctx, v124.1, v7.1);
                                                            let v1366 = constructor_rotl(ctx, v2.0, v124.0, v1365);
                                                            // Rule at src/opts/shifts.isle line 244.
                                                            returns.extend(Some(v1366));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                    &Opcode::Rotr => {
                                                        if v2.0 == v19.0 {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let v1362 = constructor_iadd_uextend(ctx, v124.1, v7.1);
                                                            let v1364 = constructor_rotr(ctx, v2.0, v124.0, v1362);
                                                            // Rule at src/opts/shifts.isle line 241.
                                                            returns.extend(Some(v1364));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                            }
                                        }
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/shifts.isle line 15.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                        let v1351 = C::u64_and(ctx, v16, v257);
                                        let v1378 = C::u64_eq(ctx, v16, v1351);
                                        if v1378 == false {
                                            let v1379 = constructor_iconst_u(ctx, v11.0, v1351);
                                            let v1383 = constructor_rotr(ctx, v2.0, v7.0, v1379);
                                            // Rule at src/opts/shifts.isle line 301.
                                            returns.extend(Some(v1383));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    match v122 {
                                        &Opcode::Rotl => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                if v7.1 == v124.1 {
                                                    let v1361 = C::subsume(ctx, v124.0);
                                                    // Rule at src/opts/shifts.isle line 204.
                                                    returns.extend(Some(v1361));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1368 = C::value_type(ctx, v124.1);
                                                let v1369 = C::value_type(ctx, v7.1);
                                                if v1368 == v1369 {
                                                    let v1365 = constructor_isub_uextend(ctx, v124.1, v7.1);
                                                    let v1366 = constructor_rotl(ctx, v2.0, v124.0, v1365);
                                                    // Rule at src/opts/shifts.isle line 263.
                                                    returns.extend(Some(v1366));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                let mut v199 = v199.into_context_iter();
                                                while let Some(v200) = v199.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v248,
                                                        imm: v249,
                                                    } = &v200.1 {
                                                        if let &Opcode::Iconst = v248 {
                                                            let v1365 = constructor_isub_uextend(ctx, v124.1, v7.1);
                                                            let v1366 = constructor_rotl(ctx, v2.0, v124.0, v1365);
                                                            // Rule at src/opts/shifts.isle line 243.
                                                            returns.extend(Some(v1366));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Rotr => {
                                            if v2.0 == v19.0 {
                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                let v1368 = C::value_type(ctx, v124.1);
                                                let v1369 = C::value_type(ctx, v7.1);
                                                if v1368 == v1369 {
                                                    let v1362 = constructor_iadd_uextend(ctx, v124.1, v7.1);
                                                    let v1364 = constructor_rotr(ctx, v2.0, v124.0, v1362);
                                                    // Rule at src/opts/shifts.isle line 258.
                                                    returns.extend(Some(v1364));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                let mut v199 = v199.into_context_iter();
                                                while let Some(v200) = v199.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v248,
                                                        imm: v249,
                                                    } = &v200.1 {
                                                        if let &Opcode::Iconst = v248 {
                                                            let v1362 = constructor_iadd_uextend(ctx, v124.1, v7.1);
                                                            let v1364 = constructor_rotr(ctx, v2.0, v124.0, v1362);
                                                            // Rule at src/opts/shifts.isle line 240.
                                                            returns.extend(Some(v1364));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    if let &Opcode::Splat = v29 {
                                        if v2.0 == v19.0 {
                                            let v1353 = C::lane_type(ctx, v2.0);
                                            let v1507 = constructor_rotr(ctx, v1353, v30, v7.1);
                                            let v1508 = constructor_splat(ctx, v2.0, v1507);
                                            // Rule at src/opts/vector.isle line 71.
                                            returns.extend(Some(v1508));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    if let &Opcode::Iconcat = v104 {
                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                        let v1345 = constructor_ishl(ctx, v2.0, v7.0, v106.0);
                                        // Rule at src/opts/shifts.isle line 138.
                                        returns.extend(Some(v1345));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Ireduce => {
                                            let v1006 = C::value_type(ctx, v27);
                                            let v1338 = C::fits_in_64(ctx, v1006);
                                            if let Some(v1339) = v1338 {
                                                let v1340 = constructor_ishl(ctx, v2.0, v7.0, v27);
                                                // Rule at src/opts/shifts.isle line 114.
                                                returns.extend(Some(v1340));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v1340 = constructor_ishl(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 115.
                                            returns.extend(Some(v1340));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Sextend => {
                                            let v1340 = constructor_ishl(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 116.
                                            returns.extend(Some(v1340));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v122,
                                                    args: ref v123,
                                                } => {
                                                    match v122 {
                                                        &Opcode::Ishl => {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            let v250 = C::u64_from_imm64(ctx, v249);
                                                                            let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                                                            let v1350 = C::u64_and(ctx, v250, v257);
                                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                                            let v1351 = C::u64_and(ctx, v16, v257);
                                                                            let v1352 = C::u64_wrapping_add(ctx, v1350, v1351);
                                                                            let v1353 = C::lane_type(ctx, v2.0);
                                                                            let v1354 = C::ty_bits_u64(ctx, v1353);
                                                                            let v1355 = C::u64_lt(ctx, v1352, v1354);
                                                                            if v1355 == true {
                                                                                let v1356 = constructor_iconst_u(ctx, v200.0, v1352);
                                                                                let v1357 = constructor_ishl(ctx, v2.0, v124.0, v1356);
                                                                                // Rule at src/opts/shifts.isle line 151.
                                                                                returns.extend(Some(v1357));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                            let v1313 = C::ty_bits_u64(ctx, v2.0);
                                                                            let v1360 = C::u64_lt_eq(ctx, v1313, v1352);
                                                                            if v1360 == true {
                                                                                let v980 = constructor_iconst_u(ctx, v2.0, 0x0_u64);
                                                                                let v981 = C::subsume(ctx, v980);
                                                                                // Rule at src/opts/shifts.isle line 183.
                                                                                returns.extend(Some(v981));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                let mut v127 = v127.into_context_iter();
                                                                while let Some(v128) = v127.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v652,
                                                                        imm: v653,
                                                                    } = &v128.1 {
                                                                        if let &Opcode::Iconst = v652 {
                                                                            let v750 = constructor_ishl(ctx, v2.0, v124.0, v7.1);
                                                                            let v751 = constructor_ishl(ctx, v2.0, v750, v124.1);
                                                                            // Rule at src/opts/cprop.isle line 251.
                                                                            returns.extend(Some(v751));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Ushr => {
                                                            let v565 = C::fits_in_64(ctx, v2.0);
                                                            if let Some(v566) = v565 {
                                                                if v19.0 == v566 {
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    let mut v199 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                    let mut v199 = v199.into_context_iter();
                                                                    while let Some(v200) = v199.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v248,
                                                                            imm: v249,
                                                                        } = &v200.1 {
                                                                            if let &Opcode::Iconst = v248 {
                                                                                if v15 == v249 {
                                                                                    let v1304 = C::imm64(ctx, 0xffffffffffffffff_u64);
                                                                                    let v1305 = C::imm64_shl(ctx, v566, v1304, v249);
                                                                                    let v1306 = constructor_iconst(ctx, v566, v1305);
                                                                                    let v1307 = constructor_band(ctx, v566, v124.0, v1306);
                                                                                    // Rule at src/opts/shifts.isle line 26.
                                                                                    returns.extend(Some(v1307));
                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            let v565 = C::fits_in_64(ctx, v2.0);
                                                            if let Some(v566) = v565 {
                                                                if v19.0 == v566 {
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    let mut v199 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                    let mut v199 = v199.into_context_iter();
                                                                    while let Some(v200) = v199.next(ctx) {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v248,
                                                                            imm: v249,
                                                                        } = &v200.1 {
                                                                            if let &Opcode::Iconst = v248 {
                                                                                if v15 == v249 {
                                                                                    let v1304 = C::imm64(ctx, 0xffffffffffffffff_u64);
                                                                                    let v1305 = C::imm64_shl(ctx, v566, v1304, v249);
                                                                                    let v1306 = constructor_iconst(ctx, v566, v1305);
                                                                                    let v1307 = constructor_band(ctx, v566, v124.0, v1306);
                                                                                    // Rule at src/opts/shifts.isle line 31.
                                                                                    returns.extend(Some(v1307));
                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v565 = C::fits_in_64(ctx, v2.0);
                                                        if let Some(v566) = v565 {
                                                            if v19.0 == v566 {
                                                                let v604 = C::imm64_shl(ctx, v566, v23, v15);
                                                                let v605 = constructor_iconst(ctx, v566, v604);
                                                                let v606 = C::subsume(ctx, v605);
                                                                // Rule at src/opts/cprop.isle line 78.
                                                                returns.extend(Some(v606));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/shifts.isle line 3.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                        let v1351 = C::u64_and(ctx, v16, v257);
                                        let v1378 = C::u64_eq(ctx, v16, v1351);
                                        if v1378 == false {
                                            let v1379 = constructor_iconst_u(ctx, v11.0, v1351);
                                            let v1380 = constructor_ishl(ctx, v2.0, v7.0, v1379);
                                            // Rule at src/opts/shifts.isle line 292.
                                            returns.extend(Some(v1380));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v29,
                                arg: v30,
                            } = &v19.1 {
                                if let &Opcode::Splat = v29 {
                                    if v2.0 == v19.0 {
                                        let v1353 = C::lane_type(ctx, v2.0);
                                        let v1509 = constructor_ishl(ctx, v1353, v30, v7.1);
                                        let v1510 = constructor_splat(ctx, v2.0, v1509);
                                        // Rule at src/opts/vector.isle line 74.
                                        returns.extend(Some(v1510));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    if let &Opcode::Iconcat = v104 {
                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                        let v1346 = constructor_ushr(ctx, v2.0, v7.0, v106.0);
                                        // Rule at src/opts/shifts.isle line 139.
                                        returns.extend(Some(v1346));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Ireduce => {
                                            let v1006 = C::value_type(ctx, v27);
                                            let v1338 = C::fits_in_64(ctx, v1006);
                                            if let Some(v1339) = v1338 {
                                                let v1341 = constructor_ushr(ctx, v2.0, v7.0, v27);
                                                // Rule at src/opts/shifts.isle line 117.
                                                returns.extend(Some(v1341));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v1341 = constructor_ushr(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 118.
                                            returns.extend(Some(v1341));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Sextend => {
                                            let v1341 = constructor_ushr(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 119.
                                            returns.extend(Some(v1341));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v122,
                                                    args: ref v123,
                                                } => {
                                                    match v122 {
                                                        &Opcode::Imul => {
                                                            let v206 = C::ty_half_width(ctx, v2.0);
                                                            if let Some(v207) = v206 {
                                                                if v2.0 == v19.0 {
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    let mut v127 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                    let mut v127 = v127.into_context_iter();
                                                                    while let Some(v128) = v127.next(ctx) {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v196,
                                                                            arg: v197,
                                                                        } = &v128.1 {
                                                                            if let &Opcode::Uextend = v196 {
                                                                                let v198 = C::value_type(ctx, v197);
                                                                                let v208 = C::ty_equal(ctx, v198, v207);
                                                                                if v208 == true {
                                                                                    let v16 = C::u64_from_imm64(ctx, v15);
                                                                                    let v209 = C::ty_bits_u64(ctx, v198);
                                                                                    let v210 = C::u64_eq(ctx, v16, v209);
                                                                                    if v210 == true {
                                                                                        let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                        C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                        let mut v199 = v199.into_context_iter();
                                                                                        while let Some(v200) = v199.next(ctx) {
                                                                                            if let &InstructionData::Unary {
                                                                                                opcode: ref v203,
                                                                                                arg: v204,
                                                                                            } = &v200.1 {
                                                                                                if let &Opcode::Uextend = v203 {
                                                                                                    let v205 = C::value_type(ctx, v204);
                                                                                                    if v198 == v205 {
                                                                                                        let v213 = constructor_umulhi(ctx, v198, v197, v204);
                                                                                                        let v214 = constructor_uextend(ctx, v2.0, v213);
                                                                                                        // Rule at src/opts/arithmetic.isle line 306.
                                                                                                        returns.extend(Some(v214));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Ishl => {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let mut v199 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                            let mut v199 = v199.into_context_iter();
                                                            while let Some(v200) = v199.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v248,
                                                                    imm: v249,
                                                                } = &v200.1 {
                                                                    if let &Opcode::Iconst = v248 {
                                                                        if v15 == v249 {
                                                                            let v52 = C::ty_int(ctx, v2.0);
                                                                            if let Some(v53) = v52 {
                                                                                let v250 = C::u64_from_imm64(ctx, v249);
                                                                                let v1319 = C::u64_matches_non_zero(ctx, v250);
                                                                                if let Some(v1320) = v1319 {
                                                                                    if v1320 == true {
                                                                                        let v1321 = C::ty_bits(ctx, v53);
                                                                                        let v1322 = C::u8_into_u64(ctx, v1321);
                                                                                        let v1323 = C::u64_wrapping_sub(ctx, v1322, v250);
                                                                                        let v1324 = constructor_shift_amt_to_type(ctx, v1323);
                                                                                        if let Some(v1325) = v1324 {
                                                                                            if v19.0 == v53 {
                                                                                                let v1326 = constructor_ireduce(ctx, v1325, v124.0);
                                                                                                let v1328 = constructor_uextend(ctx, v53, v1326);
                                                                                                // Rule at src/opts/shifts.isle line 87.
                                                                                                returns.extend(Some(v1328));
                                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            let v565 = C::fits_in_64(ctx, v2.0);
                                                                            if let Some(v566) = v565 {
                                                                                let v1095 = C::ty_int(ctx, v566);
                                                                                if let Some(v1096) = v1095 {
                                                                                    if v19.0 == v1096 {
                                                                                        let v1308 = C::ty_mask(ctx, v1096);
                                                                                        let v1309 = C::imm64(ctx, v1308);
                                                                                        let v1310 = C::imm64_ushr(ctx, v1096, v1309, v249);
                                                                                        let v1311 = constructor_iconst(ctx, v1096, v1310);
                                                                                        let v1312 = constructor_band(ctx, v1096, v124.0, v1311);
                                                                                        // Rule at src/opts/shifts.isle line 40.
                                                                                        returns.extend(Some(v1312));
                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Ushr => {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            let v250 = C::u64_from_imm64(ctx, v249);
                                                                            let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                                                            let v1350 = C::u64_and(ctx, v250, v257);
                                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                                            let v1351 = C::u64_and(ctx, v16, v257);
                                                                            let v1352 = C::u64_wrapping_add(ctx, v1350, v1351);
                                                                            let v1353 = C::lane_type(ctx, v2.0);
                                                                            let v1354 = C::ty_bits_u64(ctx, v1353);
                                                                            let v1355 = C::u64_lt(ctx, v1352, v1354);
                                                                            if v1355 == true {
                                                                                let v1356 = constructor_iconst_u(ctx, v200.0, v1352);
                                                                                let v1358 = constructor_ushr(ctx, v2.0, v124.0, v1356);
                                                                                // Rule at src/opts/shifts.isle line 160.
                                                                                returns.extend(Some(v1358));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                            let v1313 = C::ty_bits_u64(ctx, v2.0);
                                                                            let v1360 = C::u64_lt_eq(ctx, v1313, v1352);
                                                                            if v1360 == true {
                                                                                let v980 = constructor_iconst_u(ctx, v2.0, 0x0_u64);
                                                                                let v981 = C::subsume(ctx, v980);
                                                                                // Rule at src/opts/shifts.isle line 192.
                                                                                returns.extend(Some(v981));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                let mut v127 = v127.into_context_iter();
                                                                while let Some(v128) = v127.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v652,
                                                                        imm: v653,
                                                                    } = &v128.1 {
                                                                        if let &Opcode::Iconst = v652 {
                                                                            let v752 = constructor_ushr(ctx, v2.0, v124.0, v7.1);
                                                                            let v753 = constructor_ushr(ctx, v2.0, v752, v124.1);
                                                                            // Rule at src/opts/cprop.isle line 253.
                                                                            returns.extend(Some(v753));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v565 = C::fits_in_64(ctx, v2.0);
                                                        if let Some(v566) = v565 {
                                                            if v19.0 == v566 {
                                                                let v607 = C::imm64_ushr(ctx, v566, v23, v15);
                                                                let v608 = constructor_iconst(ctx, v566, v607);
                                                                let v609 = C::subsume(ctx, v608);
                                                                // Rule at src/opts/cprop.isle line 83.
                                                                returns.extend(Some(v609));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/shifts.isle line 7.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                        let v1351 = C::u64_and(ctx, v16, v257);
                                        let v1378 = C::u64_eq(ctx, v16, v1351);
                                        if v1378 == false {
                                            let v1379 = constructor_iconst_u(ctx, v11.0, v1351);
                                            let v1381 = constructor_ushr(ctx, v2.0, v7.0, v1379);
                                            // Rule at src/opts/shifts.isle line 295.
                                            returns.extend(Some(v1381));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v122,
                                    args: ref v123,
                                } => {
                                    if let &Opcode::Band = v122 {
                                        if v2.0 == v19.0 {
                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                            let mut v127 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                            let mut v127 = v127.into_context_iter();
                                            while let Some(v128) = v127.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v131,
                                                    args: ref v132,
                                                } = &v128.1 {
                                                    if let &Opcode::Ishl = v131 {
                                                        if v2.0 == v128.0 {
                                                            let v133 = C::unpack_value_array_2(ctx, v132);
                                                            if v7.1 == v133.1 {
                                                                let v1389 = constructor_ushr(ctx, v2.0, v124.1, v133.1);
                                                                let v1390 = constructor_band(ctx, v2.0, v133.0, v1389);
                                                                // Rule at src/opts/shifts.isle line 312.
                                                                returns.extend(Some(v1390));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v29,
                                    arg: v30,
                                } => {
                                    if let &Opcode::Splat = v29 {
                                        if v2.0 == v19.0 {
                                            let v1353 = C::lane_type(ctx, v2.0);
                                            let v1511 = constructor_ushr(ctx, v1353, v30, v7.1);
                                            let v1512 = constructor_splat(ctx, v2.0, v1511);
                                            // Rule at src/opts/vector.isle line 77.
                                            returns.extend(Some(v1512));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Binary {
                                    opcode: ref v104,
                                    args: ref v105,
                                } => {
                                    if let &Opcode::Iconcat = v104 {
                                        let v106 = C::unpack_value_array_2(ctx, v105);
                                        let v1347 = constructor_sshr(ctx, v2.0, v7.0, v106.0);
                                        // Rule at src/opts/shifts.isle line 140.
                                        returns.extend(Some(v1347));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    match v26 {
                                        &Opcode::Ireduce => {
                                            let v1006 = C::value_type(ctx, v27);
                                            let v1338 = C::fits_in_64(ctx, v1006);
                                            if let Some(v1339) = v1338 {
                                                let v1342 = constructor_sshr(ctx, v2.0, v7.0, v27);
                                                // Rule at src/opts/shifts.isle line 120.
                                                returns.extend(Some(v1342));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v1342 = constructor_sshr(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 121.
                                            returns.extend(Some(v1342));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Sextend => {
                                            let v1342 = constructor_sshr(ctx, v2.0, v7.0, v27);
                                            // Rule at src/opts/shifts.isle line 122.
                                            returns.extend(Some(v1342));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let mut v18 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                        let mut v18 = v18.into_context_iter();
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v122,
                                                    args: ref v123,
                                                } => {
                                                    match v122 {
                                                        &Opcode::Imul => {
                                                            let v206 = C::ty_half_width(ctx, v2.0);
                                                            if let Some(v207) = v206 {
                                                                if v2.0 == v19.0 {
                                                                    let v124 = C::unpack_value_array_2(ctx, v123);
                                                                    let mut v127 = C::inst_data_value_etor_returns::default();
                                                                    C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                    let mut v127 = v127.into_context_iter();
                                                                    while let Some(v128) = v127.next(ctx) {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v196,
                                                                            arg: v197,
                                                                        } = &v128.1 {
                                                                            if let &Opcode::Sextend = v196 {
                                                                                let v198 = C::value_type(ctx, v197);
                                                                                let v208 = C::ty_equal(ctx, v198, v207);
                                                                                if v208 == true {
                                                                                    let v16 = C::u64_from_imm64(ctx, v15);
                                                                                    let v209 = C::ty_bits_u64(ctx, v198);
                                                                                    let v210 = C::u64_eq(ctx, v16, v209);
                                                                                    if v210 == true {
                                                                                        let mut v199 = C::inst_data_value_etor_returns::default();
                                                                                        C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                                        let mut v199 = v199.into_context_iter();
                                                                                        while let Some(v200) = v199.next(ctx) {
                                                                                            if let &InstructionData::Unary {
                                                                                                opcode: ref v203,
                                                                                                arg: v204,
                                                                                            } = &v200.1 {
                                                                                                if let &Opcode::Sextend = v203 {
                                                                                                    let v205 = C::value_type(ctx, v204);
                                                                                                    if v198 == v205 {
                                                                                                        let v211 = constructor_smulhi(ctx, v198, v197, v204);
                                                                                                        let v212 = constructor_sextend(ctx, v2.0, v211);
                                                                                                        // Rule at src/opts/arithmetic.isle line 300.
                                                                                                        returns.extend(Some(v212));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Bor => {
                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                            let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                                            let v258 = C::u64_eq(ctx, v16, v257);
                                                            if v258 == true {
                                                                if v2.0 == v11.0 {
                                                                    if v2.0 == v19.0 {
                                                                        let v124 = C::unpack_value_array_2(ctx, v123);
                                                                        let mut v127 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                        let mut v127 = v127.into_context_iter();
                                                                        while let Some(v128) = v127.next(ctx) {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v196,
                                                                                arg: v197,
                                                                            } = &v128.1 {
                                                                                if let &Opcode::Ineg = v196 {
                                                                                    if v2.0 == v128.0 {
                                                                                        if v124.1 == v197 {
                                                                                            let v260 = constructor_bmask(ctx, v2.0, v197);
                                                                                            // Rule at src/opts/bitops.isle line 91.
                                                                                            returns.extend(Some(v260));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        let mut v199 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                        let mut v199 = v199.into_context_iter();
                                                                        while let Some(v200) = v199.next(ctx) {
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v203,
                                                                                arg: v204,
                                                                            } = &v200.1 {
                                                                                if let &Opcode::Ineg = v203 {
                                                                                    if v124.0 == v204 {
                                                                                        if v2.0 == v200.0 {
                                                                                            let v259 = constructor_bmask(ctx, v2.0, v124.0);
                                                                                            // Rule at src/opts/bitops.isle line 87.
                                                                                            returns.extend(Some(v259));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Ishl => {
                                                            let v124 = C::unpack_value_array_2(ctx, v123);
                                                            let mut v199 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                            let mut v199 = v199.into_context_iter();
                                                            while let Some(v200) = v199.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v248,
                                                                    imm: v249,
                                                                } = &v200.1 {
                                                                    if let &Opcode::Iconst = v248 {
                                                                        if v2.0 == v19.0 {
                                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                                            let v250 = C::u64_from_imm64(ctx, v249);
                                                                            if v16 == v250 {
                                                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                                let mut v127 = v127.into_context_iter();
                                                                                while let Some(v128) = v127.next(ctx) {
                                                                                    if let &InstructionData::Unary {
                                                                                        opcode: ref v196,
                                                                                        arg: v197,
                                                                                    } = &v128.1 {
                                                                                        match v196 {
                                                                                            &Opcode::Uextend => {
                                                                                                if v2.0 == v128.0 {
                                                                                                    let v1313 = C::ty_bits_u64(ctx, v2.0);
                                                                                                    let v198 = C::value_type(ctx, v197);
                                                                                                    let v209 = C::ty_bits_u64(ctx, v198);
                                                                                                    let v1314 = C::u64_wrapping_sub(ctx, v1313, v209);
                                                                                                    let v1315 = C::u64_eq(ctx, v250, v1314);
                                                                                                    if v1315 == true {
                                                                                                        let v1316 = constructor_sextend(ctx, v2.0, v197);
                                                                                                        // Rule at src/opts/shifts.isle line 49.
                                                                                                        returns.extend(Some(v1316));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                    let v1317 = C::u64_lt(ctx, v250, v1314);
                                                                                                    if v1317 == true {
                                                                                                        // Rule at src/opts/shifts.isle line 60.
                                                                                                        returns.extend(Some(v124.0));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            &Opcode::Sextend => {
                                                                                                let v1313 = C::ty_bits_u64(ctx, v2.0);
                                                                                                let v198 = C::value_type(ctx, v197);
                                                                                                let v209 = C::ty_bits_u64(ctx, v198);
                                                                                                let v1314 = C::u64_wrapping_sub(ctx, v1313, v209);
                                                                                                let v1318 = C::u64_lt_eq(ctx, v250, v1314);
                                                                                                if v1318 == true {
                                                                                                    if v2.0 == v128.0 {
                                                                                                        // Rule at src/opts/shifts.isle line 70.
                                                                                                        returns.extend(Some(v124.0));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            _ => {}
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        if v15 == v249 {
                                                                            let v52 = C::ty_int(ctx, v2.0);
                                                                            if let Some(v53) = v52 {
                                                                                if v19.0 == v53 {
                                                                                    let v250 = C::u64_from_imm64(ctx, v249);
                                                                                    let v1319 = C::u64_matches_non_zero(ctx, v250);
                                                                                    if let Some(v1320) = v1319 {
                                                                                        if v1320 == true {
                                                                                            let v1321 = C::ty_bits(ctx, v53);
                                                                                            let v1322 = C::u8_into_u64(ctx, v1321);
                                                                                            let v1323 = C::u64_wrapping_sub(ctx, v1322, v250);
                                                                                            let v1324 = constructor_shift_amt_to_type(ctx, v1323);
                                                                                            if let Some(v1325) = v1324 {
                                                                                                let v1326 = constructor_ireduce(ctx, v1325, v124.0);
                                                                                                let v1327 = constructor_sextend(ctx, v53, v1326);
                                                                                                // Rule at src/opts/shifts.isle line 83.
                                                                                                returns.extend(Some(v1327));
                                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            if v2.0 == v19.0 {
                                                                let v124 = C::unpack_value_array_2(ctx, v123);
                                                                let mut v127 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.0, &mut v127);
                                                                let mut v127 = v127.into_context_iter();
                                                                while let Some(v128) = v127.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v652,
                                                                        imm: v653,
                                                                    } = &v128.1 {
                                                                        if let &Opcode::Iconst = v652 {
                                                                            let v754 = constructor_sshr(ctx, v2.0, v124.0, v7.1);
                                                                            let v755 = constructor_sshr(ctx, v2.0, v754, v124.1);
                                                                            // Rule at src/opts/cprop.isle line 255.
                                                                            returns.extend(Some(v755));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                                let mut v199 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v124.1, &mut v199);
                                                                let mut v199 = v199.into_context_iter();
                                                                while let Some(v200) = v199.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v248,
                                                                        imm: v249,
                                                                    } = &v200.1 {
                                                                        if let &Opcode::Iconst = v248 {
                                                                            let v250 = C::u64_from_imm64(ctx, v249);
                                                                            let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                                                            let v1350 = C::u64_and(ctx, v250, v257);
                                                                            let v16 = C::u64_from_imm64(ctx, v15);
                                                                            let v1351 = C::u64_and(ctx, v16, v257);
                                                                            let v1352 = C::u64_wrapping_add(ctx, v1350, v1351);
                                                                            let v1353 = C::lane_type(ctx, v2.0);
                                                                            let v1354 = C::ty_bits_u64(ctx, v1353);
                                                                            let v1355 = C::u64_lt(ctx, v1352, v1354);
                                                                            if v1355 == true {
                                                                                let v1356 = constructor_iconst_u(ctx, v200.0, v1352);
                                                                                let v1359 = constructor_sshr(ctx, v2.0, v124.0, v1356);
                                                                                // Rule at src/opts/shifts.isle line 169.
                                                                                returns.extend(Some(v1359));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v565 = C::fits_in_64(ctx, v2.0);
                                                        if let Some(v566) = v565 {
                                                            if v19.0 == v566 {
                                                                let v610 = C::imm64_sshr(ctx, v566, v23, v15);
                                                                let v611 = constructor_iconst(ctx, v566, v610);
                                                                let v612 = C::subsume(ctx, v611);
                                                                // Rule at src/opts/cprop.isle line 88.
                                                                returns.extend(Some(v612));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0_u64 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/shifts.isle line 11.
                                                returns.extend(Some(v17));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                        let v1351 = C::u64_and(ctx, v16, v257);
                                        let v1378 = C::u64_eq(ctx, v16, v1351);
                                        if v1378 == false {
                                            let v1379 = constructor_iconst_u(ctx, v11.0, v1351);
                                            let v1382 = constructor_sshr(ctx, v2.0, v7.0, v1379);
                                            // Rule at src/opts/shifts.isle line 298.
                                            returns.extend(Some(v1382));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v18 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.0, &mut v18);
                        let mut v18 = v18.into_context_iter();
                        while let Some(v19) = v18.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v29,
                                arg: v30,
                            } = &v19.1 {
                                if let &Opcode::Splat = v29 {
                                    if v2.0 == v19.0 {
                                        let v1353 = C::lane_type(ctx, v2.0);
                                        let v1513 = constructor_sshr(ctx, v1353, v30, v7.1);
                                        let v1514 = constructor_splat(ctx, v2.0, v1513);
                                        // Rule at src/opts/vector.isle line 80.
                                        returns.extend(Some(v1514));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fadd => {
                        match v2.0 {
                            F32 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v797,
                                            imm: v798,
                                        } = &v11.1 {
                                            if let &Opcode::F32const = v797 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F32 {
                                                        if let &InstructionData::UnaryIeee32 {
                                                            opcode: ref v795,
                                                            imm: v796,
                                                        } = &v19.1 {
                                                            if let &Opcode::F32const = v795 {
                                                                let v799 = C::f32_add(ctx, v796, v798);
                                                                if let Some(v800) = v799 {
                                                                    let v801 = constructor_f32const(ctx, F32, v800);
                                                                    let v802 = C::subsume(ctx, v801);
                                                                    // Rule at src/opts/cprop.isle line 329.
                                                                    returns.extend(Some(v802));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v805,
                                            imm: v806,
                                        } = &v11.1 {
                                            if let &Opcode::F64const = v805 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F64 {
                                                        if let &InstructionData::UnaryIeee64 {
                                                            opcode: ref v803,
                                                            imm: v804,
                                                        } = &v19.1 {
                                                            if let &Opcode::F64const = v803 {
                                                                let v807 = C::f64_add(ctx, v804, v806);
                                                                if let Some(v808) = v807 {
                                                                    let v809 = constructor_f64const(ctx, F64, v808);
                                                                    let v810 = C::subsume(ctx, v809);
                                                                    // Rule at src/opts/cprop.isle line 332.
                                                                    returns.extend(Some(v810));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Fsub => {
                        match v2.0 {
                            F32 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v797,
                                            imm: v798,
                                        } = &v11.1 {
                                            if let &Opcode::F32const = v797 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F32 {
                                                        if let &InstructionData::UnaryIeee32 {
                                                            opcode: ref v795,
                                                            imm: v796,
                                                        } = &v19.1 {
                                                            if let &Opcode::F32const = v795 {
                                                                let v811 = C::f32_sub(ctx, v796, v798);
                                                                if let Some(v812) = v811 {
                                                                    let v813 = constructor_f32const(ctx, F32, v812);
                                                                    let v814 = C::subsume(ctx, v813);
                                                                    // Rule at src/opts/cprop.isle line 336.
                                                                    returns.extend(Some(v814));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v805,
                                            imm: v806,
                                        } = &v11.1 {
                                            if let &Opcode::F64const = v805 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F64 {
                                                        if let &InstructionData::UnaryIeee64 {
                                                            opcode: ref v803,
                                                            imm: v804,
                                                        } = &v19.1 {
                                                            if let &Opcode::F64const = v803 {
                                                                let v815 = C::f64_sub(ctx, v804, v806);
                                                                if let Some(v816) = v815 {
                                                                    let v817 = constructor_f64const(ctx, F64, v816);
                                                                    let v818 = C::subsume(ctx, v817);
                                                                    // Rule at src/opts/cprop.isle line 339.
                                                                    returns.extend(Some(v818));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Fmul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let mut v10 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v7.1, &mut v10);
                        let mut v10 = v10.into_context_iter();
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v26,
                                    arg: v27,
                                } => {
                                    if let &Opcode::Fneg = v26 {
                                        if v2.0 == v11.0 {
                                            let mut v18 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                            let mut v18 = v18.into_context_iter();
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v29,
                                                    arg: v30,
                                                } = &v19.1 {
                                                    if let &Opcode::Fneg = v29 {
                                                        if v2.0 == v19.0 {
                                                            let v103 = constructor_fmul(ctx, v2.0, v30, v27);
                                                            // Rule at src/opts/arithmetic.isle line 195.
                                                            returns.extend(Some(v103));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryIeee32 {
                                    opcode: ref v797,
                                    imm: v798,
                                } => {
                                    if let &Opcode::F32const = v797 {
                                        if v2.0 == F32 {
                                            if v11.0 == F32 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F32 {
                                                        if let &InstructionData::UnaryIeee32 {
                                                            opcode: ref v795,
                                                            imm: v796,
                                                        } = &v19.1 {
                                                            if let &Opcode::F32const = v795 {
                                                                let v819 = C::f32_mul(ctx, v796, v798);
                                                                if let Some(v820) = v819 {
                                                                    let v821 = constructor_f32const(ctx, F32, v820);
                                                                    let v822 = C::subsume(ctx, v821);
                                                                    // Rule at src/opts/cprop.isle line 343.
                                                                    returns.extend(Some(v822));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryIeee64 {
                                    opcode: ref v805,
                                    imm: v806,
                                } => {
                                    if let &Opcode::F64const = v805 {
                                        if v2.0 == F64 {
                                            if v11.0 == F64 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F64 {
                                                        if let &InstructionData::UnaryIeee64 {
                                                            opcode: ref v803,
                                                            imm: v804,
                                                        } = &v19.1 {
                                                            if let &Opcode::F64const = v803 {
                                                                let v823 = C::f64_mul(ctx, v804, v806);
                                                                if let Some(v824) = v823 {
                                                                    let v825 = constructor_f64const(ctx, F64, v824);
                                                                    let v826 = C::subsume(ctx, v825);
                                                                    // Rule at src/opts/cprop.isle line 346.
                                                                    returns.extend(Some(v826));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Fdiv => {
                        match v2.0 {
                            F32 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v797,
                                            imm: v798,
                                        } = &v11.1 {
                                            if let &Opcode::F32const = v797 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F32 {
                                                        if let &InstructionData::UnaryIeee32 {
                                                            opcode: ref v795,
                                                            imm: v796,
                                                        } = &v19.1 {
                                                            if let &Opcode::F32const = v795 {
                                                                let v827 = C::f32_div(ctx, v796, v798);
                                                                if let Some(v828) = v827 {
                                                                    let v829 = constructor_f32const(ctx, F32, v828);
                                                                    let v830 = C::subsume(ctx, v829);
                                                                    // Rule at src/opts/cprop.isle line 350.
                                                                    returns.extend(Some(v830));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v805,
                                            imm: v806,
                                        } = &v11.1 {
                                            if let &Opcode::F64const = v805 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F64 {
                                                        if let &InstructionData::UnaryIeee64 {
                                                            opcode: ref v803,
                                                            imm: v804,
                                                        } = &v19.1 {
                                                            if let &Opcode::F64const = v803 {
                                                                let v831 = C::f64_div(ctx, v804, v806);
                                                                if let Some(v832) = v831 {
                                                                    let v833 = constructor_f64const(ctx, F64, v832);
                                                                    let v834 = C::subsume(ctx, v833);
                                                                    // Rule at src/opts/cprop.isle line 353.
                                                                    returns.extend(Some(v834));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Fcopysign => {
                        match v2.0 {
                            F16 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F16 {
                                        if let &InstructionData::UnaryIeee16 {
                                            opcode: ref v877,
                                            imm: v878,
                                        } = &v11.1 {
                                            if let &Opcode::F16const = v877 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F16 {
                                                        if let &InstructionData::UnaryIeee16 {
                                                            opcode: ref v875,
                                                            imm: v876,
                                                        } = &v19.1 {
                                                            if let &Opcode::F16const = v875 {
                                                                let v955 = C::f16_copysign(ctx, v876, v878);
                                                                let v956 = constructor_f16const(ctx, F16, v955);
                                                                let v957 = C::subsume(ctx, v956);
                                                                // Rule at src/opts/cprop.isle line 436.
                                                                returns.extend(Some(v957));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F32 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v797,
                                            imm: v798,
                                        } = &v11.1 {
                                            if let &Opcode::F32const = v797 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F32 {
                                                        if let &InstructionData::UnaryIeee32 {
                                                            opcode: ref v795,
                                                            imm: v796,
                                                        } = &v19.1 {
                                                            if let &Opcode::F32const = v795 {
                                                                let v958 = C::f32_copysign(ctx, v796, v798);
                                                                let v959 = constructor_f32const(ctx, F32, v958);
                                                                let v960 = C::subsume(ctx, v959);
                                                                // Rule at src/opts/cprop.isle line 438.
                                                                returns.extend(Some(v960));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v805,
                                            imm: v806,
                                        } = &v11.1 {
                                            if let &Opcode::F64const = v805 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F64 {
                                                        if let &InstructionData::UnaryIeee64 {
                                                            opcode: ref v803,
                                                            imm: v804,
                                                        } = &v19.1 {
                                                            if let &Opcode::F64const = v803 {
                                                                let v961 = C::f64_copysign(ctx, v804, v806);
                                                                let v962 = constructor_f64const(ctx, F64, v961);
                                                                let v963 = C::subsume(ctx, v962);
                                                                // Rule at src/opts/cprop.isle line 440.
                                                                returns.extend(Some(v963));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F128 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F128 {
                                        if let &InstructionData::UnaryConst {
                                            opcode: ref v895,
                                            constant_handle: v896,
                                        } = &v11.1 {
                                            if let &Opcode::F128const = v895 {
                                                let v897 = C::ieee128_constant_extractor(ctx, v896);
                                                if let Some(v898) = v897 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if v19.0 == F128 {
                                                            if let &InstructionData::UnaryConst {
                                                                opcode: ref v891,
                                                                constant_handle: v892,
                                                            } = &v19.1 {
                                                                if let &Opcode::F128const = v891 {
                                                                    let v893 = C::ieee128_constant_extractor(ctx, v892);
                                                                    if let Some(v894) = v893 {
                                                                        let v964 = C::f128_copysign(ctx, v894, v898);
                                                                        let v965 = C::ieee128_constant(ctx, v964);
                                                                        let v966 = constructor_f128const(ctx, F128, v965);
                                                                        let v967 = C::subsume(ctx, v966);
                                                                        // Rule at src/opts/cprop.isle line 442.
                                                                        returns.extend(Some(v967));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Fmin => {
                        match v2.0 {
                            F16 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F16 {
                                        if let &InstructionData::UnaryIeee16 {
                                            opcode: ref v877,
                                            imm: v878,
                                        } = &v11.1 {
                                            if let &Opcode::F16const = v877 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F16 {
                                                        if let &InstructionData::UnaryIeee16 {
                                                            opcode: ref v875,
                                                            imm: v876,
                                                        } = &v19.1 {
                                                            if let &Opcode::F16const = v875 {
                                                                let v879 = C::f16_min(ctx, v876, v878);
                                                                if let Some(v880) = v879 {
                                                                    let v881 = constructor_f16const(ctx, F32, v880);
                                                                    let v882 = C::subsume(ctx, v881);
                                                                    // Rule at src/opts/cprop.isle line 392.
                                                                    returns.extend(Some(v882));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F32 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v797,
                                            imm: v798,
                                        } = &v11.1 {
                                            if let &Opcode::F32const = v797 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F32 {
                                                        if let &InstructionData::UnaryIeee32 {
                                                            opcode: ref v795,
                                                            imm: v796,
                                                        } = &v19.1 {
                                                            if let &Opcode::F32const = v795 {
                                                                let v883 = C::f32_min(ctx, v796, v798);
                                                                if let Some(v884) = v883 {
                                                                    let v885 = constructor_f32const(ctx, F32, v884);
                                                                    let v886 = C::subsume(ctx, v885);
                                                                    // Rule at src/opts/cprop.isle line 395.
                                                                    returns.extend(Some(v886));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v805,
                                            imm: v806,
                                        } = &v11.1 {
                                            if let &Opcode::F64const = v805 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F64 {
                                                        if let &InstructionData::UnaryIeee64 {
                                                            opcode: ref v803,
                                                            imm: v804,
                                                        } = &v19.1 {
                                                            if let &Opcode::F64const = v803 {
                                                                let v887 = C::f64_min(ctx, v804, v806);
                                                                if let Some(v888) = v887 {
                                                                    let v889 = constructor_f64const(ctx, F64, v888);
                                                                    let v890 = C::subsume(ctx, v889);
                                                                    // Rule at src/opts/cprop.isle line 398.
                                                                    returns.extend(Some(v890));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F128 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F128 {
                                        if let &InstructionData::UnaryConst {
                                            opcode: ref v895,
                                            constant_handle: v896,
                                        } = &v11.1 {
                                            if let &Opcode::F128const = v895 {
                                                let v897 = C::ieee128_constant_extractor(ctx, v896);
                                                if let Some(v898) = v897 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if v19.0 == F128 {
                                                            if let &InstructionData::UnaryConst {
                                                                opcode: ref v891,
                                                                constant_handle: v892,
                                                            } = &v19.1 {
                                                                if let &Opcode::F128const = v891 {
                                                                    let v893 = C::ieee128_constant_extractor(ctx, v892);
                                                                    if let Some(v894) = v893 {
                                                                        let v899 = C::f128_min(ctx, v894, v898);
                                                                        if let Some(v900) = v899 {
                                                                            let v902 = C::ieee128_constant(ctx, v900);
                                                                            let v903 = constructor_f128const(ctx, F128, v902);
                                                                            let v904 = C::subsume(ctx, v903);
                                                                            // Rule at src/opts/cprop.isle line 401.
                                                                            returns.extend(Some(v904));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Fmax => {
                        match v2.0 {
                            F16 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F16 {
                                        if let &InstructionData::UnaryIeee16 {
                                            opcode: ref v877,
                                            imm: v878,
                                        } = &v11.1 {
                                            if let &Opcode::F16const = v877 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F16 {
                                                        if let &InstructionData::UnaryIeee16 {
                                                            opcode: ref v875,
                                                            imm: v876,
                                                        } = &v19.1 {
                                                            if let &Opcode::F16const = v875 {
                                                                let v905 = C::f16_max(ctx, v876, v878);
                                                                if let Some(v906) = v905 {
                                                                    let v908 = constructor_f16const(ctx, F16, v906);
                                                                    let v909 = C::subsume(ctx, v908);
                                                                    // Rule at src/opts/cprop.isle line 405.
                                                                    returns.extend(Some(v909));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F32 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v797,
                                            imm: v798,
                                        } = &v11.1 {
                                            if let &Opcode::F32const = v797 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F32 {
                                                        if let &InstructionData::UnaryIeee32 {
                                                            opcode: ref v795,
                                                            imm: v796,
                                                        } = &v19.1 {
                                                            if let &Opcode::F32const = v795 {
                                                                let v910 = C::f32_max(ctx, v796, v798);
                                                                if let Some(v911) = v910 {
                                                                    let v912 = constructor_f32const(ctx, F32, v911);
                                                                    let v913 = C::subsume(ctx, v912);
                                                                    // Rule at src/opts/cprop.isle line 408.
                                                                    returns.extend(Some(v913));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v805,
                                            imm: v806,
                                        } = &v11.1 {
                                            if let &Opcode::F64const = v805 {
                                                let mut v18 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                let mut v18 = v18.into_context_iter();
                                                while let Some(v19) = v18.next(ctx) {
                                                    if v19.0 == F64 {
                                                        if let &InstructionData::UnaryIeee64 {
                                                            opcode: ref v803,
                                                            imm: v804,
                                                        } = &v19.1 {
                                                            if let &Opcode::F64const = v803 {
                                                                let v914 = C::f64_max(ctx, v804, v806);
                                                                if let Some(v915) = v914 {
                                                                    let v916 = constructor_f64const(ctx, F64, v915);
                                                                    let v917 = C::subsume(ctx, v916);
                                                                    // Rule at src/opts/cprop.isle line 411.
                                                                    returns.extend(Some(v917));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F128 => {
                                let v7 = C::unpack_value_array_2(ctx, v6);
                                let mut v10 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v7.1, &mut v10);
                                let mut v10 = v10.into_context_iter();
                                while let Some(v11) = v10.next(ctx) {
                                    if v11.0 == F128 {
                                        if let &InstructionData::UnaryConst {
                                            opcode: ref v895,
                                            constant_handle: v896,
                                        } = &v11.1 {
                                            if let &Opcode::F128const = v895 {
                                                let v897 = C::ieee128_constant_extractor(ctx, v896);
                                                if let Some(v898) = v897 {
                                                    let mut v18 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v7.0, &mut v18);
                                                    let mut v18 = v18.into_context_iter();
                                                    while let Some(v19) = v18.next(ctx) {
                                                        if v19.0 == F128 {
                                                            if let &InstructionData::UnaryConst {
                                                                opcode: ref v891,
                                                                constant_handle: v892,
                                                            } = &v19.1 {
                                                                if let &Opcode::F128const = v891 {
                                                                    let v893 = C::ieee128_constant_extractor(ctx, v892);
                                                                    if let Some(v894) = v893 {
                                                                        let v918 = C::f128_max(ctx, v894, v898);
                                                                        if let Some(v919) = v918 {
                                                                            let v920 = C::ieee128_constant(ctx, v919);
                                                                            let v921 = constructor_f128const(ctx, F128, v920);
                                                                            let v922 = C::subsume(ctx, v921);
                                                                            // Rule at src/opts/cprop.isle line 414.
                                                                            returns.extend(Some(v922));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Iconcat => {
                        if v2.0 == I128 {
                            let v7 = C::unpack_value_array_2(ctx, v6);
                            let mut v10 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v7.1, &mut v10);
                            let mut v10 = v10.into_context_iter();
                            while let Some(v11) = v10.next(ctx) {
                                match &v11.1 {
                                    &InstructionData::Binary {
                                        opcode: ref v104,
                                        args: ref v105,
                                    } => {
                                        if let &Opcode::Sshr = v104 {
                                            let v106 = C::unpack_value_array_2(ctx, v105);
                                            if v7.0 == v106.0 {
                                                let mut v109 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v106.1, &mut v109);
                                                let mut v109 = v109.into_context_iter();
                                                while let Some(v110) = v109.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v756,
                                                        imm: v757,
                                                    } = &v110.1 {
                                                        if let &Opcode::Iconst = v756 {
                                                            let v1026 = C::u64_from_imm64(ctx, v757);
                                                            if v1026 == 0x3f_u64 {
                                                                let v1027 = constructor_sextend(ctx, I128, v7.0);
                                                                // Rule at src/opts/extends.isle line 94.
                                                                returns.extend(Some(v1027));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &InstructionData::UnaryImm {
                                        opcode: ref v14,
                                        imm: v15,
                                    } => {
                                        if let &Opcode::Iconst = v14 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0_u64 {
                                                let v1025 = constructor_uextend(ctx, I128, v7.0);
                                                // Rule at src/opts/extends.isle line 93.
                                                returns.extend(Some(v1025));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v275,
                args: ref v276,
                cond: ref v277,
            } => {
                if let &Opcode::Icmp = v275 {
                    match v277 {
                        &IntCC::Equal => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v628 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                            let mut v628 = v628.into_context_iter();
                            while let Some(v629) = v628.next(ctx) {
                                match &v629.1 {
                                    &InstructionData::Binary {
                                        opcode: ref v683,
                                        args: ref v684,
                                    } => {
                                        match v683 {
                                            &Opcode::Iadd => {
                                                let mut v281 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                                let mut v281 = v281.into_context_iter();
                                                while let Some(v282) = v281.next(ctx) {
                                                    match &v282.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v700,
                                                            args: ref v701,
                                                        } => {
                                                            if let &Opcode::Iadd = v700 {
                                                                let v685 = C::unpack_value_array_2(ctx, v684);
                                                                let v702 = C::unpack_value_array_2(ctx, v701);
                                                                if v685.0 == v702.0 {
                                                                    let v1036 = constructor_eq(ctx, v2.0, v685.1, v702.1);
                                                                    let v1037 = C::subsume(ctx, v1036);
                                                                    // Rule at src/opts/icmp.isle line 26.
                                                                    returns.extend(Some(v1037));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                if v685.0 == v702.1 {
                                                                    let v1034 = constructor_eq(ctx, v2.0, v685.1, v702.0);
                                                                    let v1035 = C::subsume(ctx, v1034);
                                                                    // Rule at src/opts/icmp.isle line 24.
                                                                    returns.extend(Some(v1035));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                if v685.1 == v702.0 {
                                                                    let v1032 = constructor_eq(ctx, v2.0, v685.0, v702.1);
                                                                    let v1033 = C::subsume(ctx, v1032);
                                                                    // Rule at src/opts/icmp.isle line 22.
                                                                    returns.extend(Some(v1033));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                if v685.1 == v702.1 {
                                                                    let v1030 = constructor_eq(ctx, v2.0, v685.0, v702.0);
                                                                    let v1031 = C::subsume(ctx, v1030);
                                                                    // Rule at src/opts/icmp.isle line 20.
                                                                    returns.extend(Some(v1031));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                let mut v688 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                                let mut v688 = v688.into_context_iter();
                                                                while let Some(v689) = v688.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v692,
                                                                        imm: v693,
                                                                    } = &v689.1 {
                                                                        if let &Opcode::Iconst = v692 {
                                                                            let mut v705 = C::inst_data_value_etor_returns::default();
                                                                            C::inst_data_value_etor(ctx, v702.1, &mut v705);
                                                                            let mut v705 = v705.into_context_iter();
                                                                            while let Some(v706) = v705.next(ctx) {
                                                                                if let &InstructionData::UnaryImm {
                                                                                    opcode: ref v709,
                                                                                    imm: v710,
                                                                                } = &v706.1 {
                                                                                    if let &Opcode::Iconst = v709 {
                                                                                        let v711 = constructor_isub(ctx, v282.0, v702.1, v685.1);
                                                                                        let v712 = constructor_iadd(ctx, v629.0, v702.0, v711);
                                                                                        let v713 = constructor_eq(ctx, v2.0, v685.0, v712);
                                                                                        // Rule at src/opts/cprop.isle line 207.
                                                                                        returns.extend(Some(v713));
                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v285,
                                                            imm: v286,
                                                        } => {
                                                            if let &Opcode::Iconst = v285 {
                                                                let v685 = C::unpack_value_array_2(ctx, v684);
                                                                let mut v688 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                                let mut v688 = v688.into_context_iter();
                                                                while let Some(v689) = v688.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v692,
                                                                        imm: v693,
                                                                    } = &v689.1 {
                                                                        if let &Opcode::Iconst = v692 {
                                                                            let v694 = constructor_isub(ctx, v629.0, v278.1, v685.1);
                                                                            let v695 = constructor_eq(ctx, v2.0, v685.0, v694);
                                                                            // Rule at src/opts/cprop.isle line 197.
                                                                            returns.extend(Some(v695));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            &Opcode::Isub => {
                                                let v685 = C::unpack_value_array_2(ctx, v684);
                                                let mut v688 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                let mut v688 = v688.into_context_iter();
                                                while let Some(v689) = v688.next(ctx) {
                                                    match &v689.1 {
                                                        &InstructionData::IntCompare {
                                                            opcode: ref v1451,
                                                            args: ref v1452,
                                                            cond: ref v1453,
                                                        } => {
                                                            if let &Opcode::Icmp = v1451 {
                                                                match v1453 {
                                                                    &IntCC::SignedLessThan => {
                                                                        if v629.0 == I8 {
                                                                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                                                                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                                                                            let mut v985 = v985.into_context_iter();
                                                                            while let Some(v986) = v985.next(ctx) {
                                                                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                                                                if let Some(v988) = v987 {
                                                                                    match v988.1 {
                                                                                        -1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1459 = constructor_slt(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 178.
                                                                                                                        returns.extend(Some(v1459));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        0_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1457 = constructor_eq(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 145.
                                                                                                                        returns.extend(Some(v1457));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1463 = constructor_sgt(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 186.
                                                                                                                        returns.extend(Some(v1463));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::UnsignedLessThan => {
                                                                        if v629.0 == I8 {
                                                                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                                                                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                                                                            let mut v985 = v985.into_context_iter();
                                                                            while let Some(v986) = v985.next(ctx) {
                                                                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                                                                if let Some(v988) = v987 {
                                                                                    match v988.1 {
                                                                                        -1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1460 = constructor_ult(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 180.
                                                                                                                        returns.extend(Some(v1460));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        0_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1457 = constructor_eq(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 147.
                                                                                                                        returns.extend(Some(v1457));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1464 = constructor_ugt(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 188.
                                                                                                                        returns.extend(Some(v1464));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v692,
                                                            imm: v693,
                                                        } => {
                                                            if let &Opcode::Iconst = v692 {
                                                                let mut v281 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                                                let mut v281 = v281.into_context_iter();
                                                                while let Some(v282) = v281.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v285,
                                                                        imm: v286,
                                                                    } = &v282.1 {
                                                                        if let &Opcode::Iconst = v285 {
                                                                            let v697 = constructor_iadd(ctx, v629.0, v278.1, v685.1);
                                                                            let v698 = constructor_eq(ctx, v2.0, v685.0, v697);
                                                                            // Rule at src/opts/cprop.isle line 202.
                                                                            returns.extend(Some(v698));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                let mut v281 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                                let mut v281 = v281.into_context_iter();
                                                while let Some(v282) = v281.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v700,
                                                        args: ref v701,
                                                    } = &v282.1 {
                                                        if let &Opcode::Isub = v700 {
                                                            let v702 = C::unpack_value_array_2(ctx, v701);
                                                            let v1046 = constructor_iadd(ctx, v629.0, v685.0, v702.1);
                                                            let v1047 = constructor_iadd(ctx, v282.0, v702.0, v685.1);
                                                            let v1048 = constructor_eq(ctx, v2.0, v1046, v1047);
                                                            // Rule at src/opts/icmp.isle line 40.
                                                            returns.extend(Some(v1048));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    &InstructionData::Unary {
                                        opcode: ref v977,
                                        arg: v978,
                                    } => {
                                        if let &Opcode::Sextend = v977 {
                                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                                            let mut v985 = v985.into_context_iter();
                                            while let Some(v986) = v985.next(ctx) {
                                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                                if let Some(v988) = v987 {
                                                    if v988.1 == 0_i64 {
                                                        let v979 = C::value_type(ctx, v978);
                                                        let v992 = constructor_iconst_s(ctx, v979, 0_i64);
                                                        let v993 = constructor_eq(ctx, v979, v978, v992);
                                                        // Rule at src/opts/extends.isle line 39.
                                                        returns.extend(Some(v993));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            let mut v281 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.1, &mut v281);
                            let mut v281 = v281.into_context_iter();
                            while let Some(v282) = v281.next(ctx) {
                                match &v282.1 {
                                    &InstructionData::Binary {
                                        opcode: ref v700,
                                        args: ref v701,
                                    } => {
                                        if let &Opcode::Bxor = v700 {
                                            let v1167 = C::ty_int(ctx, v282.0);
                                            if let Some(v1168) = v1167 {
                                                let v702 = C::unpack_value_array_2(ctx, v701);
                                                if v278.0 == v702.0 {
                                                    let v1169 = constructor_iconst_u(ctx, v1168, 0x0_u64);
                                                    let v1170 = constructor_eq(ctx, v2.0, v702.1, v1169);
                                                    let v1171 = C::subsume(ctx, v1170);
                                                    // Rule at src/opts/icmp.isle line 290.
                                                    returns.extend(Some(v1171));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                    &InstructionData::UnaryImm {
                                        opcode: ref v285,
                                        imm: v286,
                                    } => {
                                        if let &Opcode::Iconst = v285 {
                                            let v287 = C::u64_from_imm64(ctx, v286);
                                            match v287 {
                                                0x0_u64 => {
                                                    let mut v1050 = C::uextend_maybe_etor_returns::default();
                                                    C::uextend_maybe_etor(ctx, v278.0, &mut v1050);
                                                    let mut v1050 = v1050.into_context_iter();
                                                    while let Some(v1051) = v1050.next(ctx) {
                                                        let mut v1054 = C::inst_data_value_etor_returns::default();
                                                        C::inst_data_value_etor(ctx, v1051.1, &mut v1054);
                                                        let mut v1054 = v1054.into_context_iter();
                                                        while let Some(v1055) = v1054.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v1058,
                                                                args: ref v1059,
                                                                cond: ref v1060,
                                                            } = &v1055.1 {
                                                                if let &Opcode::Icmp = v1058 {
                                                                    if v2.0 == v1055.0 {
                                                                        let v1065 = &C::intcc_complement(ctx, v1060);
                                                                        let v1061 = C::unpack_value_array_2(ctx, v1059);
                                                                        let v1066 = constructor_icmp(ctx, v2.0, v1065, v1061.0, v1061.1);
                                                                        let v1067 = C::subsume(ctx, v1066);
                                                                        // Rule at src/opts/icmp.isle line 55.
                                                                        returns.extend(Some(v1067));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0x1_u64 => {
                                                    let mut v1050 = C::uextend_maybe_etor_returns::default();
                                                    C::uextend_maybe_etor(ctx, v278.0, &mut v1050);
                                                    let mut v1050 = v1050.into_context_iter();
                                                    while let Some(v1051) = v1050.next(ctx) {
                                                        let mut v1054 = C::inst_data_value_etor_returns::default();
                                                        C::inst_data_value_etor(ctx, v1051.1, &mut v1054);
                                                        let mut v1054 = v1054.into_context_iter();
                                                        while let Some(v1055) = v1054.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v1058,
                                                                args: ref v1059,
                                                                cond: ref v1060,
                                                            } = &v1055.1 {
                                                                if let &Opcode::Icmp = v1058 {
                                                                    let v1064 = C::subsume(ctx, v1051.1);
                                                                    // Rule at src/opts/icmp.isle line 69.
                                                                    returns.extend(Some(v1064));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if v278.0 == v278.1 {
                                let v52 = C::ty_int(ctx, v2.0);
                                if let Some(v53) = v52 {
                                    let v1028 = constructor_iconst_u(ctx, v53, 0x1_u64);
                                    let v1029 = C::subsume(ctx, v1028);
                                    // Rule at src/opts/icmp.isle line 4.
                                    returns.extend(Some(v1029));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::NotEqual => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v628 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                            let mut v628 = v628.into_context_iter();
                            while let Some(v629) = v628.next(ctx) {
                                match &v629.1 {
                                    &InstructionData::Binary {
                                        opcode: ref v683,
                                        args: ref v684,
                                    } => {
                                        match v683 {
                                            &Opcode::Iadd => {
                                                let mut v281 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                                let mut v281 = v281.into_context_iter();
                                                while let Some(v282) = v281.next(ctx) {
                                                    match &v282.1 {
                                                        &InstructionData::Binary {
                                                            opcode: ref v700,
                                                            args: ref v701,
                                                        } => {
                                                            if let &Opcode::Iadd = v700 {
                                                                let v685 = C::unpack_value_array_2(ctx, v684);
                                                                let v702 = C::unpack_value_array_2(ctx, v701);
                                                                if v685.0 == v702.0 {
                                                                    let v1044 = constructor_ne(ctx, v2.0, v685.1, v702.1);
                                                                    let v1045 = C::subsume(ctx, v1044);
                                                                    // Rule at src/opts/icmp.isle line 34.
                                                                    returns.extend(Some(v1045));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                if v685.0 == v702.1 {
                                                                    let v1042 = constructor_ne(ctx, v2.0, v685.1, v702.0);
                                                                    let v1043 = C::subsume(ctx, v1042);
                                                                    // Rule at src/opts/icmp.isle line 32.
                                                                    returns.extend(Some(v1043));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                if v685.1 == v702.0 {
                                                                    let v1040 = constructor_ne(ctx, v2.0, v685.0, v702.1);
                                                                    let v1041 = C::subsume(ctx, v1040);
                                                                    // Rule at src/opts/icmp.isle line 30.
                                                                    returns.extend(Some(v1041));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                if v685.1 == v702.1 {
                                                                    let v1038 = constructor_ne(ctx, v2.0, v685.0, v702.0);
                                                                    let v1039 = C::subsume(ctx, v1038);
                                                                    // Rule at src/opts/icmp.isle line 28.
                                                                    returns.extend(Some(v1039));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                                let mut v688 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                                let mut v688 = v688.into_context_iter();
                                                                while let Some(v689) = v688.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v692,
                                                                        imm: v693,
                                                                    } = &v689.1 {
                                                                        if let &Opcode::Iconst = v692 {
                                                                            let mut v705 = C::inst_data_value_etor_returns::default();
                                                                            C::inst_data_value_etor(ctx, v702.1, &mut v705);
                                                                            let mut v705 = v705.into_context_iter();
                                                                            while let Some(v706) = v705.next(ctx) {
                                                                                if let &InstructionData::UnaryImm {
                                                                                    opcode: ref v709,
                                                                                    imm: v710,
                                                                                } = &v706.1 {
                                                                                    if let &Opcode::Iconst = v709 {
                                                                                        let v711 = constructor_isub(ctx, v282.0, v702.1, v685.1);
                                                                                        let v712 = constructor_iadd(ctx, v629.0, v702.0, v711);
                                                                                        let v714 = constructor_ne(ctx, v2.0, v685.0, v712);
                                                                                        // Rule at src/opts/cprop.isle line 209.
                                                                                        returns.extend(Some(v714));
                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v285,
                                                            imm: v286,
                                                        } => {
                                                            if let &Opcode::Iconst = v285 {
                                                                let v685 = C::unpack_value_array_2(ctx, v684);
                                                                let mut v688 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                                let mut v688 = v688.into_context_iter();
                                                                while let Some(v689) = v688.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v692,
                                                                        imm: v693,
                                                                    } = &v689.1 {
                                                                        if let &Opcode::Iconst = v692 {
                                                                            let v694 = constructor_isub(ctx, v629.0, v278.1, v685.1);
                                                                            let v696 = constructor_ne(ctx, v2.0, v685.0, v694);
                                                                            // Rule at src/opts/cprop.isle line 199.
                                                                            returns.extend(Some(v696));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            &Opcode::Isub => {
                                                let v685 = C::unpack_value_array_2(ctx, v684);
                                                let mut v688 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                let mut v688 = v688.into_context_iter();
                                                while let Some(v689) = v688.next(ctx) {
                                                    match &v689.1 {
                                                        &InstructionData::IntCompare {
                                                            opcode: ref v1451,
                                                            args: ref v1452,
                                                            cond: ref v1453,
                                                        } => {
                                                            if let &Opcode::Icmp = v1451 {
                                                                match v1453 {
                                                                    &IntCC::SignedLessThan => {
                                                                        if v629.0 == I8 {
                                                                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                                                                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                                                                            let mut v985 = v985.into_context_iter();
                                                                            while let Some(v986) = v985.next(ctx) {
                                                                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                                                                if let Some(v988) = v987 {
                                                                                    match v988.1 {
                                                                                        -1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1465 = constructor_sge(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 182.
                                                                                                                        returns.extend(Some(v1465));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        0_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1458 = constructor_ne(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 150.
                                                                                                                        returns.extend(Some(v1458));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1461 = constructor_sle(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 190.
                                                                                                                        returns.extend(Some(v1461));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::UnsignedLessThan => {
                                                                        if v629.0 == I8 {
                                                                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                                                                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                                                                            let mut v985 = v985.into_context_iter();
                                                                            while let Some(v986) = v985.next(ctx) {
                                                                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                                                                if let Some(v988) = v987 {
                                                                                    match v988.1 {
                                                                                        -1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1466 = constructor_uge(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 184.
                                                                                                                        returns.extend(Some(v1466));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        0_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1458 = constructor_ne(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 152.
                                                                                                                        returns.extend(Some(v1458));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        1_i64 => {
                                                                                            let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                            let mut v1441 = v1441.into_context_iter();
                                                                                            while let Some(v1442) = v1441.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1445,
                                                                                                    args: ref v1446,
                                                                                                    cond: ref v1447,
                                                                                                } = &v1442.1 {
                                                                                                    if let &Opcode::Icmp = v1445 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                            if v689.0 == v1442.0 {
                                                                                                                let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                                let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                                if v1448.0 == v1454.0 {
                                                                                                                    if v1448.1 == v1454.1 {
                                                                                                                        let v1462 = constructor_ule(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                                        // Rule at src/opts/spaceship.isle line 192.
                                                                                                                        returns.extend(Some(v1462));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v692,
                                                            imm: v693,
                                                        } => {
                                                            if let &Opcode::Iconst = v692 {
                                                                let mut v281 = C::inst_data_value_etor_returns::default();
                                                                C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                                                let mut v281 = v281.into_context_iter();
                                                                while let Some(v282) = v281.next(ctx) {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v285,
                                                                        imm: v286,
                                                                    } = &v282.1 {
                                                                        if let &Opcode::Iconst = v285 {
                                                                            let v697 = constructor_iadd(ctx, v629.0, v278.1, v685.1);
                                                                            let v699 = constructor_ne(ctx, v2.0, v685.0, v697);
                                                                            // Rule at src/opts/cprop.isle line 204.
                                                                            returns.extend(Some(v699));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                let mut v281 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                                let mut v281 = v281.into_context_iter();
                                                while let Some(v282) = v281.next(ctx) {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v700,
                                                        args: ref v701,
                                                    } = &v282.1 {
                                                        if let &Opcode::Isub = v700 {
                                                            let v702 = C::unpack_value_array_2(ctx, v701);
                                                            let v1046 = constructor_iadd(ctx, v629.0, v685.0, v702.1);
                                                            let v1047 = constructor_iadd(ctx, v282.0, v702.0, v685.1);
                                                            let v1049 = constructor_ne(ctx, v2.0, v1046, v1047);
                                                            // Rule at src/opts/icmp.isle line 42.
                                                            returns.extend(Some(v1049));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    &InstructionData::Ternary {
                                        opcode: ref v1176,
                                        args: ref v1177,
                                    } => {
                                        if let &Opcode::Select = v1176 {
                                            let v1178 = C::unpack_value_array_3(ctx, v1177);
                                            if v278.1 == v1178.1 {
                                                let mut v1182 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v1178.0, &mut v1182);
                                                let mut v1182 = v1182.into_context_iter();
                                                while let Some(v1183) = v1182.next(ctx) {
                                                    if let &InstructionData::IntCompare {
                                                        opcode: ref v1186,
                                                        args: ref v1187,
                                                        cond: ref v1188,
                                                    } = &v1183.1 {
                                                        if let &Opcode::Icmp = v1186 {
                                                            match v1188 {
                                                                &IntCC::SignedLessThan => {
                                                                    if v2.0 == v1183.0 {
                                                                        let v1189 = C::unpack_value_array_2(ctx, v1187);
                                                                        if v278.1 == v1189.0 {
                                                                            if v1178.2 == v1189.1 {
                                                                                let v1192 = constructor_sgt(ctx, v2.0, v1189.0, v1189.1);
                                                                                // Rule at src/opts/icmp.isle line 298.
                                                                                returns.extend(Some(v1192));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                &IntCC::UnsignedLessThan => {
                                                                    if v2.0 == v1183.0 {
                                                                        let v1189 = C::unpack_value_array_2(ctx, v1187);
                                                                        if v278.1 == v1189.0 {
                                                                            if v1178.2 == v1189.1 {
                                                                                let v1193 = constructor_ugt(ctx, v2.0, v1189.0, v1189.1);
                                                                                // Rule at src/opts/icmp.isle line 299.
                                                                                returns.extend(Some(v1193));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                _ => {}
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &InstructionData::Unary {
                                        opcode: ref v977,
                                        arg: v978,
                                    } => {
                                        if let &Opcode::Sextend = v977 {
                                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                                            let mut v985 = v985.into_context_iter();
                                            while let Some(v986) = v985.next(ctx) {
                                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                                if let Some(v988) = v987 {
                                                    if v988.1 == 0_i64 {
                                                        let v979 = C::value_type(ctx, v978);
                                                        let v992 = constructor_iconst_s(ctx, v979, 0_i64);
                                                        let v994 = constructor_ne(ctx, v979, v978, v992);
                                                        // Rule at src/opts/extends.isle line 41.
                                                        returns.extend(Some(v994));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            let mut v281 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.1, &mut v281);
                            let mut v281 = v281.into_context_iter();
                            while let Some(v282) = v281.next(ctx) {
                                match &v282.1 {
                                    &InstructionData::Binary {
                                        opcode: ref v700,
                                        args: ref v701,
                                    } => {
                                        if let &Opcode::Bxor = v700 {
                                            let v1167 = C::ty_int(ctx, v282.0);
                                            if let Some(v1168) = v1167 {
                                                let v702 = C::unpack_value_array_2(ctx, v701);
                                                if v278.0 == v702.0 {
                                                    let v1169 = constructor_iconst_u(ctx, v1168, 0x0_u64);
                                                    let v1172 = constructor_ne(ctx, v2.0, v702.1, v1169);
                                                    let v1173 = C::subsume(ctx, v1172);
                                                    // Rule at src/opts/icmp.isle line 291.
                                                    returns.extend(Some(v1173));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                    &InstructionData::UnaryImm {
                                        opcode: ref v285,
                                        imm: v286,
                                    } => {
                                        if let &Opcode::Iconst = v285 {
                                            let v287 = C::u64_from_imm64(ctx, v286);
                                            match v287 {
                                                0x0_u64 => {
                                                    let mut v288 = ContextIterWrapper::<ConstructorVec<_>, _>::default();
                                                    constructor_truthy(ctx, v278.0, &mut v288);
                                                    let mut v288 = v288.into_context_iter();
                                                    while let Some(v289) = v288.next(ctx) {
                                                        let v290 = C::value_type(ctx, v289);
                                                        let v291 = C::ty_int_ref_scalar_64_extract(ctx, v290);
                                                        if let Some(v292) = v291 {
                                                            let v293 = constructor_iconst_u(ctx, v292, 0x0_u64);
                                                            let v294 = constructor_ne(ctx, v2.0, v289, v293);
                                                            // Rule at src/opts/bitops.isle line 122.
                                                            returns.extend(Some(v294));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                    let mut v1050 = C::uextend_maybe_etor_returns::default();
                                                    C::uextend_maybe_etor(ctx, v278.0, &mut v1050);
                                                    let mut v1050 = v1050.into_context_iter();
                                                    while let Some(v1051) = v1050.next(ctx) {
                                                        let mut v1054 = C::inst_data_value_etor_returns::default();
                                                        C::inst_data_value_etor(ctx, v1051.1, &mut v1054);
                                                        let mut v1054 = v1054.into_context_iter();
                                                        while let Some(v1055) = v1054.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v1058,
                                                                args: ref v1059,
                                                                cond: ref v1060,
                                                            } = &v1055.1 {
                                                                if let &Opcode::Icmp = v1058 {
                                                                    if v2.0 == v1055.0 {
                                                                        let v1064 = C::subsume(ctx, v1051.1);
                                                                        // Rule at src/opts/icmp.isle line 48.
                                                                        returns.extend(Some(v1064));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0x1_u64 => {
                                                    let mut v1050 = C::uextend_maybe_etor_returns::default();
                                                    C::uextend_maybe_etor(ctx, v278.0, &mut v1050);
                                                    let mut v1050 = v1050.into_context_iter();
                                                    while let Some(v1051) = v1050.next(ctx) {
                                                        let mut v1054 = C::inst_data_value_etor_returns::default();
                                                        C::inst_data_value_etor(ctx, v1051.1, &mut v1054);
                                                        let mut v1054 = v1054.into_context_iter();
                                                        while let Some(v1055) = v1054.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v1058,
                                                                args: ref v1059,
                                                                cond: ref v1060,
                                                            } = &v1055.1 {
                                                                if let &Opcode::Icmp = v1058 {
                                                                    if v2.0 == v1055.0 {
                                                                        let v1065 = &C::intcc_complement(ctx, v1060);
                                                                        let v1061 = C::unpack_value_array_2(ctx, v1059);
                                                                        let v1066 = constructor_icmp(ctx, v2.0, v1065, v1061.0, v1061.1);
                                                                        let v1067 = C::subsume(ctx, v1066);
                                                                        // Rule at src/opts/icmp.isle line 62.
                                                                        returns.extend(Some(v1067));
                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            if v278.0 == v278.1 {
                                let v52 = C::ty_int(ctx, v2.0);
                                if let Some(v53) = v52 {
                                    let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                    let v56 = C::subsume(ctx, v55);
                                    // Rule at src/opts/icmp.isle line 5.
                                    returns.extend(Some(v56));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                            let mut v985 = v985.into_context_iter();
                            while let Some(v986) = v985.next(ctx) {
                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                if let Some(v988) = v987 {
                                    match v988.1 {
                                        -1_i64 => {
                                            let v1126 = constructor_iconst_s(ctx, v988.0, 0_i64);
                                            let v1129 = constructor_sge(ctx, v2.0, v278.0, v1126);
                                            // Rule at src/opts/icmp.isle line 197.
                                            returns.extend(Some(v1129));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        0_i64 => {
                                            let mut v628 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                            let mut v628 = v628.into_context_iter();
                                            while let Some(v629) = v628.next(ctx) {
                                                if v629.0 == I8 {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v683,
                                                        args: ref v684,
                                                    } = &v629.1 {
                                                        if let &Opcode::Isub = v683 {
                                                            let v685 = C::unpack_value_array_2(ctx, v684);
                                                            let mut v688 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                            let mut v688 = v688.into_context_iter();
                                                            while let Some(v689) = v688.next(ctx) {
                                                                if let &InstructionData::IntCompare {
                                                                    opcode: ref v1451,
                                                                    args: ref v1452,
                                                                    cond: ref v1453,
                                                                } = &v689.1 {
                                                                    if let &Opcode::Icmp = v1451 {
                                                                        match v1453 {
                                                                            &IntCC::SignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1463 = constructor_sgt(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 166.
                                                                                                            returns.extend(Some(v1463));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            &IntCC::UnsignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1464 = constructor_ugt(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 168.
                                                                                                            returns.extend(Some(v1464));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            let v565 = C::fits_in_64(ctx, v2.0);
                            if let Some(v566) = v565 {
                                let v1095 = C::ty_int(ctx, v566);
                                if let Some(v1096) = v1095 {
                                    let mut v281 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                    let mut v281 = v281.into_context_iter();
                                    while let Some(v282) = v281.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v285,
                                            imm: v286,
                                        } = &v282.1 {
                                            if let &Opcode::Iconst = v285 {
                                                let v287 = C::u64_from_imm64(ctx, v286);
                                                let v1105 = C::ty_smin(ctx, v282.0);
                                                let v1106 = C::u64_eq(ctx, v287, v1105);
                                                if v1106 == true {
                                                    let v1100 = constructor_ne(ctx, v1096, v278.0, v278.1);
                                                    // Rule at src/opts/icmp.isle line 145.
                                                    returns.extend(Some(v1100));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1107 = C::ty_smax(ctx, v282.0);
                                                let v1108 = C::u64_eq(ctx, v287, v1107);
                                                if v1108 == true {
                                                    let v1097 = constructor_iconst_u(ctx, v1096, 0x0_u64);
                                                    let v1098 = C::subsume(ctx, v1097);
                                                    // Rule at src/opts/icmp.isle line 165.
                                                    returns.extend(Some(v1098));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                if v278.0 == v278.1 {
                                    let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                    let v56 = C::subsume(ctx, v55);
                                    // Rule at src/opts/icmp.isle line 8.
                                    returns.extend(Some(v56));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v281 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.1, &mut v281);
                            let mut v281 = v281.into_context_iter();
                            while let Some(v282) = v281.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v285,
                                    imm: v286,
                                } = &v282.1 {
                                    if let &Opcode::Iconst = v285 {
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            let v1095 = C::ty_int(ctx, v566);
                                            if let Some(v1096) = v1095 {
                                                let v287 = C::u64_from_imm64(ctx, v286);
                                                let v1105 = C::ty_smin(ctx, v282.0);
                                                let v1106 = C::u64_eq(ctx, v287, v1105);
                                                if v1106 == true {
                                                    let v1101 = constructor_iconst_u(ctx, v1096, 0x1_u64);
                                                    let v1102 = C::subsume(ctx, v1101);
                                                    // Rule at src/opts/icmp.isle line 150.
                                                    returns.extend(Some(v1102));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1107 = C::ty_smax(ctx, v282.0);
                                                let v1108 = C::u64_eq(ctx, v287, v1107);
                                                if v1108 == true {
                                                    let v1099 = constructor_eq(ctx, v1096, v278.0, v278.1);
                                                    // Rule at src/opts/icmp.isle line 170.
                                                    returns.extend(Some(v1099));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        let v287 = C::u64_from_imm64(ctx, v286);
                                        if v287 == 0x0_u64 {
                                            let mut v628 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                            let mut v628 = v628.into_context_iter();
                                            while let Some(v629) = v628.next(ctx) {
                                                if v629.0 == I64 {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v977,
                                                        arg: v978,
                                                    } = &v629.1 {
                                                        if let &Opcode::Uextend = v977 {
                                                            let v979 = C::value_type(ctx, v978);
                                                            if v979 == I32 {
                                                                let v983 = constructor_iconst_u(ctx, v2.0, 0x1_u64);
                                                                let v984 = C::subsume(ctx, v983);
                                                                // Rule at src/opts/extends.isle line 32.
                                                                returns.extend(Some(v984));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                            let mut v985 = v985.into_context_iter();
                            while let Some(v986) = v985.next(ctx) {
                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                if let Some(v988) = v987 {
                                    match v988.1 {
                                        0_i64 => {
                                            let mut v628 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                            let mut v628 = v628.into_context_iter();
                                            while let Some(v629) = v628.next(ctx) {
                                                if v629.0 == I8 {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v683,
                                                        args: ref v684,
                                                    } = &v629.1 {
                                                        if let &Opcode::Isub = v683 {
                                                            let v685 = C::unpack_value_array_2(ctx, v684);
                                                            let mut v688 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                            let mut v688 = v688.into_context_iter();
                                                            while let Some(v689) = v688.next(ctx) {
                                                                if let &InstructionData::IntCompare {
                                                                    opcode: ref v1451,
                                                                    args: ref v1452,
                                                                    cond: ref v1453,
                                                                } = &v689.1 {
                                                                    if let &Opcode::Icmp = v1451 {
                                                                        match v1453 {
                                                                            &IntCC::SignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1465 = constructor_sge(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 171.
                                                                                                            returns.extend(Some(v1465));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            &IntCC::UnsignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1466 = constructor_uge(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 173.
                                                                                                            returns.extend(Some(v1466));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        1_i64 => {
                                            let v1126 = constructor_iconst_s(ctx, v988.0, 0_i64);
                                            let v1127 = constructor_sgt(ctx, v2.0, v278.0, v1126);
                                            // Rule at src/opts/icmp.isle line 191.
                                            returns.extend(Some(v1127));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                if v278.0 == v278.1 {
                                    let v1028 = constructor_iconst_u(ctx, v53, 0x1_u64);
                                    let v1029 = C::subsume(ctx, v1028);
                                    // Rule at src/opts/icmp.isle line 9.
                                    returns.extend(Some(v1029));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v281 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.1, &mut v281);
                            let mut v281 = v281.into_context_iter();
                            while let Some(v282) = v281.next(ctx) {
                                match &v282.1 {
                                    &InstructionData::Unary {
                                        opcode: ref v1194,
                                        arg: v1195,
                                    } => {
                                        if let &Opcode::Bnot = v1194 {
                                            let mut v628 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                            let mut v628 = v628.into_context_iter();
                                            while let Some(v629) = v628.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v977,
                                                    arg: v978,
                                                } = &v629.1 {
                                                    if let &Opcode::Bnot = v977 {
                                                        if v282.0 == v629.0 {
                                                            let v1197 = constructor_sgt(ctx, v2.0, v978, v1195);
                                                            // Rule at src/opts/icmp.isle line 302.
                                                            returns.extend(Some(v1197));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &InstructionData::UnaryImm {
                                        opcode: ref v285,
                                        imm: v286,
                                    } => {
                                        if let &Opcode::Iconst = v285 {
                                            let v565 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v566) = v565 {
                                                let v1095 = C::ty_int(ctx, v566);
                                                if let Some(v1096) = v1095 {
                                                    let v287 = C::u64_from_imm64(ctx, v286);
                                                    let v1105 = C::ty_smin(ctx, v282.0);
                                                    let v1106 = C::u64_eq(ctx, v287, v1105);
                                                    if v1106 == true {
                                                        let v1097 = constructor_iconst_u(ctx, v1096, 0x0_u64);
                                                        let v1098 = C::subsume(ctx, v1097);
                                                        // Rule at src/opts/icmp.isle line 135.
                                                        returns.extend(Some(v1098));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                    let v1107 = C::ty_smax(ctx, v282.0);
                                                    let v1108 = C::u64_eq(ctx, v287, v1107);
                                                    if v1108 == true {
                                                        let v1100 = constructor_ne(ctx, v1096, v278.0, v278.1);
                                                        // Rule at src/opts/icmp.isle line 155.
                                                        returns.extend(Some(v1100));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            let v287 = C::u64_from_imm64(ctx, v286);
                                            if v287 == 0x0_u64 {
                                                let mut v628 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                                let mut v628 = v628.into_context_iter();
                                                while let Some(v629) = v628.next(ctx) {
                                                    if v629.0 == I64 {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v977,
                                                            arg: v978,
                                                        } = &v629.1 {
                                                            if let &Opcode::Uextend = v977 {
                                                                let v979 = C::value_type(ctx, v978);
                                                                if v979 == I32 {
                                                                    let v980 = constructor_iconst_u(ctx, v2.0, 0x0_u64);
                                                                    let v981 = C::subsume(ctx, v980);
                                                                    // Rule at src/opts/extends.isle line 27.
                                                                    returns.extend(Some(v981));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                            let mut v985 = v985.into_context_iter();
                            while let Some(v986) = v985.next(ctx) {
                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                if let Some(v988) = v987 {
                                    match v988.1 {
                                        0_i64 => {
                                            let mut v628 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                            let mut v628 = v628.into_context_iter();
                                            while let Some(v629) = v628.next(ctx) {
                                                if v629.0 == I8 {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v683,
                                                        args: ref v684,
                                                    } = &v629.1 {
                                                        if let &Opcode::Isub = v683 {
                                                            let v685 = C::unpack_value_array_2(ctx, v684);
                                                            let mut v688 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                            let mut v688 = v688.into_context_iter();
                                                            while let Some(v689) = v688.next(ctx) {
                                                                if let &InstructionData::IntCompare {
                                                                    opcode: ref v1451,
                                                                    args: ref v1452,
                                                                    cond: ref v1453,
                                                                } = &v689.1 {
                                                                    if let &Opcode::Icmp = v1451 {
                                                                        match v1453 {
                                                                            &IntCC::SignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1459 = constructor_slt(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 156.
                                                                                                            returns.extend(Some(v1459));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            &IntCC::UnsignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1460 = constructor_ult(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 158.
                                                                                                            returns.extend(Some(v1460));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        1_i64 => {
                                            let v1126 = constructor_iconst_s(ctx, v988.0, 0_i64);
                                            let v1128 = constructor_sle(ctx, v2.0, v278.0, v1126);
                                            // Rule at src/opts/icmp.isle line 194.
                                            returns.extend(Some(v1128));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                if v278.0 == v278.1 {
                                    let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                    let v56 = C::subsume(ctx, v55);
                                    // Rule at src/opts/icmp.isle line 12.
                                    returns.extend(Some(v56));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                            C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                            let mut v985 = v985.into_context_iter();
                            while let Some(v986) = v985.next(ctx) {
                                let v987 = C::iconst_sextend_etor(ctx, v986);
                                if let Some(v988) = v987 {
                                    match v988.1 {
                                        -1_i64 => {
                                            let v1126 = constructor_iconst_s(ctx, v988.0, 0_i64);
                                            let v1130 = constructor_slt(ctx, v2.0, v278.0, v1126);
                                            // Rule at src/opts/icmp.isle line 200.
                                            returns.extend(Some(v1130));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        0_i64 => {
                                            let mut v628 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                            let mut v628 = v628.into_context_iter();
                                            while let Some(v629) = v628.next(ctx) {
                                                if v629.0 == I8 {
                                                    if let &InstructionData::Binary {
                                                        opcode: ref v683,
                                                        args: ref v684,
                                                    } = &v629.1 {
                                                        if let &Opcode::Isub = v683 {
                                                            let v685 = C::unpack_value_array_2(ctx, v684);
                                                            let mut v688 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v685.1, &mut v688);
                                                            let mut v688 = v688.into_context_iter();
                                                            while let Some(v689) = v688.next(ctx) {
                                                                if let &InstructionData::IntCompare {
                                                                    opcode: ref v1451,
                                                                    args: ref v1452,
                                                                    cond: ref v1453,
                                                                } = &v689.1 {
                                                                    if let &Opcode::Icmp = v1451 {
                                                                        match v1453 {
                                                                            &IntCC::SignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::SignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1461 = constructor_sle(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 161.
                                                                                                            returns.extend(Some(v1461));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            &IntCC::UnsignedLessThan => {
                                                                                let mut v1441 = C::inst_data_value_etor_returns::default();
                                                                                C::inst_data_value_etor(ctx, v685.0, &mut v1441);
                                                                                let mut v1441 = v1441.into_context_iter();
                                                                                while let Some(v1442) = v1441.next(ctx) {
                                                                                    if let &InstructionData::IntCompare {
                                                                                        opcode: ref v1445,
                                                                                        args: ref v1446,
                                                                                        cond: ref v1447,
                                                                                    } = &v1442.1 {
                                                                                        if let &Opcode::Icmp = v1445 {
                                                                                            if let &IntCC::UnsignedGreaterThan = v1447 {
                                                                                                if v689.0 == v1442.0 {
                                                                                                    let v1448 = C::unpack_value_array_2(ctx, v1446);
                                                                                                    let v1454 = C::unpack_value_array_2(ctx, v1452);
                                                                                                    if v1448.0 == v1454.0 {
                                                                                                        if v1448.1 == v1454.1 {
                                                                                                            let v1462 = constructor_ule(ctx, v1442.0, v1448.0, v1448.1);
                                                                                                            // Rule at src/opts/spaceship.isle line 163.
                                                                                                            returns.extend(Some(v1462));
                                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            let v565 = C::fits_in_64(ctx, v2.0);
                            if let Some(v566) = v565 {
                                let v1095 = C::ty_int(ctx, v566);
                                if let Some(v1096) = v1095 {
                                    let mut v281 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                    let mut v281 = v281.into_context_iter();
                                    while let Some(v282) = v281.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v285,
                                            imm: v286,
                                        } = &v282.1 {
                                            if let &Opcode::Iconst = v285 {
                                                let v287 = C::u64_from_imm64(ctx, v286);
                                                let v1105 = C::ty_smin(ctx, v282.0);
                                                let v1106 = C::u64_eq(ctx, v287, v1105);
                                                if v1106 == true {
                                                    let v1099 = constructor_eq(ctx, v1096, v278.0, v278.1);
                                                    // Rule at src/opts/icmp.isle line 140.
                                                    returns.extend(Some(v1099));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1107 = C::ty_smax(ctx, v282.0);
                                                let v1108 = C::u64_eq(ctx, v287, v1107);
                                                if v1108 == true {
                                                    let v1101 = constructor_iconst_u(ctx, v1096, 0x1_u64);
                                                    let v1102 = C::subsume(ctx, v1101);
                                                    // Rule at src/opts/icmp.isle line 160.
                                                    returns.extend(Some(v1102));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                if v278.0 == v278.1 {
                                    let v1028 = constructor_iconst_u(ctx, v53, 0x1_u64);
                                    let v1029 = C::subsume(ctx, v1028);
                                    // Rule at src/opts/icmp.isle line 13.
                                    returns.extend(Some(v1029));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v565 = C::fits_in_64(ctx, v2.0);
                            if let Some(v566) = v565 {
                                let v1095 = C::ty_int(ctx, v566);
                                if let Some(v1096) = v1095 {
                                    let v278 = C::unpack_value_array_2(ctx, v276);
                                    let mut v281 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                    let mut v281 = v281.into_context_iter();
                                    while let Some(v282) = v281.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v285,
                                            imm: v286,
                                        } = &v282.1 {
                                            if let &Opcode::Iconst = v285 {
                                                let v287 = C::u64_from_imm64(ctx, v286);
                                                if v287 == 0x0_u64 {
                                                    let v1100 = constructor_ne(ctx, v1096, v278.0, v278.1);
                                                    // Rule at src/opts/icmp.isle line 107.
                                                    returns.extend(Some(v1100));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1103 = C::ty_umax(ctx, v282.0);
                                                let v1104 = C::u64_eq(ctx, v287, v1103);
                                                if v1104 == true {
                                                    let v1097 = constructor_iconst_u(ctx, v1096, 0x0_u64);
                                                    let v1098 = C::subsume(ctx, v1097);
                                                    // Rule at src/opts/icmp.isle line 125.
                                                    returns.extend(Some(v1098));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                let v278 = C::unpack_value_array_2(ctx, v276);
                                if v278.0 == v278.1 {
                                    let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                    let v56 = C::subsume(ctx, v55);
                                    // Rule at src/opts/icmp.isle line 6.
                                    returns.extend(Some(v56));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v628 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                            let mut v628 = v628.into_context_iter();
                            while let Some(v629) = v628.next(ctx) {
                                if let &InstructionData::Binary {
                                    opcode: ref v683,
                                    args: ref v684,
                                } = &v629.1 {
                                    if let &Opcode::Isub = v683 {
                                        let v685 = C::unpack_value_array_2(ctx, v684);
                                        if v278.1 == v685.0 {
                                            let v1174 = constructor_ugt(ctx, v2.0, v685.1, v685.0);
                                            // Rule at src/opts/icmp.isle line 294.
                                            returns.extend(Some(v1174));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v281 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.1, &mut v281);
                            let mut v281 = v281.into_context_iter();
                            while let Some(v282) = v281.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v285,
                                    imm: v286,
                                } = &v282.1 {
                                    if let &Opcode::Iconst = v285 {
                                        let v287 = C::u64_from_imm64(ctx, v286);
                                        match v287 {
                                            0x0_u64 => {
                                                let v565 = C::fits_in_64(ctx, v2.0);
                                                if let Some(v566) = v565 {
                                                    let v1095 = C::ty_int(ctx, v566);
                                                    if let Some(v1096) = v1095 {
                                                        let v1101 = constructor_iconst_u(ctx, v1096, 0x1_u64);
                                                        let v1102 = C::subsume(ctx, v1101);
                                                        // Rule at src/opts/icmp.isle line 111.
                                                        returns.extend(Some(v1102));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            0x1_u64 => {
                                                let v1123 = constructor_iconst_u(ctx, v282.0, 0x0_u64);
                                                let v1124 = constructor_ne(ctx, v2.0, v278.0, v1123);
                                                // Rule at src/opts/icmp.isle line 185.
                                                returns.extend(Some(v1124));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            _ => {}
                                        }
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            let v1095 = C::ty_int(ctx, v566);
                                            if let Some(v1096) = v1095 {
                                                let v1103 = C::ty_umax(ctx, v282.0);
                                                let v1104 = C::u64_eq(ctx, v287, v1103);
                                                if v1104 == true {
                                                    let v1099 = constructor_eq(ctx, v1096, v278.0, v278.1);
                                                    // Rule at src/opts/icmp.isle line 130.
                                                    returns.extend(Some(v1099));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                if v278.0 == v278.1 {
                                    let v1028 = constructor_iconst_u(ctx, v53, 0x1_u64);
                                    let v1029 = C::subsume(ctx, v1028);
                                    // Rule at src/opts/icmp.isle line 7.
                                    returns.extend(Some(v1029));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v281 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.1, &mut v281);
                            let mut v281 = v281.into_context_iter();
                            while let Some(v282) = v281.next(ctx) {
                                match &v282.1 {
                                    &InstructionData::Unary {
                                        opcode: ref v1194,
                                        arg: v1195,
                                    } => {
                                        if let &Opcode::Bnot = v1194 {
                                            let mut v628 = C::inst_data_value_etor_returns::default();
                                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                                            let mut v628 = v628.into_context_iter();
                                            while let Some(v629) = v628.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v977,
                                                    arg: v978,
                                                } = &v629.1 {
                                                    if let &Opcode::Bnot = v977 {
                                                        if v282.0 == v629.0 {
                                                            let v1196 = constructor_ugt(ctx, v2.0, v978, v1195);
                                                            // Rule at src/opts/icmp.isle line 301.
                                                            returns.extend(Some(v1196));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &InstructionData::UnaryImm {
                                        opcode: ref v285,
                                        imm: v286,
                                    } => {
                                        if let &Opcode::Iconst = v285 {
                                            let v287 = C::u64_from_imm64(ctx, v286);
                                            match v287 {
                                                0x0_u64 => {
                                                    let v565 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v566) = v565 {
                                                        let v1095 = C::ty_int(ctx, v566);
                                                        if let Some(v1096) = v1095 {
                                                            let v1097 = constructor_iconst_u(ctx, v1096, 0x0_u64);
                                                            let v1098 = C::subsume(ctx, v1097);
                                                            // Rule at src/opts/icmp.isle line 99.
                                                            returns.extend(Some(v1098));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                                0x1_u64 => {
                                                    let v1123 = constructor_iconst_u(ctx, v282.0, 0x0_u64);
                                                    let v1125 = constructor_eq(ctx, v2.0, v278.0, v1123);
                                                    // Rule at src/opts/icmp.isle line 188.
                                                    returns.extend(Some(v1125));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                _ => {}
                                            }
                                            let v565 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v566) = v565 {
                                                let v1095 = C::ty_int(ctx, v566);
                                                if let Some(v1096) = v1095 {
                                                    let v1103 = C::ty_umax(ctx, v282.0);
                                                    let v1104 = C::u64_eq(ctx, v287, v1103);
                                                    if v1104 == true {
                                                        let v1100 = constructor_ne(ctx, v1096, v278.0, v278.1);
                                                        // Rule at src/opts/icmp.isle line 115.
                                                        returns.extend(Some(v1100));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                if v278.0 == v278.1 {
                                    let v55 = constructor_iconst_u(ctx, v53, 0x0_u64);
                                    let v56 = C::subsume(ctx, v55);
                                    // Rule at src/opts/icmp.isle line 10.
                                    returns.extend(Some(v56));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v565 = C::fits_in_64(ctx, v2.0);
                            if let Some(v566) = v565 {
                                let v1095 = C::ty_int(ctx, v566);
                                if let Some(v1096) = v1095 {
                                    let v278 = C::unpack_value_array_2(ctx, v276);
                                    let mut v281 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                    let mut v281 = v281.into_context_iter();
                                    while let Some(v282) = v281.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v285,
                                            imm: v286,
                                        } = &v282.1 {
                                            if let &Opcode::Iconst = v285 {
                                                let v287 = C::u64_from_imm64(ctx, v286);
                                                if v287 == 0x0_u64 {
                                                    let v1099 = constructor_eq(ctx, v1096, v278.0, v278.1);
                                                    // Rule at src/opts/icmp.isle line 103.
                                                    returns.extend(Some(v1099));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1103 = C::ty_umax(ctx, v282.0);
                                                let v1104 = C::u64_eq(ctx, v287, v1103);
                                                if v1104 == true {
                                                    let v1101 = constructor_iconst_u(ctx, v1096, 0x1_u64);
                                                    let v1102 = C::subsume(ctx, v1101);
                                                    // Rule at src/opts/icmp.isle line 120.
                                                    returns.extend(Some(v1102));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            let v52 = C::ty_int(ctx, v2.0);
                            if let Some(v53) = v52 {
                                let v278 = C::unpack_value_array_2(ctx, v276);
                                if v278.0 == v278.1 {
                                    let v1028 = constructor_iconst_u(ctx, v53, 0x1_u64);
                                    let v1029 = C::subsume(ctx, v1028);
                                    // Rule at src/opts/icmp.isle line 11.
                                    returns.extend(Some(v1029));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                            let v278 = C::unpack_value_array_2(ctx, v276);
                            let mut v628 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v278.0, &mut v628);
                            let mut v628 = v628.into_context_iter();
                            while let Some(v629) = v628.next(ctx) {
                                if let &InstructionData::Binary {
                                    opcode: ref v683,
                                    args: ref v684,
                                } = &v629.1 {
                                    if let &Opcode::Isub = v683 {
                                        let v685 = C::unpack_value_array_2(ctx, v684);
                                        if v278.1 == v685.0 {
                                            let v1175 = constructor_ule(ctx, v2.0, v685.1, v685.0);
                                            // Rule at src/opts/icmp.isle line 295.
                                            returns.extend(Some(v1175));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    let v278 = C::unpack_value_array_2(ctx, v276);
                    let mut v628 = C::inst_data_value_etor_returns::default();
                    C::inst_data_value_etor(ctx, v278.0, &mut v628);
                    let mut v628 = v628.into_context_iter();
                    while let Some(v629) = v628.next(ctx) {
                        match &v629.1 {
                            &InstructionData::Unary {
                                opcode: ref v977,
                                arg: v978,
                            } => {
                                if let &Opcode::Sextend = v977 {
                                    let v995 = &C::signed_cond_code(ctx, v277);
                                    if let Some(v996) = v995 {
                                        let mut v985 = C::inst_data_value_tupled_etor_returns::default();
                                        C::inst_data_value_tupled_etor(ctx, v278.1, &mut v985);
                                        let mut v985 = v985.into_context_iter();
                                        while let Some(v986) = v985.next(ctx) {
                                            let v987 = C::iconst_sextend_etor(ctx, v986);
                                            if let Some(v988) = v987 {
                                                if v988.1 == 0_i64 {
                                                    let v979 = C::value_type(ctx, v978);
                                                    let v992 = constructor_iconst_s(ctx, v979, 0_i64);
                                                    let v997 = constructor_icmp(ctx, v979, v277, v978, v992);
                                                    // Rule at src/opts/extends.isle line 43.
                                                    returns.extend(Some(v997));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &InstructionData::UnaryImm {
                                opcode: ref v632,
                                imm: v633,
                            } => {
                                if let &Opcode::Iconst = v632 {
                                    let mut v281 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v278.1, &mut v281);
                                    let mut v281 = v281.into_context_iter();
                                    while let Some(v282) = v281.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v285,
                                            imm: v286,
                                        } = &v282.1 {
                                            if let &Opcode::Iconst = v285 {
                                                if v282.0 == v629.0 {
                                                    let v634 = C::imm64_icmp(ctx, v629.0, v277, v633, v286);
                                                    let v635 = constructor_iconst(ctx, v2.0, v634);
                                                    let v636 = C::subsume(ctx, v635);
                                                    // Rule at src/opts/cprop.isle line 103.
                                                    returns.extend(Some(v636));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                    let v644 = &C::intcc_swap_args(ctx, v277);
                                    let v645 = constructor_icmp(ctx, v2.0, v644, v278.1, v278.0);
                                    // Rule at src/opts/cprop.isle line 137.
                                    returns.extend(Some(v645));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v84,
                args: ref v85,
            } => {
                match v84 {
                    &Opcode::Select => {
                        let v86 = C::unpack_value_array_3(ctx, v85);
                        let mut v90 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v86.0, &mut v90);
                        let mut v90 = v90.into_context_iter();
                        while let Some(v91) = v90.next(ctx) {
                            match &v91.1 {
                                &InstructionData::IntCompare {
                                    opcode: ref v1131,
                                    args: ref v1132,
                                    cond: ref v1133,
                                } => {
                                    if let &Opcode::Icmp = v1131 {
                                        match v1133 {
                                            &IntCC::Equal => {
                                                let mut v1147 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                let mut v1147 = v1147.into_context_iter();
                                                while let Some(v1148) = v1147.next(ctx) {
                                                    match &v1148.1 {
                                                        &InstructionData::IntCompare {
                                                            opcode: ref v1151,
                                                            args: ref v1152,
                                                            cond: ref v1153,
                                                        } => {
                                                            if let &Opcode::Icmp = v1151 {
                                                                match v1153 {
                                                                    &IntCC::SignedGreaterThan => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1162 = constructor_sgt(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 264.
                                                                                                                        returns.extend(Some(v1162));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::SignedGreaterThanOrEqual => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedGreaterThanOrEqual = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1160 = constructor_sge(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 254.
                                                                                                                        returns.extend(Some(v1160));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::SignedLessThan => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedLessThan = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1166 = constructor_slt(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 284.
                                                                                                                        returns.extend(Some(v1166));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::SignedLessThanOrEqual => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedLessThanOrEqual = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1164 = constructor_sle(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 274.
                                                                                                                        returns.extend(Some(v1164));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::UnsignedGreaterThan => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedGreaterThan = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1161 = constructor_ugt(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 259.
                                                                                                                        returns.extend(Some(v1161));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::UnsignedGreaterThanOrEqual => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedGreaterThanOrEqual = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1159 = constructor_uge(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 249.
                                                                                                                        returns.extend(Some(v1159));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::UnsignedLessThan => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedLessThan = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1165 = constructor_ult(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 279.
                                                                                                                        returns.extend(Some(v1165));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    &IntCC::UnsignedLessThanOrEqual => {
                                                                        let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                        let v1137 = C::value_type(ctx, v1134.0);
                                                                        if v1137 == I64 {
                                                                            let v1138 = C::value_type(ctx, v1134.1);
                                                                            if v1138 == I64 {
                                                                                if v2.0 == v1148.0 {
                                                                                    let v1154 = C::unpack_value_array_2(ctx, v1152);
                                                                                    if v1134.0 == v1154.0 {
                                                                                        if v1134.1 == v1154.1 {
                                                                                            let mut v96 = C::inst_data_value_etor_returns::default();
                                                                                            C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                                                            let mut v96 = v96.into_context_iter();
                                                                                            while let Some(v97) = v96.next(ctx) {
                                                                                                if let &InstructionData::IntCompare {
                                                                                                    opcode: ref v1139,
                                                                                                    args: ref v1140,
                                                                                                    cond: ref v1141,
                                                                                                } = &v97.1 {
                                                                                                    if let &Opcode::Icmp = v1139 {
                                                                                                        if let &IntCC::UnsignedLessThanOrEqual = v1141 {
                                                                                                            let v1142 = C::unpack_value_array_2(ctx, v1140);
                                                                                                            let v1145 = C::value_type(ctx, v1142.0);
                                                                                                            if v1145 == I64 {
                                                                                                                let v1146 = C::value_type(ctx, v1142.1);
                                                                                                                if v1146 == I64 {
                                                                                                                    if v2.0 == v97.0 {
                                                                                                                        let v1157 = constructor_iconcat(ctx, I64, v1142.0, v1134.0);
                                                                                                                        let v1158 = constructor_iconcat(ctx, I64, v1142.1, v1134.1);
                                                                                                                        let v1163 = constructor_ule(ctx, v2.0, v1157, v1158);
                                                                                                                        // Rule at src/opts/icmp.isle line 269.
                                                                                                                        returns.extend(Some(v1163));
                                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::Ternary {
                                                            opcode: ref v1289,
                                                            args: ref v1290,
                                                        } => {
                                                            if let &Opcode::Select = v1289 {
                                                                if v2.0 == v1148.0 {
                                                                    let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                                                    C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                                                    let mut v1217 = v1217.into_context_iter();
                                                                    while let Some(v1218) = v1217.next(ctx) {
                                                                        let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                                                        if let Some(v1220) = v1219 {
                                                                            if v1220.1 == 0_i64 {
                                                                                if v2.0 == v1220.0 {
                                                                                    let v1291 = C::unpack_value_array_3(ctx, v1290);
                                                                                    let mut v1407 = C::inst_data_value_etor_returns::default();
                                                                                    C::inst_data_value_etor(ctx, v1291.0, &mut v1407);
                                                                                    let mut v1407 = v1407.into_context_iter();
                                                                                    while let Some(v1408) = v1407.next(ctx) {
                                                                                        if let &InstructionData::IntCompare {
                                                                                            opcode: ref v1411,
                                                                                            args: ref v1412,
                                                                                            cond: ref v1413,
                                                                                        } = &v1408.1 {
                                                                                            if let &Opcode::Icmp = v1411 {
                                                                                                match v1413 {
                                                                                                    &IntCC::SignedGreaterThan => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == 1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == -1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 103.
                                                                                                                                                    returns.extend(Some(v1440));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::SignedGreaterThanOrEqual => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == 1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == -1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 110.
                                                                                                                                                    returns.extend(Some(v1440));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::SignedLessThan => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == -1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == 1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 89.
                                                                                                                                                    returns.extend(Some(v1440));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::SignedLessThanOrEqual => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == -1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == 1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 96.
                                                                                                                                                    returns.extend(Some(v1440));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::UnsignedGreaterThan => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == 1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == -1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 38.
                                                                                                                                                    returns.extend(Some(v1406));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::UnsignedGreaterThanOrEqual => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == 1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == -1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 45.
                                                                                                                                                    returns.extend(Some(v1406));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::UnsignedLessThan => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == -1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == 1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 24.
                                                                                                                                                    returns.extend(Some(v1406));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::UnsignedLessThanOrEqual => {
                                                                                                        if v91.0 == v1408.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1414 = C::unpack_value_array_2(ctx, v1412);
                                                                                                            if v1134.0 == v1414.0 {
                                                                                                                if v1134.1 == v1414.1 {
                                                                                                                    let mut v1417 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.1, &mut v1417);
                                                                                                                    let mut v1417 = v1417.into_context_iter();
                                                                                                                    while let Some(v1418) = v1417.next(ctx) {
                                                                                                                        let v1419 = C::iconst_sextend_etor(ctx, v1418);
                                                                                                                        if let Some(v1420) = v1419 {
                                                                                                                            if v1420.1 == -1_i64 {
                                                                                                                                if v2.0 == v1420.0 {
                                                                                                                                    let mut v1423 = C::inst_data_value_tupled_etor_returns::default();
                                                                                                                                    C::inst_data_value_tupled_etor(ctx, v1291.2, &mut v1423);
                                                                                                                                    let mut v1423 = v1423.into_context_iter();
                                                                                                                                    while let Some(v1424) = v1423.next(ctx) {
                                                                                                                                        let v1425 = C::iconst_sextend_etor(ctx, v1424);
                                                                                                                                        if let Some(v1426) = v1425 {
                                                                                                                                            if v1426.1 == 1_i64 {
                                                                                                                                                if v2.0 == v1426.0 {
                                                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                                                    // Rule at src/opts/spaceship.isle line 31.
                                                                                                                                                    returns.extend(Some(v1406));
                                                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {}
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThan => {
                                                let mut v1147 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                let mut v1147 = v1147.into_context_iter();
                                                while let Some(v1148) = v1147.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v1247,
                                                        arg: v1248,
                                                    } = &v1148.1 {
                                                        match v1247 {
                                                            &Opcode::Ineg => {
                                                                if v91.0 == v1148.0 {
                                                                    let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                                                    C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                                                    let mut v1217 = v1217.into_context_iter();
                                                                    while let Some(v1218) = v1217.next(ctx) {
                                                                        let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                                                        if let Some(v1220) = v1219 {
                                                                            if v1220.1 == 1_i64 {
                                                                                if v2.0 == v1220.0 {
                                                                                    let mut v1429 = C::inst_data_value_etor_returns::default();
                                                                                    C::inst_data_value_etor(ctx, v1248, &mut v1429);
                                                                                    let mut v1429 = v1429.into_context_iter();
                                                                                    while let Some(v1430) = v1429.next(ctx) {
                                                                                        if let &InstructionData::IntCompare {
                                                                                            opcode: ref v1433,
                                                                                            args: ref v1434,
                                                                                            cond: ref v1435,
                                                                                        } = &v1430.1 {
                                                                                            if let &Opcode::Icmp = v1433 {
                                                                                                match v1435 {
                                                                                                    &IntCC::NotEqual => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                    // Rule at src/opts/spaceship.isle line 129.
                                                                                                                    returns.extend(Some(v1440));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::SignedLessThan => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                    // Rule at src/opts/spaceship.isle line 119.
                                                                                                                    returns.extend(Some(v1440));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {}
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                if v2.0 == v1148.0 {
                                                                    let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                    if v86.1 == v1134.0 {
                                                                        if v86.1 == v1248 {
                                                                            let mut v1253 = C::inst_data_value_etor_returns::default();
                                                                            C::inst_data_value_etor(ctx, v1134.1, &mut v1253);
                                                                            let mut v1253 = v1253.into_context_iter();
                                                                            while let Some(v1254) = v1253.next(ctx) {
                                                                                if let &InstructionData::UnaryImm {
                                                                                    opcode: ref v1257,
                                                                                    imm: v1258,
                                                                                } = &v1254.1 {
                                                                                    if let &Opcode::Iconst = v1257 {
                                                                                        let v1259 = C::u64_from_imm64(ctx, v1258);
                                                                                        if v1259 == 0x0_u64 {
                                                                                            if v2.0 == v1254.0 {
                                                                                                let v1260 = constructor_iabs(ctx, v2.0, v1134.0);
                                                                                                let v1261 = C::subsume(ctx, v1260);
                                                                                                // Rule at src/opts/selects.isle line 89.
                                                                                                returns.extend(Some(v1261));
                                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            &Opcode::Bmask => {
                                                                if v2.0 == v1148.0 {
                                                                    let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                                                    C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                                                    let mut v1217 = v1217.into_context_iter();
                                                                    while let Some(v1218) = v1217.next(ctx) {
                                                                        let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                                                        if let Some(v1220) = v1219 {
                                                                            if v1220.1 == 1_i64 {
                                                                                if v2.0 == v1220.0 {
                                                                                    let mut v1429 = C::inst_data_value_etor_returns::default();
                                                                                    C::inst_data_value_etor(ctx, v1248, &mut v1429);
                                                                                    let mut v1429 = v1429.into_context_iter();
                                                                                    while let Some(v1430) = v1429.next(ctx) {
                                                                                        if let &InstructionData::IntCompare {
                                                                                            opcode: ref v1433,
                                                                                            args: ref v1434,
                                                                                            cond: ref v1435,
                                                                                        } = &v1430.1 {
                                                                                            if let &Opcode::Icmp = v1433 {
                                                                                                match v1435 {
                                                                                                    &IntCC::NotEqual => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                    // Rule at src/opts/spaceship.isle line 133.
                                                                                                                    returns.extend(Some(v1440));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::SignedLessThan => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                                    // Rule at src/opts/spaceship.isle line 123.
                                                                                                                    returns.extend(Some(v1440));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {}
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 25.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.2 == v1134.0 {
                                                    if v86.1 == v1134.1 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 39.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 26.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                    let mut v1147 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                    let mut v1147 = v1147.into_context_iter();
                                                    while let Some(v1148) = v1147.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v1247,
                                                            arg: v1248,
                                                        } = &v1148.1 {
                                                            if let &Opcode::Ineg = v1247 {
                                                                if v86.1 == v1248 {
                                                                    if v2.0 == v1148.0 {
                                                                        let mut v1253 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v1134.1, &mut v1253);
                                                                        let mut v1253 = v1253.into_context_iter();
                                                                        while let Some(v1254) = v1253.next(ctx) {
                                                                            if let &InstructionData::UnaryImm {
                                                                                opcode: ref v1257,
                                                                                imm: v1258,
                                                                            } = &v1254.1 {
                                                                                if let &Opcode::Iconst = v1257 {
                                                                                    let v1259 = C::u64_from_imm64(ctx, v1258);
                                                                                    if v1259 == 0x0_u64 {
                                                                                        if v2.0 == v1254.0 {
                                                                                            let v1260 = constructor_iabs(ctx, v2.0, v1134.0);
                                                                                            let v1261 = C::subsume(ctx, v1260);
                                                                                            // Rule at src/opts/selects.isle line 90.
                                                                                            returns.extend(Some(v1261));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 40.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.2 == v1134.0 {
                                                    if v86.1 == v1134.1 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 35.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                    let mut v96 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                    let mut v96 = v96.into_context_iter();
                                                    while let Some(v97) = v96.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v100,
                                                            arg: v101,
                                                        } = &v97.1 {
                                                            if let &Opcode::Ineg = v100 {
                                                                if v86.2 == v101 {
                                                                    if v2.0 == v97.0 {
                                                                        let mut v1253 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v1134.1, &mut v1253);
                                                                        let mut v1253 = v1253.into_context_iter();
                                                                        while let Some(v1254) = v1253.next(ctx) {
                                                                            if let &InstructionData::UnaryImm {
                                                                                opcode: ref v1257,
                                                                                imm: v1258,
                                                                            } = &v1254.1 {
                                                                                if let &Opcode::Iconst = v1257 {
                                                                                    let v1259 = C::u64_from_imm64(ctx, v1258);
                                                                                    if v1259 == 0x0_u64 {
                                                                                        if v2.0 == v1254.0 {
                                                                                            let v1260 = constructor_iabs(ctx, v2.0, v1134.0);
                                                                                            let v1261 = C::subsume(ctx, v1260);
                                                                                            // Rule at src/opts/selects.isle line 92.
                                                                                            returns.extend(Some(v1261));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                                C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                                let mut v1217 = v1217.into_context_iter();
                                                while let Some(v1218) = v1217.next(ctx) {
                                                    let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                                    if let Some(v1220) = v1219 {
                                                        if v1220.1 == -1_i64 {
                                                            if v2.0 == v1220.0 {
                                                                let mut v1391 = C::uextend_maybe_etor_returns::default();
                                                                C::uextend_maybe_etor(ctx, v86.2, &mut v1391);
                                                                let mut v1391 = v1391.into_context_iter();
                                                                while let Some(v1392) = v1391.next(ctx) {
                                                                    if v2.0 == v1392.0 {
                                                                        let mut v1395 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v1392.1, &mut v1395);
                                                                        let mut v1395 = v1395.into_context_iter();
                                                                        while let Some(v1396) = v1395.next(ctx) {
                                                                            if let &InstructionData::IntCompare {
                                                                                opcode: ref v1399,
                                                                                args: ref v1400,
                                                                                cond: ref v1401,
                                                                            } = &v1396.1 {
                                                                                if let &Opcode::Icmp = v1399 {
                                                                                    match v1401 {
                                                                                        &IntCC::NotEqual => {
                                                                                            if v91.0 == v1396.0 {
                                                                                                let v1402 = C::unpack_value_array_2(ctx, v1400);
                                                                                                if v1134.0 == v1402.0 {
                                                                                                    if v1134.1 == v1402.1 {
                                                                                                        let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                        let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                        // Rule at src/opts/spaceship.isle line 77.
                                                                                                        returns.extend(Some(v1440));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        &IntCC::SignedGreaterThan => {
                                                                                            if v91.0 == v1396.0 {
                                                                                                let v1402 = C::unpack_value_array_2(ctx, v1400);
                                                                                                if v1134.0 == v1402.0 {
                                                                                                    if v1134.1 == v1402.1 {
                                                                                                        let v1439 = constructor_spaceship_s(ctx, v91.0, v1134.0, v1134.1);
                                                                                                        let v1440 = constructor_sextend_maybe(ctx, v2.0, v1439);
                                                                                                        // Rule at src/opts/spaceship.isle line 83.
                                                                                                        returns.extend(Some(v1440));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 29.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.2 == v1134.0 {
                                                    if v86.1 == v1134.1 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 36.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                    let mut v96 = C::inst_data_value_etor_returns::default();
                                                    C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                                    let mut v96 = v96.into_context_iter();
                                                    while let Some(v97) = v96.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v100,
                                                            arg: v101,
                                                        } = &v97.1 {
                                                            if let &Opcode::Ineg = v100 {
                                                                if v86.2 == v101 {
                                                                    if v2.0 == v97.0 {
                                                                        let mut v1253 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v1134.1, &mut v1253);
                                                                        let mut v1253 = v1253.into_context_iter();
                                                                        while let Some(v1254) = v1253.next(ctx) {
                                                                            if let &InstructionData::UnaryImm {
                                                                                opcode: ref v1257,
                                                                                imm: v1258,
                                                                            } = &v1254.1 {
                                                                                if let &Opcode::Iconst = v1257 {
                                                                                    let v1259 = C::u64_from_imm64(ctx, v1258);
                                                                                    if v1259 == 0x0_u64 {
                                                                                        if v2.0 == v1254.0 {
                                                                                            let v1260 = constructor_iabs(ctx, v2.0, v1134.0);
                                                                                            let v1261 = C::subsume(ctx, v1260);
                                                                                            // Rule at src/opts/selects.isle line 91.
                                                                                            returns.extend(Some(v1261));
                                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 30.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let mut v1147 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                let mut v1147 = v1147.into_context_iter();
                                                while let Some(v1148) = v1147.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v1247,
                                                        arg: v1248,
                                                    } = &v1148.1 {
                                                        match v1247 {
                                                            &Opcode::Ineg => {
                                                                if v91.0 == v1148.0 {
                                                                    let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                                                    C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                                                    let mut v1217 = v1217.into_context_iter();
                                                                    while let Some(v1218) = v1217.next(ctx) {
                                                                        let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                                                        if let Some(v1220) = v1219 {
                                                                            if v1220.1 == 1_i64 {
                                                                                if v2.0 == v1220.0 {
                                                                                    let mut v1429 = C::inst_data_value_etor_returns::default();
                                                                                    C::inst_data_value_etor(ctx, v1248, &mut v1429);
                                                                                    let mut v1429 = v1429.into_context_iter();
                                                                                    while let Some(v1430) = v1429.next(ctx) {
                                                                                        if let &InstructionData::IntCompare {
                                                                                            opcode: ref v1433,
                                                                                            args: ref v1434,
                                                                                            cond: ref v1435,
                                                                                        } = &v1430.1 {
                                                                                            if let &Opcode::Icmp = v1433 {
                                                                                                match v1435 {
                                                                                                    &IntCC::NotEqual => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                    // Rule at src/opts/spaceship.isle line 64.
                                                                                                                    returns.extend(Some(v1406));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::UnsignedLessThan => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                    // Rule at src/opts/spaceship.isle line 54.
                                                                                                                    returns.extend(Some(v1406));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {}
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            &Opcode::Bmask => {
                                                                if v2.0 == v1148.0 {
                                                                    let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                                                    C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                                                    let mut v1217 = v1217.into_context_iter();
                                                                    while let Some(v1218) = v1217.next(ctx) {
                                                                        let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                                                        if let Some(v1220) = v1219 {
                                                                            if v1220.1 == 1_i64 {
                                                                                if v2.0 == v1220.0 {
                                                                                    let mut v1429 = C::inst_data_value_etor_returns::default();
                                                                                    C::inst_data_value_etor(ctx, v1248, &mut v1429);
                                                                                    let mut v1429 = v1429.into_context_iter();
                                                                                    while let Some(v1430) = v1429.next(ctx) {
                                                                                        if let &InstructionData::IntCompare {
                                                                                            opcode: ref v1433,
                                                                                            args: ref v1434,
                                                                                            cond: ref v1435,
                                                                                        } = &v1430.1 {
                                                                                            if let &Opcode::Icmp = v1433 {
                                                                                                match v1435 {
                                                                                                    &IntCC::NotEqual => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                    // Rule at src/opts/spaceship.isle line 68.
                                                                                                                    returns.extend(Some(v1406));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    &IntCC::UnsignedLessThan => {
                                                                                                        if v91.0 == v1430.0 {
                                                                                                            let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                            let v1436 = C::unpack_value_array_2(ctx, v1434);
                                                                                                            if v1134.0 == v1436.0 {
                                                                                                                if v1134.1 == v1436.1 {
                                                                                                                    let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                                    let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                                    // Rule at src/opts/spaceship.isle line 58.
                                                                                                                    returns.extend(Some(v1406));
                                                                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {}
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 27.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.2 == v1134.0 {
                                                    if v86.1 == v1134.1 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 41.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 28.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 42.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                                C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                                let mut v1217 = v1217.into_context_iter();
                                                while let Some(v1218) = v1217.next(ctx) {
                                                    let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                                    if let Some(v1220) = v1219 {
                                                        if v1220.1 == -1_i64 {
                                                            if v2.0 == v1220.0 {
                                                                let mut v1391 = C::uextend_maybe_etor_returns::default();
                                                                C::uextend_maybe_etor(ctx, v86.2, &mut v1391);
                                                                let mut v1391 = v1391.into_context_iter();
                                                                while let Some(v1392) = v1391.next(ctx) {
                                                                    if v2.0 == v1392.0 {
                                                                        let mut v1395 = C::inst_data_value_etor_returns::default();
                                                                        C::inst_data_value_etor(ctx, v1392.1, &mut v1395);
                                                                        let mut v1395 = v1395.into_context_iter();
                                                                        while let Some(v1396) = v1395.next(ctx) {
                                                                            if let &InstructionData::IntCompare {
                                                                                opcode: ref v1399,
                                                                                args: ref v1400,
                                                                                cond: ref v1401,
                                                                            } = &v1396.1 {
                                                                                if let &Opcode::Icmp = v1399 {
                                                                                    match v1401 {
                                                                                        &IntCC::NotEqual => {
                                                                                            if v91.0 == v1396.0 {
                                                                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                let v1402 = C::unpack_value_array_2(ctx, v1400);
                                                                                                if v1134.0 == v1402.0 {
                                                                                                    if v1134.1 == v1402.1 {
                                                                                                        let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                        let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                        // Rule at src/opts/spaceship.isle line 12.
                                                                                                        returns.extend(Some(v1406));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        &IntCC::UnsignedGreaterThan => {
                                                                                            if v91.0 == v1396.0 {
                                                                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                                let v1402 = C::unpack_value_array_2(ctx, v1400);
                                                                                                if v1134.0 == v1402.0 {
                                                                                                    if v1134.1 == v1402.1 {
                                                                                                        let v1405 = constructor_spaceship_u(ctx, v91.0, v1134.0, v1134.1);
                                                                                                        let v1406 = constructor_sextend_maybe(ctx, v2.0, v1405);
                                                                                                        // Rule at src/opts/spaceship.isle line 18.
                                                                                                        returns.extend(Some(v1406));
                                                                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 31.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 37.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 32.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 38.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                        let mut v96 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                        let mut v96 = v96.into_context_iter();
                                        while let Some(v97) = v96.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v1205,
                                                imm: v1206,
                                            } = &v97.1 {
                                                if let &Opcode::Iconst = v1205 {
                                                    let v1207 = C::u64_from_imm64(ctx, v1206);
                                                    match v1207 {
                                                        0x0_u64 => {
                                                            let mut v1147 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                            let mut v1147 = v1147.into_context_iter();
                                                            while let Some(v1148) = v1147.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v1208,
                                                                    imm: v1209,
                                                                } = &v1148.1 {
                                                                    if let &Opcode::Iconst = v1208 {
                                                                        let v1210 = C::u64_from_imm64(ctx, v1209);
                                                                        let v1211 = C::u64_matches_non_zero(ctx, v1210);
                                                                        if let Some(v1212) = v1211 {
                                                                            if v1212 == true {
                                                                                let v1213 = &C::intcc_complement(ctx, v1133);
                                                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                                                let v1214 = constructor_icmp(ctx, v91.0, v1213, v1134.0, v1134.1);
                                                                                let v1215 = constructor_select(ctx, v2.0, v1214, v86.2, v86.1);
                                                                                // Rule at src/opts/selects.isle line 8.
                                                                                returns.extend(Some(v1215));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        0x1_u64 => {
                                                            let mut v1147 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                            let mut v1147 = v1147.into_context_iter();
                                                            while let Some(v1148) = v1147.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v1208,
                                                                    imm: v1209,
                                                                } = &v1148.1 {
                                                                    if let &Opcode::Iconst = v1208 {
                                                                        let v1210 = C::u64_from_imm64(ctx, v1209);
                                                                        if v1210 == 0x0_u64 {
                                                                            let v1216 = constructor_uextend_maybe(ctx, v2.0, v86.0);
                                                                            // Rule at src/opts/selects.isle line 14.
                                                                            returns.extend(Some(v1216));
                                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                        }
                                        let mut v1217 = C::inst_data_value_tupled_etor_returns::default();
                                        C::inst_data_value_tupled_etor(ctx, v86.1, &mut v1217);
                                        let mut v1217 = v1217.into_context_iter();
                                        while let Some(v1218) = v1217.next(ctx) {
                                            let v1219 = C::iconst_sextend_etor(ctx, v1218);
                                            if let Some(v1220) = v1219 {
                                                if v1220.1 == -1_i64 {
                                                    let mut v1223 = C::inst_data_value_tupled_etor_returns::default();
                                                    C::inst_data_value_tupled_etor(ctx, v86.2, &mut v1223);
                                                    let mut v1223 = v1223.into_context_iter();
                                                    while let Some(v1224) = v1223.next(ctx) {
                                                        let v1225 = C::iconst_sextend_etor(ctx, v1224);
                                                        if let Some(v1226) = v1225 {
                                                            if v1226.1 == 0_i64 {
                                                                let v1229 = constructor_bmask(ctx, v2.0, v86.0);
                                                                // Rule at src/opts/selects.isle line 19.
                                                                returns.extend(Some(v1229));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v94,
                                    arg: v95,
                                } => {
                                    if let &Opcode::Uextend = v94 {
                                        let mut v1068 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v95, &mut v1068);
                                        let mut v1068 = v1068.into_context_iter();
                                        while let Some(v1069) = v1068.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v1072,
                                                args: ref v1073,
                                                cond: ref v1074,
                                            } = &v1069.1 {
                                                if let &Opcode::Icmp = v1072 {
                                                    let v1078 = constructor_select(ctx, v2.0, v95, v86.1, v86.2);
                                                    // Rule at src/opts/icmp.isle line 76.
                                                    returns.extend(Some(v1078));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    // Rule at src/opts/icmp.isle line 79.
                                                    returns.extend(Some(v1078));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v676,
                                    imm: v677,
                                } => {
                                    if let &Opcode::Iconst = v676 {
                                        let v678 = C::u64_from_imm64(ctx, v677);
                                        if v678 == 0x0_u64 {
                                            let v682 = C::subsume(ctx, v86.2);
                                            // Rule at src/opts/cprop.isle line 192.
                                            returns.extend(Some(v682));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        let v679 = C::u64_matches_non_zero(ctx, v678);
                                        if let Some(v680) = v679 {
                                            if v680 == true {
                                                let v681 = C::subsume(ctx, v86.1);
                                                // Rule at src/opts/cprop.isle line 190.
                                                returns.extend(Some(v681));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let mut v96 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v86.1, &mut v96);
                        let mut v96 = v96.into_context_iter();
                        while let Some(v97) = v96.next(ctx) {
                            match &v97.1 {
                                &InstructionData::Ternary {
                                    opcode: ref v1296,
                                    args: ref v1297,
                                } => {
                                    if let &Opcode::Select = v1296 {
                                        if v2.0 == v97.0 {
                                            let v1298 = C::unpack_value_array_3(ctx, v1297);
                                            if v86.0 == v1298.0 {
                                                let v1302 = constructor_select(ctx, v2.0, v86.0, v1298.1, v86.2);
                                                // Rule at src/opts/selects.isle line 102.
                                                returns.extend(Some(v1302));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v100,
                                    arg: v101,
                                } => {
                                    match v100 {
                                        &Opcode::Uextend => {
                                            if v2.0 == v97.0 {
                                                let mut v1147 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                let mut v1147 = v1147.into_context_iter();
                                                while let Some(v1148) = v1147.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v1247,
                                                        arg: v1248,
                                                    } = &v1148.1 {
                                                        if let &Opcode::Uextend = v1247 {
                                                            if v2.0 == v1148.0 {
                                                                let v1246 = C::value_type(ctx, v101);
                                                                let v1249 = C::value_type(ctx, v1248);
                                                                if v1246 == v1249 {
                                                                    let v1250 = constructor_select(ctx, v1246, v86.0, v101, v1248);
                                                                    let v1251 = constructor_uextend(ctx, v2.0, v1250);
                                                                    // Rule at src/opts/selects.isle line 80.
                                                                    returns.extend(Some(v1251));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            if v2.0 == v97.0 {
                                                let mut v1147 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                                                let mut v1147 = v1147.into_context_iter();
                                                while let Some(v1148) = v1147.next(ctx) {
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v1247,
                                                        arg: v1248,
                                                    } = &v1148.1 {
                                                        if let &Opcode::Sextend = v1247 {
                                                            if v2.0 == v1148.0 {
                                                                let v1246 = C::value_type(ctx, v101);
                                                                let v1249 = C::value_type(ctx, v1248);
                                                                if v1246 == v1249 {
                                                                    let v1250 = constructor_select(ctx, v1246, v86.0, v101, v1248);
                                                                    let v1252 = constructor_sextend(ctx, v2.0, v1250);
                                                                    // Rule at src/opts/selects.isle line 84.
                                                                    returns.extend(Some(v1252));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v86.1 == v86.2 {
                            let v681 = C::subsume(ctx, v86.1);
                            // Rule at src/opts/selects.isle line 3.
                            returns.extend(Some(v681));
                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                        }
                        let mut v272 = ContextIterWrapper::<ConstructorVec<_>, _>::default();
                        constructor_truthy(ctx, v86.0, &mut v272);
                        let mut v272 = v272.into_context_iter();
                        while let Some(v273) = v272.next(ctx) {
                            let v274 = constructor_select(ctx, v2.0, v273, v86.1, v86.2);
                            // Rule at src/opts/bitops.isle line 120.
                            returns.extend(Some(v274));
                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                        }
                        let mut v1147 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v86.2, &mut v1147);
                        let mut v1147 = v1147.into_context_iter();
                        while let Some(v1148) = v1147.next(ctx) {
                            if let &InstructionData::Ternary {
                                opcode: ref v1289,
                                args: ref v1290,
                            } = &v1148.1 {
                                if let &Opcode::Select = v1289 {
                                    if v2.0 == v1148.0 {
                                        let v1291 = C::unpack_value_array_3(ctx, v1290);
                                        if v86.0 == v1291.0 {
                                            let v1295 = constructor_select(ctx, v2.0, v86.0, v86.1, v1291.2);
                                            // Rule at src/opts/selects.isle line 101.
                                            returns.extend(Some(v1295));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::SelectSpectreGuard => {
                        let v86 = C::unpack_value_array_3(ctx, v85);
                        let mut v90 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v86.0, &mut v90);
                        let mut v90 = v90.into_context_iter();
                        while let Some(v91) = v90.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v676,
                                imm: v677,
                            } = &v91.1 {
                                if let &Opcode::Iconst = v676 {
                                    let v678 = C::u64_from_imm64(ctx, v677);
                                    if v678 == 0x0_u64 {
                                        let v682 = C::subsume(ctx, v86.2);
                                        // Rule at src/opts/spectre.isle line 13.
                                        returns.extend(Some(v682));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                    let v679 = C::u64_matches_non_zero(ctx, v678);
                                    if let Some(v680) = v679 {
                                        if v680 == true {
                                            let v681 = C::subsume(ctx, v86.1);
                                            // Rule at src/opts/spectre.isle line 11.
                                            returns.extend(Some(v681));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                        if v86.1 == v86.2 {
                            let v681 = C::subsume(ctx, v86.1);
                            // Rule at src/opts/spectre.isle line 9.
                            returns.extend(Some(v681));
                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                        }
                    }
                    &Opcode::Bitselect => {
                        let v1234 = C::multi_lane(ctx, v2.0);
                        if let Some(v1235) = v1234 {
                            let v86 = C::unpack_value_array_3(ctx, v85);
                            let mut v90 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v86.0, &mut v90);
                            let mut v90 = v90.into_context_iter();
                            while let Some(v91) = v90.next(ctx) {
                                if let &InstructionData::IntCompare {
                                    opcode: ref v1131,
                                    args: ref v1132,
                                    cond: ref v1133,
                                } = &v91.1 {
                                    if let &Opcode::Icmp = v1131 {
                                        match v1133 {
                                            &IntCC::SignedGreaterThan => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 45.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 59.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 46.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 60.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 49.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 55.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1232 = constructor_smin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 50.
                                                        returns.extend(Some(v1232));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1230 = constructor_smax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 56.
                                                        returns.extend(Some(v1230));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 47.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 61.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 48.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 62.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 51.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 57.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v1134 = C::unpack_value_array_2(ctx, v1132);
                                                if v86.1 == v1134.0 {
                                                    if v86.2 == v1134.1 {
                                                        let v1233 = constructor_umin(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 52.
                                                        returns.extend(Some(v1233));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                                if v86.1 == v1134.1 {
                                                    if v86.2 == v1134.0 {
                                                        let v1231 = constructor_umax(ctx, v2.0, v1134.0, v1134.1);
                                                        // Rule at src/opts/selects.isle line 58.
                                                        returns.extend(Some(v1231));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        let v86 = C::unpack_value_array_3(ctx, v85);
                        if v86.1 == v86.2 {
                            let v681 = C::subsume(ctx, v86.1);
                            // Rule at src/opts/selects.isle line 4.
                            returns.extend(Some(v681));
                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                        }
                    }
                    &Opcode::Fma => {
                        let v86 = C::unpack_value_array_3(ctx, v85);
                        let mut v90 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v86.0, &mut v90);
                        let mut v90 = v90.into_context_iter();
                        while let Some(v91) = v90.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v94,
                                arg: v95,
                            } = &v91.1 {
                                if let &Opcode::Fneg = v94 {
                                    if v2.0 == v91.0 {
                                        let mut v96 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v86.1, &mut v96);
                                        let mut v96 = v96.into_context_iter();
                                        while let Some(v97) = v96.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v100,
                                                arg: v101,
                                            } = &v97.1 {
                                                if let &Opcode::Fneg = v100 {
                                                    if v2.0 == v97.0 {
                                                        let v102 = constructor_fma(ctx, v2.0, v95, v101, v86.2);
                                                        // Rule at src/opts/arithmetic.isle line 190.
                                                        returns.extend(Some(v102));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::Unary {
                opcode: ref v32,
                arg: v33,
            } => {
                match v32 {
                    &Opcode::Splat => {
                        let v722 = C::ty_vec128(ctx, v2.0);
                        if let Some(v723) = v722 {
                            let mut v34 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v33, &mut v34);
                            let mut v34 = v34.into_context_iter();
                            while let Some(v35) = v34.next(ctx) {
                                match &v35.1 {
                                    &InstructionData::UnaryIeee32 {
                                        opcode: ref v739,
                                        imm: v740,
                                    } => {
                                        if let &Opcode::F32const = v739 {
                                            let v741 = C::u32_from_ieee32(ctx, v740);
                                            let v742 = C::u32_into_u64(ctx, v741);
                                            let v743 = constructor_splat32(ctx, v742);
                                            let v744 = constructor_vconst(ctx, v723, v743);
                                            // Rule at src/opts/cprop.isle line 234.
                                            returns.extend(Some(v744));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                    &InstructionData::UnaryIeee64 {
                                        opcode: ref v745,
                                        imm: v746,
                                    } => {
                                        if let &Opcode::F64const = v745 {
                                            let v747 = C::u64_from_ieee64(ctx, v746);
                                            let v748 = C::splat64(ctx, v747);
                                            let v749 = constructor_vconst(ctx, v723, v748);
                                            // Rule at src/opts/cprop.isle line 236.
                                            returns.extend(Some(v749));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                    &InstructionData::UnaryImm {
                                        opcode: ref v567,
                                        imm: v568,
                                    } => {
                                        if let &Opcode::Iconst = v567 {
                                            match v35.0 {
                                                I8 => {
                                                    let v724 = C::u64_uextend_imm64(ctx, I8, v568);
                                                    let v725 = constructor_splat8(ctx, v724);
                                                    let v726 = constructor_vconst(ctx, v723, v725);
                                                    // Rule at src/opts/cprop.isle line 226.
                                                    returns.extend(Some(v726));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                I16 => {
                                                    let v728 = C::u64_uextend_imm64(ctx, I16, v568);
                                                    let v729 = constructor_splat16(ctx, v728);
                                                    let v730 = constructor_vconst(ctx, v723, v729);
                                                    // Rule at src/opts/cprop.isle line 228.
                                                    returns.extend(Some(v730));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                I32 => {
                                                    let v732 = C::u64_uextend_imm64(ctx, I32, v568);
                                                    let v733 = constructor_splat32(ctx, v732);
                                                    let v734 = constructor_vconst(ctx, v723, v733);
                                                    // Rule at src/opts/cprop.isle line 230.
                                                    returns.extend(Some(v734));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                I64 => {
                                                    let v736 = C::u64_uextend_imm64(ctx, I64, v568);
                                                    let v737 = C::splat64(ctx, v736);
                                                    let v738 = constructor_vconst(ctx, v723, v737);
                                                    // Rule at src/opts/cprop.isle line 232.
                                                    returns.extend(Some(v738));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    &Opcode::Ineg => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::Binary {
                                    opcode: ref v38,
                                    args: ref v39,
                                } => {
                                    match v38 {
                                        &Opcode::Isub => {
                                            if v2.0 == v35.0 {
                                                let v40 = C::unpack_value_array_2(ctx, v39);
                                                let v43 = constructor_isub(ctx, v2.0, v40.1, v40.0);
                                                // Rule at src/opts/arithmetic.isle line 27.
                                                returns.extend(Some(v43));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Ushr => {
                                            if v2.0 == v35.0 {
                                                let v40 = C::unpack_value_array_2(ctx, v39);
                                                let mut v1329 = C::inst_data_value_etor_returns::default();
                                                C::inst_data_value_etor(ctx, v40.1, &mut v1329);
                                                let mut v1329 = v1329.into_context_iter();
                                                while let Some(v1330) = v1329.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v1333,
                                                        imm: v1334,
                                                    } = &v1330.1 {
                                                        if let &Opcode::Iconst = v1333 {
                                                            let v1335 = C::u64_from_imm64(ctx, v1334);
                                                            let v257 = constructor_ty_shift_mask(ctx, v2.0);
                                                            let v1336 = C::u64_eq(ctx, v1335, v257);
                                                            if v1336 == true {
                                                                if v2.0 == v1330.0 {
                                                                    let v1337 = constructor_sshr(ctx, v2.0, v40.0, v40.1);
                                                                    // Rule at src/opts/shifts.isle line 98.
                                                                    returns.extend(Some(v1337));
                                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    match v45 {
                                        &Opcode::Splat => {
                                            if v2.0 == v35.0 {
                                                let v1353 = C::lane_type(ctx, v2.0);
                                                let v1491 = constructor_ineg(ctx, v1353, v46);
                                                let v1492 = constructor_splat(ctx, v2.0, v1491);
                                                // Rule at src/opts/vector.isle line 45.
                                                returns.extend(Some(v1492));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Ineg => {
                                            if v2.0 == v35.0 {
                                                let v47 = C::subsume(ctx, v46);
                                                // Rule at src/opts/arithmetic.isle line 34.
                                                returns.extend(Some(v47));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Iabs => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                match v45 {
                                    &Opcode::Splat => {
                                        if v2.0 == v35.0 {
                                            let v1353 = C::lane_type(ctx, v2.0);
                                            let v1493 = constructor_iabs(ctx, v1353, v46);
                                            let v1494 = constructor_splat(ctx, v2.0, v1493);
                                            // Rule at src/opts/vector.isle line 48.
                                            returns.extend(Some(v1494));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                    &Opcode::Ineg => {
                                        if v2.0 == v35.0 {
                                            let v50 = constructor_iabs(ctx, v2.0, v46);
                                            // Rule at src/opts/arithmetic.isle line 41.
                                            returns.extend(Some(v50));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                    &Opcode::Iabs => {
                                        if v2.0 == v35.0 {
                                            let v51 = C::subsume(ctx, v33);
                                            // Rule at src/opts/arithmetic.isle line 45.
                                            returns.extend(Some(v51));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    &Opcode::Bnot => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::Binary {
                                    opcode: ref v38,
                                    args: ref v39,
                                } => {
                                    match v38 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v35.0 {
                                                let v40 = C::unpack_value_array_2(ctx, v39);
                                                let mut v66 = C::inst_data_value_tupled_etor_returns::default();
                                                C::inst_data_value_tupled_etor(ctx, v40.1, &mut v66);
                                                let mut v66 = v66.into_context_iter();
                                                while let Some(v67) = v66.next(ctx) {
                                                    let v68 = C::iconst_sextend_etor(ctx, v67);
                                                    if let Some(v69) = v68 {
                                                        if v69.1 == -1_i64 {
                                                            if v2.0 == v69.0 {
                                                                let v72 = constructor_ineg(ctx, v2.0, v40.0);
                                                                // Rule at src/opts/arithmetic.isle line 74.
                                                                returns.extend(Some(v72));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v35.0 {
                                                let v40 = C::unpack_value_array_2(ctx, v39);
                                                let mut v66 = C::inst_data_value_tupled_etor_returns::default();
                                                C::inst_data_value_tupled_etor(ctx, v40.1, &mut v66);
                                                let mut v66 = v66.into_context_iter();
                                                while let Some(v67) = v66.next(ctx) {
                                                    let v68 = C::iconst_sextend_etor(ctx, v67);
                                                    if let Some(v69) = v68 {
                                                        if v69.1 == 1_i64 {
                                                            if v2.0 == v69.0 {
                                                                let v72 = constructor_ineg(ctx, v2.0, v40.0);
                                                                // Rule at src/opts/arithmetic.isle line 72.
                                                                returns.extend(Some(v72));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Band => {
                                            let v40 = C::unpack_value_array_2(ctx, v39);
                                            let v242 = constructor_bnot(ctx, v2.0, v40.0);
                                            let v243 = constructor_bnot(ctx, v2.0, v40.1);
                                            let v245 = constructor_bor(ctx, v2.0, v242, v243);
                                            // Rule at src/opts/bitops.isle line 48.
                                            returns.extend(Some(v245));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v35.0 {
                                                let v40 = C::unpack_value_array_2(ctx, v39);
                                                let v242 = constructor_bnot(ctx, v2.0, v40.0);
                                                let v243 = constructor_bnot(ctx, v2.0, v40.1);
                                                let v244 = constructor_band(ctx, v2.0, v242, v243);
                                                // Rule at src/opts/bitops.isle line 45.
                                                returns.extend(Some(v244));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    match v45 {
                                        &Opcode::Splat => {
                                            let v1471 = C::ty_vector_not_float(ctx, v2.0);
                                            if let Some(v1472) = v1471 {
                                                if v2.0 == v35.0 {
                                                    let v1353 = C::lane_type(ctx, v2.0);
                                                    let v1479 = constructor_bnot(ctx, v1353, v46);
                                                    let v1480 = constructor_splat(ctx, v2.0, v1479);
                                                    // Rule at src/opts/vector.isle line 26.
                                                    returns.extend(Some(v1480));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                        &Opcode::Bnot => {
                                            if v2.0 == v35.0 {
                                                let v47 = C::subsume(ctx, v46);
                                                // Rule at src/opts/bitops.isle line 41.
                                                returns.extend(Some(v47));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v567,
                                    imm: v568,
                                } => {
                                    if let &Opcode::Iconst = v567 {
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            if v35.0 == v566 {
                                                let v599 = C::u64_from_imm64(ctx, v568);
                                                let v600 = C::u64_not(ctx, v599);
                                                let v601 = C::imm64_masked(ctx, v566, v600);
                                                let v602 = constructor_iconst(ctx, v566, v601);
                                                let v603 = C::subsume(ctx, v602);
                                                // Rule at src/opts/cprop.isle line 73.
                                                returns.extend(Some(v603));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v1198 = C::remat(ctx, arg0);
                        // Rule at src/opts/remat.isle line 23.
                        returns.extend(Some(v1198));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Bitrev => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                if let &Opcode::Bitrev = v45 {
                                    if v2.0 == v35.0 {
                                        let v47 = C::subsume(ctx, v46);
                                        // Rule at src/opts/bitops.isle line 139.
                                        returns.extend(Some(v47));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Clz => {
                        let v565 = C::fits_in_64(ctx, v2.0);
                        if let Some(v566) = v565 {
                            let mut v34 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v33, &mut v34);
                            let mut v34 = v34.into_context_iter();
                            while let Some(v35) = v34.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v567,
                                    imm: v568,
                                } = &v35.1 {
                                    if let &Opcode::Iconst = v567 {
                                        if v35.0 == v566 {
                                            let v569 = C::imm64_clz(ctx, v566, v568);
                                            let v570 = constructor_iconst(ctx, v566, v569);
                                            let v571 = C::subsume(ctx, v570);
                                            // Rule at src/opts/cprop.isle line 2.
                                            returns.extend(Some(v571));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ctz => {
                        let v565 = C::fits_in_64(ctx, v2.0);
                        if let Some(v566) = v565 {
                            let mut v34 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v33, &mut v34);
                            let mut v34 = v34.into_context_iter();
                            while let Some(v35) = v34.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v567,
                                    imm: v568,
                                } = &v35.1 {
                                    if let &Opcode::Iconst = v567 {
                                        if v35.0 == v566 {
                                            let v572 = C::imm64_ctz(ctx, v566, v568);
                                            let v573 = constructor_iconst(ctx, v566, v572);
                                            let v574 = C::subsume(ctx, v573);
                                            // Rule at src/opts/cprop.isle line 8.
                                            returns.extend(Some(v574));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bswap => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    if let &Opcode::Bswap = v45 {
                                        if v2.0 == v35.0 {
                                            let v47 = C::subsume(ctx, v46);
                                            // Rule at src/opts/bitops.isle line 136.
                                            returns.extend(Some(v47));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v567,
                                    imm: v568,
                                } => {
                                    if let &Opcode::Iconst = v567 {
                                        match v2.0 {
                                            I16 => {
                                                let v599 = C::u64_from_imm64(ctx, v568);
                                                let v783 = C::u64_bswap16(ctx, v599);
                                                let v784 = C::imm64(ctx, v783);
                                                let v785 = constructor_iconst(ctx, I16, v784);
                                                let v786 = C::subsume(ctx, v785);
                                                // Rule at src/opts/cprop.isle line 306.
                                                returns.extend(Some(v786));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            I32 => {
                                                let v599 = C::u64_from_imm64(ctx, v568);
                                                let v787 = C::u64_bswap32(ctx, v599);
                                                let v788 = C::imm64(ctx, v787);
                                                let v789 = constructor_iconst(ctx, I32, v788);
                                                let v790 = C::subsume(ctx, v789);
                                                // Rule at src/opts/cprop.isle line 308.
                                                returns.extend(Some(v790));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            I64 => {
                                                let v599 = C::u64_from_imm64(ctx, v568);
                                                let v791 = C::u64_bswap64(ctx, v599);
                                                let v792 = C::imm64(ctx, v791);
                                                let v793 = constructor_iconst(ctx, I64, v792);
                                                let v794 = C::subsume(ctx, v793);
                                                // Rule at src/opts/cprop.isle line 310.
                                                returns.extend(Some(v794));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Popcnt => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                if let &Opcode::Splat = v45 {
                                    if v2.0 == v35.0 {
                                        let v1353 = C::lane_type(ctx, v2.0);
                                        let v1495 = constructor_popcnt(ctx, v1353, v46);
                                        let v1496 = constructor_splat(ctx, v2.0, v1495);
                                        // Rule at src/opts/vector.isle line 51.
                                        returns.extend(Some(v1496));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sqrt => {
                        match v2.0 {
                            F32 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v739,
                                            imm: v740,
                                        } = &v35.1 {
                                            if let &Opcode::F32const = v739 {
                                                let v835 = C::f32_sqrt(ctx, v740);
                                                if let Some(v836) = v835 {
                                                    let v837 = constructor_f32const(ctx, F32, v836);
                                                    let v838 = C::subsume(ctx, v837);
                                                    // Rule at src/opts/cprop.isle line 357.
                                                    returns.extend(Some(v838));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v745,
                                            imm: v746,
                                        } = &v35.1 {
                                            if let &Opcode::F64const = v745 {
                                                let v839 = C::f64_sqrt(ctx, v746);
                                                if let Some(v840) = v839 {
                                                    let v841 = constructor_f64const(ctx, F64, v840);
                                                    let v842 = C::subsume(ctx, v841);
                                                    // Rule at src/opts/cprop.isle line 360.
                                                    returns.extend(Some(v842));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Fneg => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    if let &Opcode::Fneg = v45 {
                                        if v2.0 == v35.0 {
                                            let v47 = C::subsume(ctx, v46);
                                            // Rule at src/opts/arithmetic.isle line 186.
                                            returns.extend(Some(v47));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                &InstructionData::UnaryConst {
                                    opcode: ref v934,
                                    constant_handle: v935,
                                } => {
                                    if let &Opcode::F128const = v934 {
                                        if v2.0 == F128 {
                                            if v35.0 == F128 {
                                                let v936 = C::ieee128_constant_extractor(ctx, v935);
                                                if let Some(v937) = v936 {
                                                    let v938 = C::f128_neg(ctx, v937);
                                                    let v939 = C::ieee128_constant(ctx, v938);
                                                    let v940 = constructor_f128const(ctx, F128, v939);
                                                    let v941 = C::subsume(ctx, v940);
                                                    // Rule at src/opts/cprop.isle line 424.
                                                    returns.extend(Some(v941));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryIeee16 {
                                    opcode: ref v923,
                                    imm: v924,
                                } => {
                                    if let &Opcode::F16const = v923 {
                                        if v2.0 == F16 {
                                            if v35.0 == F16 {
                                                let v925 = C::f16_neg(ctx, v924);
                                                let v926 = constructor_f16const(ctx, F16, v925);
                                                let v927 = C::subsume(ctx, v926);
                                                // Rule at src/opts/cprop.isle line 418.
                                                returns.extend(Some(v927));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryIeee32 {
                                    opcode: ref v739,
                                    imm: v740,
                                } => {
                                    if let &Opcode::F32const = v739 {
                                        if v2.0 == F32 {
                                            if v35.0 == F32 {
                                                let v928 = C::f32_neg(ctx, v740);
                                                let v929 = constructor_f32const(ctx, F32, v928);
                                                let v930 = C::subsume(ctx, v929);
                                                // Rule at src/opts/cprop.isle line 420.
                                                returns.extend(Some(v930));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryIeee64 {
                                    opcode: ref v745,
                                    imm: v746,
                                } => {
                                    if let &Opcode::F64const = v745 {
                                        if v2.0 == F64 {
                                            if v35.0 == F64 {
                                                let v931 = C::f64_neg(ctx, v746);
                                                let v932 = constructor_f64const(ctx, F64, v931);
                                                let v933 = C::subsume(ctx, v932);
                                                // Rule at src/opts/cprop.isle line 422.
                                                returns.extend(Some(v933));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Fabs => {
                        match v2.0 {
                            F16 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F16 {
                                        if let &InstructionData::UnaryIeee16 {
                                            opcode: ref v923,
                                            imm: v924,
                                        } = &v35.1 {
                                            if let &Opcode::F16const = v923 {
                                                let v942 = C::f16_abs(ctx, v924);
                                                let v943 = constructor_f16const(ctx, F16, v942);
                                                let v944 = C::subsume(ctx, v943);
                                                // Rule at src/opts/cprop.isle line 427.
                                                returns.extend(Some(v944));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                            }
                            F32 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v739,
                                            imm: v740,
                                        } = &v35.1 {
                                            if let &Opcode::F32const = v739 {
                                                let v945 = C::f32_abs(ctx, v740);
                                                let v946 = constructor_f32const(ctx, F32, v945);
                                                let v947 = C::subsume(ctx, v946);
                                                // Rule at src/opts/cprop.isle line 429.
                                                returns.extend(Some(v947));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v745,
                                            imm: v746,
                                        } = &v35.1 {
                                            if let &Opcode::F64const = v745 {
                                                let v948 = C::f64_abs(ctx, v746);
                                                let v949 = constructor_f64const(ctx, F64, v948);
                                                let v950 = C::subsume(ctx, v949);
                                                // Rule at src/opts/cprop.isle line 431.
                                                returns.extend(Some(v950));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                }
                            }
                            F128 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F128 {
                                        if let &InstructionData::UnaryConst {
                                            opcode: ref v934,
                                            constant_handle: v935,
                                        } = &v35.1 {
                                            if let &Opcode::F128const = v934 {
                                                let v936 = C::ieee128_constant_extractor(ctx, v935);
                                                if let Some(v937) = v936 {
                                                    let v951 = C::f128_abs(ctx, v937);
                                                    let v952 = C::ieee128_constant(ctx, v951);
                                                    let v953 = constructor_f128const(ctx, F128, v952);
                                                    let v954 = C::subsume(ctx, v953);
                                                    // Rule at src/opts/cprop.isle line 433.
                                                    returns.extend(Some(v954));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Ceil => {
                        match v2.0 {
                            F32 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v739,
                                            imm: v740,
                                        } = &v35.1 {
                                            if let &Opcode::F32const = v739 {
                                                let v843 = C::f32_ceil(ctx, v740);
                                                if let Some(v844) = v843 {
                                                    let v845 = constructor_f32const(ctx, F32, v844);
                                                    let v846 = C::subsume(ctx, v845);
                                                    // Rule at src/opts/cprop.isle line 364.
                                                    returns.extend(Some(v846));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v745,
                                            imm: v746,
                                        } = &v35.1 {
                                            if let &Opcode::F64const = v745 {
                                                let v847 = C::f64_ceil(ctx, v746);
                                                if let Some(v848) = v847 {
                                                    let v849 = constructor_f64const(ctx, F64, v848);
                                                    let v850 = C::subsume(ctx, v849);
                                                    // Rule at src/opts/cprop.isle line 367.
                                                    returns.extend(Some(v850));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Floor => {
                        match v2.0 {
                            F32 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v739,
                                            imm: v740,
                                        } = &v35.1 {
                                            if let &Opcode::F32const = v739 {
                                                let v851 = C::f32_floor(ctx, v740);
                                                if let Some(v852) = v851 {
                                                    let v853 = constructor_f32const(ctx, F32, v852);
                                                    let v854 = C::subsume(ctx, v853);
                                                    // Rule at src/opts/cprop.isle line 371.
                                                    returns.extend(Some(v854));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v745,
                                            imm: v746,
                                        } = &v35.1 {
                                            if let &Opcode::F64const = v745 {
                                                let v855 = C::f64_floor(ctx, v746);
                                                if let Some(v856) = v855 {
                                                    let v857 = constructor_f64const(ctx, F64, v856);
                                                    let v858 = C::subsume(ctx, v857);
                                                    // Rule at src/opts/cprop.isle line 374.
                                                    returns.extend(Some(v858));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Trunc => {
                        match v2.0 {
                            F32 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v739,
                                            imm: v740,
                                        } = &v35.1 {
                                            if let &Opcode::F32const = v739 {
                                                let v859 = C::f32_trunc(ctx, v740);
                                                if let Some(v860) = v859 {
                                                    let v861 = constructor_f32const(ctx, F32, v860);
                                                    let v862 = C::subsume(ctx, v861);
                                                    // Rule at src/opts/cprop.isle line 378.
                                                    returns.extend(Some(v862));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v745,
                                            imm: v746,
                                        } = &v35.1 {
                                            if let &Opcode::F64const = v745 {
                                                let v863 = C::f64_trunc(ctx, v746);
                                                if let Some(v864) = v863 {
                                                    let v865 = constructor_f64const(ctx, F64, v864);
                                                    let v866 = C::subsume(ctx, v865);
                                                    // Rule at src/opts/cprop.isle line 381.
                                                    returns.extend(Some(v866));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Nearest => {
                        match v2.0 {
                            F32 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F32 {
                                        if let &InstructionData::UnaryIeee32 {
                                            opcode: ref v739,
                                            imm: v740,
                                        } = &v35.1 {
                                            if let &Opcode::F32const = v739 {
                                                let v867 = C::f32_nearest(ctx, v740);
                                                if let Some(v868) = v867 {
                                                    let v869 = constructor_f32const(ctx, F32, v868);
                                                    let v870 = C::subsume(ctx, v869);
                                                    // Rule at src/opts/cprop.isle line 385.
                                                    returns.extend(Some(v870));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            F64 => {
                                let mut v34 = C::inst_data_value_etor_returns::default();
                                C::inst_data_value_etor(ctx, v33, &mut v34);
                                let mut v34 = v34.into_context_iter();
                                while let Some(v35) = v34.next(ctx) {
                                    if v35.0 == F64 {
                                        if let &InstructionData::UnaryIeee64 {
                                            opcode: ref v745,
                                            imm: v746,
                                        } = &v35.1 {
                                            if let &Opcode::F64const = v745 {
                                                let v871 = C::f64_nearest(ctx, v746);
                                                if let Some(v872) = v871 {
                                                    let v873 = constructor_f64const(ctx, F64, v872);
                                                    let v874 = C::subsume(ctx, v873);
                                                    // Rule at src/opts/cprop.isle line 388.
                                                    returns.extend(Some(v874));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    &Opcode::Bmask => {
                        if v2.0 == I8 {
                            let mut v34 = C::inst_data_value_etor_returns::default();
                            C::inst_data_value_etor(ctx, v33, &mut v34);
                            let mut v34 = v34.into_context_iter();
                            while let Some(v35) = v34.next(ctx) {
                                if v35.0 == I8 {
                                    if let &InstructionData::IntCompare {
                                        opcode: ref v261,
                                        args: ref v262,
                                        cond: ref v263,
                                    } = &v35.1 {
                                        if let &Opcode::Icmp = v261 {
                                            let v268 = constructor_ineg(ctx, I8, v33);
                                            // Rule at src/opts/bitops.isle line 97.
                                            returns.extend(Some(v268));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                        let mut v269 = ContextIterWrapper::<ConstructorVec<_>, _>::default();
                        constructor_truthy(ctx, v33, &mut v269);
                        let mut v269 = v269.into_context_iter();
                        while let Some(v270) = v269.next(ctx) {
                            let v271 = constructor_bmask(ctx, v2.0, v270);
                            // Rule at src/opts/bitops.isle line 119.
                            returns.extend(Some(v271));
                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                        }
                    }
                    &Opcode::Ireduce => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::Binary {
                                    opcode: ref v38,
                                    args: ref v39,
                                } => {
                                    match v38 {
                                        &Opcode::Iadd => {
                                            let v40 = C::unpack_value_array_2(ctx, v39);
                                            let v1016 = constructor_ireduce(ctx, v2.0, v40.0);
                                            let v1017 = constructor_ireduce(ctx, v2.0, v40.1);
                                            let v1018 = constructor_iadd(ctx, v2.0, v1016, v1017);
                                            // Rule at src/opts/extends.isle line 85.
                                            returns.extend(Some(v1018));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Isub => {
                                            let v40 = C::unpack_value_array_2(ctx, v39);
                                            let v1016 = constructor_ireduce(ctx, v2.0, v40.0);
                                            let v1017 = constructor_ireduce(ctx, v2.0, v40.1);
                                            let v1019 = constructor_isub(ctx, v2.0, v1016, v1017);
                                            // Rule at src/opts/extends.isle line 86.
                                            returns.extend(Some(v1019));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Imul => {
                                            let v40 = C::unpack_value_array_2(ctx, v39);
                                            let v1016 = constructor_ireduce(ctx, v2.0, v40.0);
                                            let v1017 = constructor_ireduce(ctx, v2.0, v40.1);
                                            let v1020 = constructor_imul(ctx, v2.0, v1016, v1017);
                                            // Rule at src/opts/extends.isle line 87.
                                            returns.extend(Some(v1020));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Band => {
                                            let v40 = C::unpack_value_array_2(ctx, v39);
                                            let v1016 = constructor_ireduce(ctx, v2.0, v40.0);
                                            let v1017 = constructor_ireduce(ctx, v2.0, v40.1);
                                            let v1023 = constructor_band(ctx, v2.0, v1016, v1017);
                                            // Rule at src/opts/extends.isle line 90.
                                            returns.extend(Some(v1023));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Bor => {
                                            let v40 = C::unpack_value_array_2(ctx, v39);
                                            let v1016 = constructor_ireduce(ctx, v2.0, v40.0);
                                            let v1017 = constructor_ireduce(ctx, v2.0, v40.1);
                                            let v1021 = constructor_bor(ctx, v2.0, v1016, v1017);
                                            // Rule at src/opts/extends.isle line 88.
                                            returns.extend(Some(v1021));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Bxor => {
                                            let v40 = C::unpack_value_array_2(ctx, v39);
                                            let v1016 = constructor_ireduce(ctx, v2.0, v40.0);
                                            let v1017 = constructor_ireduce(ctx, v2.0, v40.1);
                                            let v1022 = constructor_bxor(ctx, v2.0, v1016, v1017);
                                            // Rule at src/opts/extends.isle line 89.
                                            returns.extend(Some(v1022));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    match v45 {
                                        &Opcode::Ineg => {
                                            let v1013 = constructor_ireduce(ctx, v2.0, v46);
                                            let v1014 = constructor_ineg(ctx, v2.0, v1013);
                                            // Rule at src/opts/extends.isle line 82.
                                            returns.extend(Some(v1014));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Bnot => {
                                            let v1013 = constructor_ireduce(ctx, v2.0, v46);
                                            let v1015 = constructor_bnot(ctx, v2.0, v1013);
                                            // Rule at src/opts/extends.isle line 83.
                                            returns.extend(Some(v1015));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Bmask => {
                                            let v295 = constructor_bmask(ctx, v2.0, v46);
                                            // Rule at src/opts/bitops.isle line 133.
                                            returns.extend(Some(v295));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Uextend => {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                let v999 = C::ty_bits_u64(ctx, v53);
                                                let v998 = C::value_type(ctx, v46);
                                                let v1000 = C::ty_bits_u64(ctx, v998);
                                                let v1001 = C::u64_lt(ctx, v999, v1000);
                                                if v1001 == true {
                                                    let v1002 = constructor_ireduce(ctx, v53, v46);
                                                    // Rule at src/opts/extends.isle line 57.
                                                    returns.extend(Some(v1002));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1003 = C::u64_lt(ctx, v1000, v999);
                                                if v1003 == true {
                                                    let v1005 = constructor_uextend(ctx, v53, v46);
                                                    // Rule at src/opts/extends.isle line 64.
                                                    returns.extend(Some(v1005));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                            let v998 = C::value_type(ctx, v46);
                                            if v2.0 == v998 {
                                                let v47 = C::subsume(ctx, v46);
                                                // Rule at src/opts/extends.isle line 50.
                                                returns.extend(Some(v47));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v52 = C::ty_int(ctx, v2.0);
                                            if let Some(v53) = v52 {
                                                let v999 = C::ty_bits_u64(ctx, v53);
                                                let v998 = C::value_type(ctx, v46);
                                                let v1000 = C::ty_bits_u64(ctx, v998);
                                                let v1001 = C::u64_lt(ctx, v999, v1000);
                                                if v1001 == true {
                                                    let v1002 = constructor_ireduce(ctx, v53, v46);
                                                    // Rule at src/opts/extends.isle line 54.
                                                    returns.extend(Some(v1002));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                                let v1003 = C::u64_lt(ctx, v1000, v999);
                                                if v1003 == true {
                                                    let v1004 = constructor_sextend(ctx, v53, v46);
                                                    // Rule at src/opts/extends.isle line 61.
                                                    returns.extend(Some(v1004));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                            let v998 = C::value_type(ctx, v46);
                                            if v2.0 == v998 {
                                                let v47 = C::subsume(ctx, v46);
                                                // Rule at src/opts/extends.isle line 49.
                                                returns.extend(Some(v47));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v567,
                                    imm: v568,
                                } => {
                                    if let &Opcode::Iconst = v567 {
                                        let v613 = C::fits_in_64(ctx, v35.0);
                                        if let Some(v614) = v613 {
                                            let v599 = C::u64_from_imm64(ctx, v568);
                                            let v615 = C::imm64_masked(ctx, v2.0, v599);
                                            let v616 = constructor_iconst(ctx, v2.0, v615);
                                            let v617 = C::subsume(ctx, v616);
                                            // Rule at src/opts/cprop.isle line 93.
                                            returns.extend(Some(v617));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::SwidenLow => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                if let &Opcode::Splat = v45 {
                                    let v1353 = C::lane_type(ctx, v2.0);
                                    let v1515 = constructor_sextend(ctx, v1353, v46);
                                    let v1516 = constructor_splat(ctx, v2.0, v1515);
                                    // Rule at src/opts/vector.isle line 85.
                                    returns.extend(Some(v1516));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                    }
                    &Opcode::SwidenHigh => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                if let &Opcode::Splat = v45 {
                                    let v1353 = C::lane_type(ctx, v2.0);
                                    let v1515 = constructor_sextend(ctx, v1353, v46);
                                    let v1516 = constructor_splat(ctx, v2.0, v1515);
                                    // Rule at src/opts/vector.isle line 84.
                                    returns.extend(Some(v1516));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                    }
                    &Opcode::UwidenLow => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                if let &Opcode::Splat = v45 {
                                    let v1353 = C::lane_type(ctx, v2.0);
                                    let v1517 = constructor_uextend(ctx, v1353, v46);
                                    let v1518 = constructor_splat(ctx, v2.0, v1517);
                                    // Rule at src/opts/vector.isle line 88.
                                    returns.extend(Some(v1518));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                    }
                    &Opcode::UwidenHigh => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                if let &Opcode::Splat = v45 {
                                    let v1353 = C::lane_type(ctx, v2.0);
                                    let v1517 = constructor_uextend(ctx, v1353, v46);
                                    let v1518 = constructor_splat(ctx, v2.0, v1517);
                                    // Rule at src/opts/vector.isle line 87.
                                    returns.extend(Some(v1518));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                    }
                    &Opcode::Uextend => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    if let &Opcode::Uextend = v45 {
                                        let v968 = constructor_uextend(ctx, v2.0, v46);
                                        // Rule at src/opts/extends.isle line 1.
                                        returns.extend(Some(v968));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v567,
                                    imm: v568,
                                } => {
                                    if let &Opcode::Iconst = v567 {
                                        let v565 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v566) = v565 {
                                            let v599 = C::u64_from_imm64(ctx, v568);
                                            let v618 = constructor_iconst_u(ctx, v566, v599);
                                            let v619 = C::subsume(ctx, v618);
                                            // Rule at src/opts/cprop.isle line 98.
                                            returns.extend(Some(v619));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sextend => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::IntCompare {
                                    opcode: ref v261,
                                    args: ref v262,
                                    cond: ref v263,
                                } => {
                                    if let &Opcode::Icmp = v261 {
                                        let v970 = constructor_uextend(ctx, v2.0, v33);
                                        // Rule at src/opts/extends.isle line 11.
                                        returns.extend(Some(v970));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    match v45 {
                                        &Opcode::Bmask => {
                                            let v295 = constructor_bmask(ctx, v2.0, v46);
                                            // Rule at src/opts/bitops.isle line 132.
                                            returns.extend(Some(v295));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Uextend => {
                                            let v968 = constructor_uextend(ctx, v2.0, v46);
                                            // Rule at src/opts/extends.isle line 7.
                                            returns.extend(Some(v968));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Sextend => {
                                            let v969 = constructor_sextend(ctx, v2.0, v46);
                                            // Rule at src/opts/extends.isle line 3.
                                            returns.extend(Some(v969));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v565 = C::fits_in_64(ctx, v2.0);
                        if let Some(v566) = v565 {
                            let mut v620 = C::inst_data_value_tupled_etor_returns::default();
                            C::inst_data_value_tupled_etor(ctx, v33, &mut v620);
                            let mut v620 = v620.into_context_iter();
                            while let Some(v621) = v620.next(ctx) {
                                let v622 = C::iconst_sextend_etor(ctx, v621);
                                if let Some(v623) = v622 {
                                    let v626 = constructor_iconst_s(ctx, v566, v623.1);
                                    let v627 = C::subsume(ctx, v626);
                                    // Rule at src/opts/cprop.isle line 100.
                                    returns.extend(Some(v627));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                            }
                        }
                    }
                    &Opcode::FcvtFromUint => {
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            match &v35.1 {
                                &InstructionData::Unary {
                                    opcode: ref v45,
                                    arg: v46,
                                } => {
                                    match v45 {
                                        &Opcode::Splat => {
                                            let v1353 = C::lane_type(ctx, v2.0);
                                            let v1467 = constructor_fcvt_from_uint(ctx, v1353, v46);
                                            let v1468 = constructor_splat(ctx, v2.0, v1467);
                                            // Rule at src/opts/vector.isle line 6.
                                            returns.extend(Some(v1468));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        &Opcode::Uextend => {
                                            let v215 = constructor_fcvt_from_uint(ctx, v2.0, v46);
                                            // Rule at src/opts/arithmetic.isle line 318.
                                            returns.extend(Some(v215));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v567,
                                    imm: v568,
                                } => {
                                    if let &Opcode::Iconst = v567 {
                                        match v2.0 {
                                            F32 => {
                                                let v599 = C::u64_from_imm64(ctx, v568);
                                                let v774 = C::f32_from_uint(ctx, v599);
                                                let v775 = constructor_f32const(ctx, F32, v774);
                                                // Rule at src/opts/cprop.isle line 287.
                                                returns.extend(Some(v775));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            F64 => {
                                                let v599 = C::u64_from_imm64(ctx, v568);
                                                let v777 = C::f64_from_uint(ctx, v599);
                                                let v778 = constructor_f64const(ctx, F64, v777);
                                                // Rule at src/opts/cprop.isle line 289.
                                                returns.extend(Some(v778));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::FcvtFromSint => {
                        match v2.0 {
                            F32 => {
                                let mut v620 = C::inst_data_value_tupled_etor_returns::default();
                                C::inst_data_value_tupled_etor(ctx, v33, &mut v620);
                                let mut v620 = v620.into_context_iter();
                                while let Some(v621) = v620.next(ctx) {
                                    let v622 = C::iconst_sextend_etor(ctx, v621);
                                    if let Some(v623) = v622 {
                                        let v779 = C::f32_from_sint(ctx, v623.1);
                                        let v780 = constructor_f32const(ctx, F32, v779);
                                        // Rule at src/opts/cprop.isle line 291.
                                        returns.extend(Some(v780));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                            F64 => {
                                let mut v620 = C::inst_data_value_tupled_etor_returns::default();
                                C::inst_data_value_tupled_etor(ctx, v33, &mut v620);
                                let mut v620 = v620.into_context_iter();
                                while let Some(v621) = v620.next(ctx) {
                                    let v622 = C::iconst_sextend_etor(ctx, v621);
                                    if let Some(v623) = v622 {
                                        let v781 = C::f64_from_sint(ctx, v623.1);
                                        let v782 = constructor_f64const(ctx, F64, v781);
                                        // Rule at src/opts/cprop.isle line 293.
                                        returns.extend(Some(v782));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                            _ => {}
                        }
                        let mut v34 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v33, &mut v34);
                        let mut v34 = v34.into_context_iter();
                        while let Some(v35) = v34.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v45,
                                arg: v46,
                            } = &v35.1 {
                                match v45 {
                                    &Opcode::Splat => {
                                        let v1353 = C::lane_type(ctx, v2.0);
                                        let v1469 = constructor_fcvt_from_sint(ctx, v1353, v46);
                                        let v1470 = constructor_splat(ctx, v2.0, v1469);
                                        // Rule at src/opts/vector.isle line 8.
                                        returns.extend(Some(v1470));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                    &Opcode::Sextend => {
                                        let v216 = constructor_fcvt_from_sint(ctx, v2.0, v46);
                                        // Rule at src/opts/arithmetic.isle line 320.
                                        returns.extend(Some(v216));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref v1201,
                imm: v1202,
            } => {
                if let &Opcode::F32const = v1201 {
                    let v1198 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 27.
                    returns.extend(Some(v1198));
                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref v1203,
                imm: v1204,
            } => {
                if let &Opcode::F64const = v1203 {
                    let v1198 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 29.
                    returns.extend(Some(v1198));
                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v1199,
                imm: v1200,
            } => {
                if let &Opcode::Iconst = v1199 {
                    let v1198 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 25.
                    returns.extend(Some(v1198));
                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                }
            }
            _ => {}
        }
    }
}

// Generated as internal constructor for term inst_to_skeleton_inst_simplification.
pub fn constructor_inst_to_skeleton_inst_simplification<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> SkeletonInstSimplification {
    let v1 = SkeletonInstSimplification::Replace {
        inst: arg0,
    };
    // Rule at src/prelude_opt.isle line 91.
    return v1;
}

// Generated as internal constructor for term value_to_skeleton_inst_simplification.
pub fn constructor_value_to_skeleton_inst_simplification<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> SkeletonInstSimplification {
    let v1 = SkeletonInstSimplification::RemoveWithVal {
        val: arg0,
    };
    // Rule at src/prelude_opt.isle line 95.
    return v1;
}

// Generated as internal constructor for term remove_inst.
pub fn constructor_remove_inst<C: Context>(
    ctx: &mut C,
) -> SkeletonInstSimplification {
    // Rule at src/prelude_opt.isle line 99.
    return SkeletonInstSimplification::Remove;
}

// Generated as internal constructor for term replace_with_val.
pub fn constructor_replace_with_val<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: Value,
) -> SkeletonInstSimplification {
    let v2 = SkeletonInstSimplification::ReplaceWithVal {
        inst: arg0,
        val: arg1,
    };
    // Rule at src/prelude_opt.isle line 102.
    return v2;
}

// Generated as internal constructor for term simplify_skeleton.
pub fn constructor_simplify_skeleton<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    returns: &mut (impl Extend<SkeletonInstSimplification> + Length),
) -> () {
    let v1 = &C::inst_data_etor(ctx, arg0);
    if let Some(v2) = v1 {
        match v2 {
            &InstructionData::Binary {
                opcode: ref v3,
                args: ref v4,
            } => {
                match v3 {
                    &Opcode::Udiv => {
                        let v5 = C::unpack_value_array_2(ctx, v4);
                        let mut v15 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v5.1, &mut v15);
                        let mut v15 = v15.into_context_iter();
                        while let Some(v16) = v15.next(ctx) {
                            match &v16.1 {
                                &InstructionData::Ternary {
                                    opcode: ref v189,
                                    args: ref v190,
                                } => {
                                    if let &Opcode::Select = v189 {
                                        let v191 = C::unpack_value_array_3(ctx, v190);
                                        let mut v195 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v191.1, &mut v195);
                                        let mut v195 = v195.into_context_iter();
                                        while let Some(v196) = v195.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v199,
                                                imm: v200,
                                            } = &v196.1 {
                                                if let &Opcode::Iconst = v199 {
                                                    let v201 = C::imm64_power_of_two(ctx, v200);
                                                    if let Some(v202) = v201 {
                                                        if v16.0 == v196.0 {
                                                            let mut v203 = C::inst_data_value_etor_returns::default();
                                                            C::inst_data_value_etor(ctx, v191.2, &mut v203);
                                                            let mut v203 = v203.into_context_iter();
                                                            while let Some(v204) = v203.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v207,
                                                                    imm: v208,
                                                                } = &v204.1 {
                                                                    if let &Opcode::Iconst = v207 {
                                                                        let v209 = C::imm64_power_of_two(ctx, v208);
                                                                        if let Some(v210) = v209 {
                                                                            if v16.0 == v204.0 {
                                                                                let v211 = C::imm64(ctx, v202);
                                                                                let v212 = constructor_iconst(ctx, v16.0, v211);
                                                                                let v213 = C::imm64(ctx, v210);
                                                                                let v214 = constructor_iconst(ctx, v16.0, v213);
                                                                                let v215 = constructor_select(ctx, v16.0, v191.0, v212, v214);
                                                                                let v216 = constructor_ushr(ctx, v16.0, v5.0, v215);
                                                                                let v217 = &constructor_value_to_skeleton_inst_simplification(ctx, v216);
                                                                                // Rule at src/opts/skeleton.isle line 40.
                                                                                returns.extend(Some(v217.clone()));
                                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v19,
                                    imm: v20,
                                } => {
                                    if let &Opcode::Iconst = v19 {
                                        match v16.0 {
                                            I32 => {
                                                let v21 = C::u64_from_imm64(ctx, v20);
                                                let v70 = C::u64_matches_non_zero(ctx, v21);
                                                if let Some(v71) = v70 {
                                                    if v71 == true {
                                                        let v72 = C::u64_from_u32(ctx, v21);
                                                        if let Some(v73) = v72 {
                                                            let v74 = C::u32_is_power_of_two(ctx, v73);
                                                            if v74 == false {
                                                                let v76 = constructor_apply_div_const_magic_u32(ctx, &Opcode::Udiv, v5.0, v73);
                                                                let v77 = &constructor_value_to_skeleton_inst_simplification(ctx, v76);
                                                                // Rule at src/opts/arithmetic.isle line 113.
                                                                returns.extend(Some(v77.clone()));
                                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            I64 => {
                                                let v21 = C::u64_from_imm64(ctx, v20);
                                                let v70 = C::u64_matches_non_zero(ctx, v21);
                                                if let Some(v71) = v70 {
                                                    if v71 == true {
                                                        let v78 = C::u64_is_power_of_two(ctx, v21);
                                                        if v78 == false {
                                                            let v79 = constructor_apply_div_const_magic_u64(ctx, &Opcode::Udiv, v5.0, v21);
                                                            let v80 = &constructor_value_to_skeleton_inst_simplification(ctx, v79);
                                                            // Rule at src/opts/arithmetic.isle line 116.
                                                            returns.extend(Some(v80.clone()));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                        let v21 = C::u64_from_imm64(ctx, v20);
                                        if v21 == 0x1_u64 {
                                            let v14 = &constructor_value_to_skeleton_inst_simplification(ctx, v5.0);
                                            // Rule at src/opts/arithmetic.isle line 79.
                                            returns.extend(Some(v14.clone()));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                        let v22 = C::u64_matches_power_of_two(ctx, v21);
                                        if let Some(v23) = v22 {
                                            if v23 == true {
                                                let v24 = C::u64_ilog2(ctx, v21);
                                                let v25 = C::u32_into_u64(ctx, v24);
                                                let v26 = constructor_iconst_u(ctx, v16.0, v25);
                                                let v27 = constructor_ushr(ctx, v16.0, v5.0, v26);
                                                let v28 = &constructor_value_to_skeleton_inst_simplification(ctx, v27);
                                                // Rule at src/opts/arithmetic.isle line 82.
                                                returns.extend(Some(v28.clone()));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                        let mut v121 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v5.0, &mut v121);
                                        let mut v121 = v121.into_context_iter();
                                        while let Some(v122) = v121.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v125,
                                                imm: v126,
                                            } = &v122.1 {
                                                if let &Opcode::Iconst = v125 {
                                                    let v135 = C::u64_from_imm64(ctx, v126);
                                                    let v136 = C::u64_checked_div(ctx, v135, v21);
                                                    if let Some(v137) = v136 {
                                                        if v16.0 == v122.0 {
                                                            let v138 = C::imm64_masked(ctx, v122.0, v137);
                                                            let v139 = constructor_iconst(ctx, v122.0, v138);
                                                            let v140 = &constructor_value_to_skeleton_inst_simplification(ctx, v139);
                                                            // Rule at src/opts/cprop.isle line 43.
                                                            returns.extend(Some(v140.clone()));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let v5 = C::unpack_value_array_2(ctx, v4);
                        let mut v8 = C::inst_data_value_tupled_etor_returns::default();
                        C::inst_data_value_tupled_etor(ctx, v5.1, &mut v8);
                        let mut v8 = v8.into_context_iter();
                        while let Some(v9) = v8.next(ctx) {
                            let v10 = C::iconst_sextend_etor(ctx, v9);
                            if let Some(v11) = v10 {
                                match v11.0 {
                                    I32 => {
                                        let v81 = C::i64_matches_non_zero(ctx, v11.1);
                                        if let Some(v82) = v81 {
                                            if v82 == true {
                                                let v83 = C::i64_from_i32(ctx, v11.1);
                                                if let Some(v84) = v83 {
                                                    let v85 = C::i32_into_i64(ctx, v84);
                                                    let v86 = constructor_i64_is_any_sign_power_of_two(ctx, v85);
                                                    if v86 == false {
                                                        let v88 = constructor_apply_div_const_magic_s32(ctx, &Opcode::Sdiv, v5.0, v84);
                                                        let v89 = &constructor_value_to_skeleton_inst_simplification(ctx, v88);
                                                        // Rule at src/opts/arithmetic.isle line 121.
                                                        returns.extend(Some(v89.clone()));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    I64 => {
                                        let v81 = C::i64_matches_non_zero(ctx, v11.1);
                                        if let Some(v82) = v81 {
                                            if v82 == true {
                                                let v90 = constructor_i64_is_any_sign_power_of_two(ctx, v11.1);
                                                if v90 == false {
                                                    let v91 = constructor_apply_div_const_magic_s64(ctx, &Opcode::Sdiv, v5.0, v11.1);
                                                    let v92 = &constructor_value_to_skeleton_inst_simplification(ctx, v91);
                                                    // Rule at src/opts/arithmetic.isle line 124.
                                                    returns.extend(Some(v92.clone()));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                                if v11.1 == 1_i64 {
                                    let v14 = &constructor_value_to_skeleton_inst_simplification(ctx, v5.0);
                                    // Rule at src/opts/arithmetic.isle line 78.
                                    returns.extend(Some(v14.clone()));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                                let v50 = constructor_i64_is_negative_power_of_two(ctx, v11.1);
                                if v50 == true {
                                    let v52 = C::i64_ne(ctx, v11.1, -1_i64);
                                    if v52 == true {
                                        let v53 = C::i64_trailing_zeros(ctx, v11.1);
                                        let v54 = C::u32_sub(ctx, v53, 0x1_u32);
                                        let v55 = C::u32_into_u64(ctx, v54);
                                        let v56 = constructor_iconst_u(ctx, v11.0, v55);
                                        let v57 = constructor_sshr(ctx, v11.0, v5.0, v56);
                                        let v58 = C::ty_bits(ctx, v11.0);
                                        let v59 = C::u8_into_u32(ctx, v58);
                                        let v60 = C::u32_sub(ctx, v59, v53);
                                        let v61 = C::u32_into_u64(ctx, v60);
                                        let v62 = constructor_iconst_u(ctx, v11.0, v61);
                                        let v63 = constructor_ushr(ctx, v11.0, v57, v62);
                                        let v64 = constructor_iadd(ctx, v11.0, v5.0, v63);
                                        let v65 = C::u32_into_i64(ctx, v53);
                                        let v66 = constructor_iconst_s(ctx, v11.0, v65);
                                        let v67 = constructor_sshr(ctx, v11.0, v64, v66);
                                        let v68 = constructor_ineg(ctx, v11.0, v67);
                                        let v69 = &constructor_value_to_skeleton_inst_simplification(ctx, v68);
                                        // Rule at src/opts/arithmetic.isle line 101.
                                        returns.extend(Some(v69.clone()));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                        let mut v15 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v5.1, &mut v15);
                        let mut v15 = v15.into_context_iter();
                        while let Some(v16) = v15.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v19,
                                imm: v20,
                            } = &v16.1 {
                                if let &Opcode::Iconst = v19 {
                                    let v21 = C::u64_from_imm64(ctx, v20);
                                    let v22 = C::u64_matches_power_of_two(ctx, v21);
                                    if let Some(v23) = v22 {
                                        if v23 == true {
                                            let v30 = C::u64_gt(ctx, v21, 0x1_u64);
                                            if v30 == true {
                                                let v31 = C::u64_trailing_zeros(ctx, v21);
                                                let v32 = C::ty_bits(ctx, v16.0);
                                                let v33 = C::u8_into_u32(ctx, v32);
                                                let v35 = C::u32_sub(ctx, v33, 0x1_u32);
                                                let v36 = C::u32_lt(ctx, v31, v35);
                                                if v36 == true {
                                                    let v37 = C::u32_sub(ctx, v31, 0x1_u32);
                                                    let v38 = C::u32_into_u64(ctx, v37);
                                                    let v39 = constructor_iconst_u(ctx, v16.0, v38);
                                                    let v40 = constructor_sshr(ctx, v16.0, v5.0, v39);
                                                    let v41 = C::u32_sub(ctx, v33, v31);
                                                    let v42 = C::u32_into_u64(ctx, v41);
                                                    let v43 = constructor_iconst_u(ctx, v16.0, v42);
                                                    let v44 = constructor_ushr(ctx, v16.0, v40, v43);
                                                    let v45 = constructor_iadd(ctx, v16.0, v5.0, v44);
                                                    let v46 = C::u32_into_i64(ctx, v31);
                                                    let v47 = constructor_iconst_s(ctx, v16.0, v46);
                                                    let v48 = constructor_sshr(ctx, v16.0, v45, v47);
                                                    let v49 = &constructor_value_to_skeleton_inst_simplification(ctx, v48);
                                                    // Rule at src/opts/arithmetic.isle line 86.
                                                    returns.extend(Some(v49.clone()));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                    let mut v121 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v5.0, &mut v121);
                                    let mut v121 = v121.into_context_iter();
                                    while let Some(v122) = v121.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v125,
                                            imm: v126,
                                        } = &v122.1 {
                                            if let &Opcode::Iconst = v125 {
                                                let v127 = C::imm64_sdiv(ctx, v122.0, v126, v20);
                                                if let Some(v128) = v127 {
                                                    if v16.0 == v122.0 {
                                                        let v129 = constructor_iconst(ctx, v122.0, v128);
                                                        let v130 = &constructor_value_to_skeleton_inst_simplification(ctx, v129);
                                                        // Rule at src/opts/cprop.isle line 31.
                                                        returns.extend(Some(v130.clone()));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Urem => {
                        let v5 = C::unpack_value_array_2(ctx, v4);
                        let mut v15 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v5.1, &mut v15);
                        let mut v15 = v15.into_context_iter();
                        while let Some(v16) = v15.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v19,
                                imm: v20,
                            } = &v16.1 {
                                if let &Opcode::Iconst = v19 {
                                    match v16.0 {
                                        I32 => {
                                            let v21 = C::u64_from_imm64(ctx, v20);
                                            let v70 = C::u64_matches_non_zero(ctx, v21);
                                            if let Some(v71) = v70 {
                                                if v71 == true {
                                                    let v72 = C::u64_from_u32(ctx, v21);
                                                    if let Some(v73) = v72 {
                                                        let v74 = C::u32_is_power_of_two(ctx, v73);
                                                        if v74 == false {
                                                            let v112 = constructor_apply_div_const_magic_u32(ctx, &Opcode::Urem, v5.0, v73);
                                                            let v113 = &constructor_value_to_skeleton_inst_simplification(ctx, v112);
                                                            // Rule at src/opts/arithmetic.isle line 156.
                                                            returns.extend(Some(v113.clone()));
                                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        I64 => {
                                            let v21 = C::u64_from_imm64(ctx, v20);
                                            let v70 = C::u64_matches_non_zero(ctx, v21);
                                            if let Some(v71) = v70 {
                                                if v71 == true {
                                                    let v78 = C::u64_is_power_of_two(ctx, v21);
                                                    if v78 == false {
                                                        let v114 = constructor_apply_div_const_magic_u64(ctx, &Opcode::Urem, v5.0, v21);
                                                        let v115 = &constructor_value_to_skeleton_inst_simplification(ctx, v114);
                                                        // Rule at src/opts/arithmetic.isle line 159.
                                                        returns.extend(Some(v115.clone()));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                    let v21 = C::u64_from_imm64(ctx, v20);
                                    if v21 == 0x1_u64 {
                                        let v94 = constructor_iconst_u(ctx, v16.0, 0x0_u64);
                                        let v95 = &constructor_value_to_skeleton_inst_simplification(ctx, v94);
                                        // Rule at src/opts/arithmetic.isle line 129.
                                        returns.extend(Some(v95.clone()));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                    let v22 = C::u64_matches_power_of_two(ctx, v21);
                                    if let Some(v23) = v22 {
                                        if v23 == true {
                                            let v30 = C::u64_gt(ctx, v21, 0x1_u64);
                                            if v30 == true {
                                                let v24 = C::u64_ilog2(ctx, v21);
                                                let v98 = C::u64_shl(ctx, 0x1_u64, v24);
                                                let v99 = C::u64_sub(ctx, v98, 0x1_u64);
                                                let v100 = constructor_iconst_u(ctx, v16.0, v99);
                                                let v101 = constructor_band(ctx, v16.0, v5.0, v100);
                                                let v102 = &constructor_value_to_skeleton_inst_simplification(ctx, v101);
                                                // Rule at src/opts/arithmetic.isle line 134.
                                                returns.extend(Some(v102.clone()));
                                                if returns.len() >= MAX_ISLE_RETURNS { return; }
                                            }
                                        }
                                    }
                                    let mut v121 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v5.0, &mut v121);
                                    let mut v121 = v121.into_context_iter();
                                    while let Some(v122) = v121.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v125,
                                            imm: v126,
                                        } = &v122.1 {
                                            if let &Opcode::Iconst = v125 {
                                                let v135 = C::u64_from_imm64(ctx, v126);
                                                let v141 = C::u64_checked_rem(ctx, v135, v21);
                                                if let Some(v142) = v141 {
                                                    if v16.0 == v122.0 {
                                                        let v143 = C::imm64_masked(ctx, v122.0, v142);
                                                        let v144 = constructor_iconst(ctx, v122.0, v143);
                                                        let v145 = &constructor_value_to_skeleton_inst_simplification(ctx, v144);
                                                        // Rule at src/opts/cprop.isle line 49.
                                                        returns.extend(Some(v145.clone()));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Srem => {
                        let v5 = C::unpack_value_array_2(ctx, v4);
                        let mut v8 = C::inst_data_value_tupled_etor_returns::default();
                        C::inst_data_value_tupled_etor(ctx, v5.1, &mut v8);
                        let mut v8 = v8.into_context_iter();
                        while let Some(v9) = v8.next(ctx) {
                            let v10 = C::iconst_sextend_etor(ctx, v9);
                            if let Some(v11) = v10 {
                                match v11.0 {
                                    I32 => {
                                        let v81 = C::i64_matches_non_zero(ctx, v11.1);
                                        if let Some(v82) = v81 {
                                            if v82 == true {
                                                let v83 = C::i64_from_i32(ctx, v11.1);
                                                if let Some(v84) = v83 {
                                                    let v85 = C::i32_into_i64(ctx, v84);
                                                    let v86 = constructor_i64_is_any_sign_power_of_two(ctx, v85);
                                                    if v86 == false {
                                                        let v117 = constructor_apply_div_const_magic_s32(ctx, &Opcode::Srem, v5.0, v84);
                                                        let v118 = &constructor_value_to_skeleton_inst_simplification(ctx, v117);
                                                        // Rule at src/opts/arithmetic.isle line 164.
                                                        returns.extend(Some(v118.clone()));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    I64 => {
                                        let v81 = C::i64_matches_non_zero(ctx, v11.1);
                                        if let Some(v82) = v81 {
                                            if v82 == true {
                                                let v90 = constructor_i64_is_any_sign_power_of_two(ctx, v11.1);
                                                if v90 == false {
                                                    let v119 = constructor_apply_div_const_magic_s64(ctx, &Opcode::Srem, v5.0, v11.1);
                                                    let v120 = &constructor_value_to_skeleton_inst_simplification(ctx, v119);
                                                    // Rule at src/opts/arithmetic.isle line 167.
                                                    returns.extend(Some(v120.clone()));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                                if v11.1 == -1_i64 {
                                    let v96 = constructor_iconst_u(ctx, v11.0, 0x0_u64);
                                    let v97 = &constructor_value_to_skeleton_inst_simplification(ctx, v96);
                                    // Rule at src/opts/arithmetic.isle line 131.
                                    returns.extend(Some(v97.clone()));
                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                }
                                let v52 = C::i64_ne(ctx, v11.1, -1_i64);
                                if v52 == true {
                                    let v90 = constructor_i64_is_any_sign_power_of_two(ctx, v11.1);
                                    if v90 == true {
                                        let v104 = C::i64_ne(ctx, v11.1, 1_i64);
                                        if v104 == true {
                                            let v53 = C::i64_trailing_zeros(ctx, v11.1);
                                            let v54 = C::u32_sub(ctx, v53, 0x1_u32);
                                            let v55 = C::u32_into_u64(ctx, v54);
                                            let v56 = constructor_iconst_u(ctx, v11.0, v55);
                                            let v57 = constructor_sshr(ctx, v11.0, v5.0, v56);
                                            let v58 = C::ty_bits(ctx, v11.0);
                                            let v59 = C::u8_into_u32(ctx, v58);
                                            let v60 = C::u32_sub(ctx, v59, v53);
                                            let v61 = C::u32_into_u64(ctx, v60);
                                            let v62 = constructor_iconst_u(ctx, v11.0, v61);
                                            let v63 = constructor_ushr(ctx, v11.0, v57, v62);
                                            let v64 = constructor_iadd(ctx, v11.0, v5.0, v63);
                                            let v105 = C::i64_shl(ctx, 1_i64, v53);
                                            let v106 = C::i64_wrapping_neg(ctx, v105);
                                            let v107 = constructor_iconst_s(ctx, v11.0, v106);
                                            let v108 = constructor_band(ctx, v11.0, v64, v107);
                                            let v109 = constructor_isub(ctx, v11.0, v5.0, v108);
                                            let v110 = &constructor_value_to_skeleton_inst_simplification(ctx, v109);
                                            // Rule at src/opts/arithmetic.isle line 141.
                                            returns.extend(Some(v110.clone()));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                        let mut v15 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v5.1, &mut v15);
                        let mut v15 = v15.into_context_iter();
                        while let Some(v16) = v15.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v19,
                                imm: v20,
                            } = &v16.1 {
                                if let &Opcode::Iconst = v19 {
                                    let v21 = C::u64_from_imm64(ctx, v20);
                                    if v21 == 0x1_u64 {
                                        let v94 = constructor_iconst_u(ctx, v16.0, 0x0_u64);
                                        let v95 = &constructor_value_to_skeleton_inst_simplification(ctx, v94);
                                        // Rule at src/opts/arithmetic.isle line 130.
                                        returns.extend(Some(v95.clone()));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                    let mut v121 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v5.0, &mut v121);
                                    let mut v121 = v121.into_context_iter();
                                    while let Some(v122) = v121.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v125,
                                            imm: v126,
                                        } = &v122.1 {
                                            if let &Opcode::Iconst = v125 {
                                                let v131 = C::imm64_srem(ctx, v122.0, v126, v20);
                                                if let Some(v132) = v131 {
                                                    if v16.0 == v122.0 {
                                                        let v133 = constructor_iconst(ctx, v122.0, v132);
                                                        let v134 = &constructor_value_to_skeleton_inst_simplification(ctx, v133);
                                                        // Rule at src/opts/cprop.isle line 37.
                                                        returns.extend(Some(v134.clone()));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::CondTrap {
                opcode: ref v146,
                arg: v147,
                code: ref v148,
            } => {
                match v146 {
                    &Opcode::Trapz => {
                        let mut v149 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v147, &mut v149);
                        let mut v149 = v149.into_context_iter();
                        while let Some(v150) = v149.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v153,
                                imm: v154,
                            } = &v150.1 {
                                if let &Opcode::Iconst = v153 {
                                    let v155 = C::u64_from_imm64(ctx, v154);
                                    let v156 = C::u64_matches_non_zero(ctx, v155);
                                    if let Some(v157) = v156 {
                                        if v157 == true {
                                            let v158 = &constructor_remove_inst(ctx);
                                            // Rule at src/opts/skeleton.isle line 6.
                                            returns.extend(Some(v158.clone()));
                                            if returns.len() >= MAX_ISLE_RETURNS { return; }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Trapnz => {
                        let mut v149 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v147, &mut v149);
                        let mut v149 = v149.into_context_iter();
                        while let Some(v150) = v149.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v153,
                                imm: v154,
                            } = &v150.1 {
                                if let &Opcode::Iconst = v153 {
                                    let v155 = C::u64_from_imm64(ctx, v154);
                                    if v155 == 0x0_u64 {
                                        let v158 = &constructor_remove_inst(ctx);
                                        // Rule at src/opts/skeleton.isle line 8.
                                        returns.extend(Some(v158.clone()));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntAddTrap {
                opcode: ref v159,
                args: ref v160,
                code: ref v161,
            } => {
                if let &Opcode::UaddOverflowTrap = v159 {
                    let v162 = C::unpack_value_array_2(ctx, v160);
                    let mut v165 = C::inst_data_value_etor_returns::default();
                    C::inst_data_value_etor(ctx, v162.0, &mut v165);
                    let mut v165 = v165.into_context_iter();
                    while let Some(v166) = v165.next(ctx) {
                        match &v166.1 {
                            &InstructionData::Unary {
                                opcode: ref v183,
                                arg: v184,
                            } => {
                                if let &Opcode::Uextend = v183 {
                                    let mut v172 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v162.1, &mut v172);
                                    let mut v172 = v172.into_context_iter();
                                    while let Some(v173) = v172.next(ctx) {
                                        if let &InstructionData::Unary {
                                            opcode: ref v185,
                                            arg: v186,
                                        } = &v173.1 {
                                            if let &Opcode::Uextend = v185 {
                                                if v166.0 == v173.0 {
                                                    let v187 = constructor_iadd(ctx, v166.0, v162.0, v162.1);
                                                    let v188 = &constructor_value_to_skeleton_inst_simplification(ctx, v187);
                                                    // Rule at src/opts/skeleton.isle line 17.
                                                    returns.extend(Some(v188.clone()));
                                                    if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            &InstructionData::UnaryImm {
                                opcode: ref v169,
                                imm: v170,
                            } => {
                                if let &Opcode::Iconst = v169 {
                                    let mut v172 = C::inst_data_value_etor_returns::default();
                                    C::inst_data_value_etor(ctx, v162.1, &mut v172);
                                    let mut v172 = v172.into_context_iter();
                                    while let Some(v173) = v172.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v176,
                                            imm: v177,
                                        } = &v173.1 {
                                            if let &Opcode::Iconst = v176 {
                                                let v171 = C::u64_from_imm64(ctx, v170);
                                                let v178 = C::u64_from_imm64(ctx, v177);
                                                let v179 = C::checked_add_with_type(ctx, v166.0, v171, v178);
                                                if let Some(v180) = v179 {
                                                    if v166.0 == v173.0 {
                                                        let v181 = constructor_iconst_u(ctx, v166.0, v180);
                                                        let v182 = &constructor_value_to_skeleton_inst_simplification(ctx, v181);
                                                        // Rule at src/opts/skeleton.isle line 12.
                                                        returns.extend(Some(v182.clone()));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            _ => {}
        }
    }
}

// Generated as internal constructor for term iconst_s.
pub fn constructor_iconst_s<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: i64,
) -> Value {
    if arg0 == I128 {
        let v11 = constructor_iconst_s(ctx, I64, arg1);
        let v12 = constructor_sextend(ctx, I128, v11);
        // Rule at src/prelude_opt.isle line 141.
        return v12;
    }
    let v2 = C::i64_cast_unsigned(ctx, arg1);
    let v3 = C::ty_umax(ctx, arg0);
    let v4 = C::u64_and(ctx, v2, v3);
    let v5 = C::i64_sextend_u64(ctx, arg0, v4);
    let v6 = C::i64_eq(ctx, arg1, v5);
    if v6 == true {
        let v7 = C::imm64(ctx, v4);
        let v8 = constructor_iconst(ctx, arg0, v7);
        // Rule at src/prelude_opt.isle line 135.
        return v8;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "iconst_s", "src/prelude_opt.isle line 133")
}

// Generated as internal constructor for term iconst_u.
pub fn constructor_iconst_u<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
) -> Value {
    if arg0 == I128 {
        let v8 = constructor_iconst_u(ctx, I64, arg1);
        let v9 = constructor_uextend(ctx, I128, v8);
        // Rule at src/prelude_opt.isle line 154.
        return v9;
    }
    let v2 = C::ty_umax(ctx, arg0);
    let v3 = C::u64_lt_eq(ctx, arg1, v2);
    if v3 == true {
        let v4 = C::imm64(ctx, arg1);
        let v5 = constructor_iconst(ctx, arg0, v4);
        // Rule at src/prelude_opt.isle line 151.
        return v5;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "iconst_u", "src/prelude_opt.isle line 149")
}

// Generated as internal constructor for term uextend_maybe.
pub fn constructor_uextend_maybe<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = C::value_type(ctx, arg1);
    if arg0 == v3 {
        // Rule at src/prelude_opt.isle line 174.
        return arg1;
    }
    let v2 = constructor_uextend(ctx, arg0, arg1);
    // Rule at src/prelude_opt.isle line 173.
    return v2;
}

// Generated as internal constructor for term sextend_maybe.
pub fn constructor_sextend_maybe<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = C::value_type(ctx, arg1);
    if arg0 == v3 {
        // Rule at src/prelude_opt.isle line 180.
        return arg1;
    }
    let v2 = constructor_sextend(ctx, arg0, arg1);
    // Rule at src/prelude_opt.isle line 179.
    return v2;
}

// Generated as internal constructor for term eq.
pub fn constructor_eq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg1, arg2);
    // Rule at src/prelude_opt.isle line 38.
    return v4;
}

// Generated as internal constructor for term ne.
pub fn constructor_ne<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 39.
    return v4;
}

// Generated as internal constructor for term ult.
pub fn constructor_ult<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 40.
    return v4;
}

// Generated as internal constructor for term ule.
pub fn constructor_ule<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 41.
    return v4;
}

// Generated as internal constructor for term ugt.
pub fn constructor_ugt<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 42.
    return v4;
}

// Generated as internal constructor for term uge.
pub fn constructor_uge<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 43.
    return v4;
}

// Generated as internal constructor for term slt.
pub fn constructor_slt<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 44.
    return v4;
}

// Generated as internal constructor for term sle.
pub fn constructor_sle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 45.
    return v4;
}

// Generated as internal constructor for term sgt.
pub fn constructor_sgt<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 46.
    return v4;
}

// Generated as internal constructor for term sge.
pub fn constructor_sge<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 47.
    return v4;
}

// Generated as internal constructor for term i64_is_negative_power_of_two.
pub fn constructor_i64_is_negative_power_of_two<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> bool {
    let v1 = C::i64_wrapping_neg(ctx, arg0);
    let v2 = C::i64_cast_unsigned(ctx, v1);
    let v3 = C::u64_is_power_of_two(ctx, v2);
    // Rule at src/prelude_opt.isle line 217.
    return v3;
}

// Generated as internal constructor for term i64_is_any_sign_power_of_two.
pub fn constructor_i64_is_any_sign_power_of_two<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> bool {
    let v1 = C::i64_cast_unsigned(ctx, arg0);
    let v2 = C::u64_is_power_of_two(ctx, v1);
    if v2 == true {
        let v3 = true;
        // Rule at src/prelude_opt.isle line 221.
        return v3;
    }
    let v4 = constructor_i64_is_negative_power_of_two(ctx, arg0);
    if v4 == true {
        let v3 = true;
        // Rule at src/prelude_opt.isle line 224.
        return v3;
    }
    let v5 = false;
    // Rule at src/prelude_opt.isle line 227.
    return v5;
}

// Generated as internal constructor for term apply_div_const_magic_u32.
pub fn constructor_apply_div_const_magic_u32<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u32,
) -> Value {
    let v3 = &C::div_const_magic_u32(ctx, arg2);
    let v4 = constructor_apply_div_const_magic_u32_inner(ctx, arg0, arg1, arg2, v3);
    // Rule at src/prelude_opt.isle line 256.
    return v4;
}

// Generated as internal constructor for term apply_div_const_magic_u32_inner.
pub fn constructor_apply_div_const_magic_u32_inner<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u32,
    arg3: &DivConstMagicU32,
) -> Value {
    if let &DivConstMagicU32::U32 {
        mul_by: v4,
        do_add: v5,
        shift_by: v6,
    } = arg3 {
        let v8 = C::u32_into_u64(ctx, v4);
        let v9 = constructor_iconst_u(ctx, I32, v8);
        let v10 = constructor_umulhi(ctx, I32, arg1, v9);
        let v11 = constructor_apply_div_const_magic_u32_maybe_add(ctx, arg0, arg1, arg2, arg3, v10);
        // Rule at src/prelude_opt.isle line 261.
        return v11;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u32_inner", "src/prelude_opt.isle line 260")
}

// Generated as internal constructor for term apply_div_const_magic_u32_maybe_add.
pub fn constructor_apply_div_const_magic_u32_maybe_add<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u32,
    arg3: &DivConstMagicU32,
    arg4: Value,
) -> Value {
    if let &DivConstMagicU32::U32 {
        mul_by: v4,
        do_add: v5,
        shift_by: v6,
    } = arg3 {
        match v5 {
            false => {
                let v15 = C::u32_into_u64(ctx, v6);
                let v16 = constructor_iconst_u(ctx, I32, v15);
                let v17 = constructor_ushr(ctx, I32, arg4, v16);
                let v18 = constructor_apply_div_const_magic_u32_finish(ctx, arg0, arg1, arg2, v17);
                // Rule at src/prelude_opt.isle line 286.
                return v18;
            }
            true => {
                let v9 = constructor_isub(ctx, I32, arg1, arg4);
                let v11 = constructor_iconst_u(ctx, I32, 0x1_u64);
                let v12 = constructor_ushr(ctx, I32, v9, v11);
                let v13 = constructor_iadd(ctx, I32, arg4, v12);
                let v14 = constructor_apply_div_const_magic_u32_maybe_shift(ctx, arg0, arg1, arg2, arg3, v13);
                // Rule at src/prelude_opt.isle line 277.
                return v14;
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u32_maybe_add", "src/prelude_opt.isle line 276")
}

// Generated as internal constructor for term apply_div_const_magic_u32_maybe_shift.
pub fn constructor_apply_div_const_magic_u32_maybe_shift<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u32,
    arg3: &DivConstMagicU32,
    arg4: Value,
) -> Value {
    if let &DivConstMagicU32::U32 {
        mul_by: v4,
        do_add: v5,
        shift_by: v6,
    } = arg3 {
        if v6 == 0x0_u32 {
            let v8 = constructor_apply_div_const_magic_u32_finish(ctx, arg0, arg1, arg2, arg4);
            // Rule at src/prelude_opt.isle line 300.
            return v8;
        }
        let v9 = C::u32_matches_non_zero(ctx, v6);
        if let Some(v10) = v9 {
            if v10 == true {
                let v13 = C::u32_sub(ctx, v6, 0x1_u32);
                let v14 = C::u32_into_u64(ctx, v13);
                let v15 = constructor_iconst_u(ctx, I32, v14);
                let v16 = constructor_ushr(ctx, I32, arg4, v15);
                let v17 = constructor_apply_div_const_magic_u32_finish(ctx, arg0, arg1, arg2, v16);
                // Rule at src/prelude_opt.isle line 306.
                return v17;
            }
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u32_maybe_shift", "src/prelude_opt.isle line 299")
}

// Generated as internal constructor for term apply_div_const_magic_u32_finish.
pub fn constructor_apply_div_const_magic_u32_finish<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u32,
    arg3: Value,
) -> Value {
    match arg0 {
        &Opcode::Udiv => {
            // Rule at src/prelude_opt.isle line 326.
            return arg3;
        }
        &Opcode::Urem => {
            let v5 = C::u32_into_u64(ctx, arg2);
            let v6 = constructor_iconst_u(ctx, I32, v5);
            let v7 = constructor_imul(ctx, I32, arg3, v6);
            let v8 = constructor_isub(ctx, I32, arg1, v7);
            // Rule at src/prelude_opt.isle line 327.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u32_finish", "src/prelude_opt.isle line 325")
}

// Generated as internal constructor for term apply_div_const_magic_u64.
pub fn constructor_apply_div_const_magic_u64<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u64,
) -> Value {
    let v3 = &C::div_const_magic_u64(ctx, arg2);
    let v4 = constructor_apply_div_const_magic_u64_inner(ctx, arg0, arg1, arg2, v3);
    // Rule at src/prelude_opt.isle line 333.
    return v4;
}

// Generated as internal constructor for term apply_div_const_magic_u64_inner.
pub fn constructor_apply_div_const_magic_u64_inner<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u64,
    arg3: &DivConstMagicU64,
) -> Value {
    if let &DivConstMagicU64::U64 {
        mul_by: v4,
        do_add: v5,
        shift_by: v6,
    } = arg3 {
        let v8 = constructor_iconst_u(ctx, I64, v4);
        let v9 = constructor_umulhi(ctx, I64, arg1, v8);
        let v10 = constructor_apply_div_const_magic_u64_maybe_add(ctx, arg0, arg1, arg2, arg3, v9);
        // Rule at src/prelude_opt.isle line 338.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u64_inner", "src/prelude_opt.isle line 337")
}

// Generated as internal constructor for term apply_div_const_magic_u64_maybe_add.
pub fn constructor_apply_div_const_magic_u64_maybe_add<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u64,
    arg3: &DivConstMagicU64,
    arg4: Value,
) -> Value {
    if let &DivConstMagicU64::U64 {
        mul_by: v4,
        do_add: v5,
        shift_by: v6,
    } = arg3 {
        match v5 {
            false => {
                let v15 = C::u32_into_u64(ctx, v6);
                let v16 = constructor_iconst_u(ctx, I64, v15);
                let v17 = constructor_ushr(ctx, I64, arg4, v16);
                let v18 = constructor_apply_div_const_magic_u64_finish(ctx, arg0, arg1, arg2, v17);
                // Rule at src/prelude_opt.isle line 363.
                return v18;
            }
            true => {
                let v9 = constructor_isub(ctx, I64, arg1, arg4);
                let v11 = constructor_iconst_u(ctx, I64, 0x1_u64);
                let v12 = constructor_ushr(ctx, I64, v9, v11);
                let v13 = constructor_iadd(ctx, I64, arg4, v12);
                let v14 = constructor_apply_div_const_magic_u64_maybe_shift(ctx, arg0, arg1, arg2, arg3, v13);
                // Rule at src/prelude_opt.isle line 354.
                return v14;
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u64_maybe_add", "src/prelude_opt.isle line 353")
}

// Generated as internal constructor for term apply_div_const_magic_u64_maybe_shift.
pub fn constructor_apply_div_const_magic_u64_maybe_shift<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u64,
    arg3: &DivConstMagicU64,
    arg4: Value,
) -> Value {
    if let &DivConstMagicU64::U64 {
        mul_by: v4,
        do_add: v5,
        shift_by: v6,
    } = arg3 {
        if v6 == 0x0_u32 {
            let v8 = constructor_apply_div_const_magic_u64_finish(ctx, arg0, arg1, arg2, arg4);
            // Rule at src/prelude_opt.isle line 377.
            return v8;
        }
        let v9 = C::u32_matches_non_zero(ctx, v6);
        if let Some(v10) = v9 {
            if v10 == true {
                let v12 = C::u32_into_u64(ctx, v6);
                let v14 = C::u64_sub(ctx, v12, 0x1_u64);
                let v15 = constructor_iconst_u(ctx, I64, v14);
                let v16 = constructor_ushr(ctx, I64, arg4, v15);
                let v17 = constructor_apply_div_const_magic_u64_finish(ctx, arg0, arg1, arg2, v16);
                // Rule at src/prelude_opt.isle line 383.
                return v17;
            }
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u64_maybe_shift", "src/prelude_opt.isle line 376")
}

// Generated as internal constructor for term apply_div_const_magic_u64_finish.
pub fn constructor_apply_div_const_magic_u64_finish<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: u64,
    arg3: Value,
) -> Value {
    match arg0 {
        &Opcode::Udiv => {
            // Rule at src/prelude_opt.isle line 403.
            return arg3;
        }
        &Opcode::Urem => {
            let v5 = constructor_iconst_u(ctx, I64, arg2);
            let v6 = constructor_imul(ctx, I64, arg3, v5);
            let v7 = constructor_isub(ctx, I64, arg1, v6);
            // Rule at src/prelude_opt.isle line 404.
            return v7;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_u64_finish", "src/prelude_opt.isle line 402")
}

// Generated as internal constructor for term apply_div_const_magic_s32.
pub fn constructor_apply_div_const_magic_s32<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i32,
) -> Value {
    let v3 = &C::div_const_magic_s32(ctx, arg2);
    let v4 = constructor_apply_div_const_magic_s32_inner(ctx, arg0, arg1, arg2, v3);
    // Rule at src/prelude_opt.isle line 411.
    return v4;
}

// Generated as internal constructor for term apply_div_const_magic_s32_inner.
pub fn constructor_apply_div_const_magic_s32_inner<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i32,
    arg3: &DivConstMagicS32,
) -> Value {
    if let &DivConstMagicS32::S32 {
        mul_by: v4,
        shift_by: v5,
    } = arg3 {
        let v7 = C::i32_into_i64(ctx, v4);
        let v8 = constructor_iconst_s(ctx, I32, v7);
        let v9 = constructor_smulhi(ctx, I32, arg1, v8);
        let v10 = constructor_apply_div_const_magic_s32_add_sub(ctx, arg0, arg1, arg2, arg3, v9);
        // Rule at src/prelude_opt.isle line 417.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_s32_inner", "src/prelude_opt.isle line 416")
}

// Generated as internal constructor for term apply_div_const_magic_s32_add_sub.
pub fn constructor_apply_div_const_magic_s32_add_sub<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i32,
    arg3: &DivConstMagicS32,
    arg4: Value,
) -> Value {
    if let &DivConstMagicS32::S32 {
        mul_by: v4,
        shift_by: v5,
    } = arg3 {
        let v8 = C::i32_gt(ctx, arg2, 0_i32);
        if v8 == true {
            let v9 = C::i32_lt(ctx, v4, 0_i32);
            if v9 == true {
                let v11 = constructor_iadd(ctx, I32, arg4, arg1);
                let v12 = constructor_apply_div_const_magic_s32_shift(ctx, arg0, arg1, arg2, arg3, v11);
                // Rule at src/prelude_opt.isle line 433.
                return v12;
            }
        }
        let v13 = C::i32_lt(ctx, arg2, 0_i32);
        if v13 == true {
            let v14 = C::i32_gt(ctx, v4, 0_i32);
            if v14 == true {
                let v15 = constructor_isub(ctx, I32, arg4, arg1);
                let v16 = constructor_apply_div_const_magic_s32_shift(ctx, arg0, arg1, arg2, arg3, v15);
                // Rule at src/prelude_opt.isle line 442.
                return v16;
            }
        }
    }
    let v17 = constructor_apply_div_const_magic_s32_shift(ctx, arg0, arg1, arg2, arg3, arg4);
    // Rule at src/prelude_opt.isle line 451.
    return v17;
}

// Generated as internal constructor for term apply_div_const_magic_s32_shift.
pub fn constructor_apply_div_const_magic_s32_shift<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i32,
    arg3: &DivConstMagicS32,
    arg4: Value,
) -> Value {
    if let &DivConstMagicS32::S32 {
        mul_by: v4,
        shift_by: v5,
    } = arg3 {
        let v8 = C::u32_into_i64(ctx, v5);
        let v9 = constructor_iconst_s(ctx, I32, v8);
        let v10 = constructor_sshr(ctx, I32, arg4, v9);
        let v12 = constructor_iconst_s(ctx, I32, 31_i64);
        let v13 = constructor_ushr(ctx, I32, v10, v12);
        let v14 = constructor_iadd(ctx, I32, v10, v13);
        let v15 = constructor_apply_div_const_magic_s32_finish(ctx, arg0, arg1, arg2, v14);
        // Rule at src/prelude_opt.isle line 462.
        return v15;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_s32_shift", "src/prelude_opt.isle line 461")
}

// Generated as internal constructor for term apply_div_const_magic_s32_finish.
pub fn constructor_apply_div_const_magic_s32_finish<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i32,
    arg3: Value,
) -> Value {
    match arg0 {
        &Opcode::Sdiv => {
            // Rule at src/prelude_opt.isle line 486.
            return arg3;
        }
        &Opcode::Srem => {
            let v5 = C::i32_into_i64(ctx, arg2);
            let v6 = constructor_iconst_s(ctx, I32, v5);
            let v7 = constructor_imul(ctx, I32, arg3, v6);
            let v8 = constructor_isub(ctx, I32, arg1, v7);
            // Rule at src/prelude_opt.isle line 483.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_s32_finish", "src/prelude_opt.isle line 482")
}

// Generated as internal constructor for term apply_div_const_magic_s64.
pub fn constructor_apply_div_const_magic_s64<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i64,
) -> Value {
    let v3 = &C::div_const_magic_s64(ctx, arg2);
    let v4 = constructor_apply_div_const_magic_s64_inner(ctx, arg0, arg1, arg2, v3);
    // Rule at src/prelude_opt.isle line 492.
    return v4;
}

// Generated as internal constructor for term apply_div_const_magic_s64_inner.
pub fn constructor_apply_div_const_magic_s64_inner<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i64,
    arg3: &DivConstMagicS64,
) -> Value {
    if let &DivConstMagicS64::S64 {
        mul_by: v4,
        shift_by: v5,
    } = arg3 {
        let v7 = constructor_iconst_s(ctx, I64, v4);
        let v8 = constructor_smulhi(ctx, I64, arg1, v7);
        let v9 = constructor_apply_div_const_magic_s64_add_sub(ctx, arg0, arg1, arg2, arg3, v8);
        // Rule at src/prelude_opt.isle line 498.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_s64_inner", "src/prelude_opt.isle line 497")
}

// Generated as internal constructor for term apply_div_const_magic_s64_add_sub.
pub fn constructor_apply_div_const_magic_s64_add_sub<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i64,
    arg3: &DivConstMagicS64,
    arg4: Value,
) -> Value {
    if let &DivConstMagicS64::S64 {
        mul_by: v4,
        shift_by: v5,
    } = arg3 {
        let v8 = C::i64_gt(ctx, arg2, 0_i64);
        if v8 == true {
            let v9 = C::i64_lt(ctx, v4, 0_i64);
            if v9 == true {
                let v11 = constructor_iadd(ctx, I64, arg4, arg1);
                let v12 = constructor_apply_div_const_magic_s64_shift(ctx, arg0, arg1, arg2, arg3, v11);
                // Rule at src/prelude_opt.isle line 514.
                return v12;
            }
        }
        let v13 = C::i64_lt(ctx, arg2, 0_i64);
        if v13 == true {
            let v14 = C::i64_gt(ctx, v4, 0_i64);
            if v14 == true {
                let v15 = constructor_isub(ctx, I64, arg4, arg1);
                let v16 = constructor_apply_div_const_magic_s64_shift(ctx, arg0, arg1, arg2, arg3, v15);
                // Rule at src/prelude_opt.isle line 523.
                return v16;
            }
        }
    }
    let v17 = constructor_apply_div_const_magic_s64_shift(ctx, arg0, arg1, arg2, arg3, arg4);
    // Rule at src/prelude_opt.isle line 532.
    return v17;
}

// Generated as internal constructor for term apply_div_const_magic_s64_shift.
pub fn constructor_apply_div_const_magic_s64_shift<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i64,
    arg3: &DivConstMagicS64,
    arg4: Value,
) -> Value {
    if let &DivConstMagicS64::S64 {
        mul_by: v4,
        shift_by: v5,
    } = arg3 {
        let v8 = C::u32_into_i64(ctx, v5);
        let v9 = constructor_iconst_s(ctx, I64, v8);
        let v10 = constructor_sshr(ctx, I64, arg4, v9);
        let v12 = constructor_iconst_s(ctx, I64, 63_i64);
        let v13 = constructor_ushr(ctx, I64, v10, v12);
        let v14 = constructor_iadd(ctx, I64, v10, v13);
        let v15 = constructor_apply_div_const_magic_s64_finish(ctx, arg0, arg1, arg2, v14);
        // Rule at src/prelude_opt.isle line 543.
        return v15;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_s64_shift", "src/prelude_opt.isle line 542")
}

// Generated as internal constructor for term apply_div_const_magic_s64_finish.
pub fn constructor_apply_div_const_magic_s64_finish<C: Context>(
    ctx: &mut C,
    arg0: &Opcode,
    arg1: Value,
    arg2: i64,
    arg3: Value,
) -> Value {
    match arg0 {
        &Opcode::Sdiv => {
            // Rule at src/prelude_opt.isle line 567.
            return arg3;
        }
        &Opcode::Srem => {
            let v5 = constructor_iconst_s(ctx, I64, arg2);
            let v6 = constructor_imul(ctx, I64, arg3, v5);
            let v7 = constructor_isub(ctx, I64, arg1, v6);
            // Rule at src/prelude_opt.isle line 564.
            return v7;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "apply_div_const_magic_s64_finish", "src/prelude_opt.isle line 563")
}

// Generated as internal constructor for term truthy.
pub fn constructor_truthy<C: Context>(
    ctx: &mut C,
    arg0: Value,
    returns: &mut (impl Extend<Value> + Length),
) -> () {
    let mut v1 = C::inst_data_value_etor_returns::default();
    C::inst_data_value_etor(ctx, arg0, &mut v1);
    let mut v1 = v1.into_context_iter();
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v7,
                args: ref v8,
            } => {
                match v7 {
                    &Opcode::Rotl => {
                        let v9 = C::unpack_value_array_2(ctx, v8);
                        // Rule at src/opts/bitops.isle line 111.
                        returns.extend(Some(v9.0));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Rotr => {
                        let v9 = C::unpack_value_array_2(ctx, v8);
                        // Rule at src/opts/bitops.isle line 112.
                        returns.extend(Some(v9.0));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v34,
                args: ref v35,
                cond: ref v36,
            } => {
                if let &Opcode::Icmp = v34 {
                    if let &IntCC::NotEqual = v36 {
                        let v37 = C::unpack_value_array_2(ctx, v35);
                        let mut v40 = C::inst_data_value_etor_returns::default();
                        C::inst_data_value_etor(ctx, v37.1, &mut v40);
                        let mut v40 = v40.into_context_iter();
                        while let Some(v41) = v40.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v44,
                                imm: v45,
                            } = &v41.1 {
                                if let &Opcode::Iconst = v44 {
                                    let v46 = C::u64_from_imm64(ctx, v45);
                                    if v46 == 0x0_u64 {
                                        // Rule at src/opts/bitops.isle line 115.
                                        returns.extend(Some(v37.0));
                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v12,
                args: ref v13,
            } => {
                if let &Opcode::Select = v12 {
                    let v14 = C::unpack_value_array_3(ctx, v13);
                    let mut v18 = C::inst_data_value_etor_returns::default();
                    C::inst_data_value_etor(ctx, v14.1, &mut v18);
                    let mut v18 = v18.into_context_iter();
                    while let Some(v19) = v18.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v22,
                            imm: v23,
                        } = &v19.1 {
                            if let &Opcode::Iconst = v22 {
                                let v24 = C::u64_from_imm64(ctx, v23);
                                let v25 = C::u64_matches_non_zero(ctx, v24);
                                if let Some(v26) = v25 {
                                    if v26 == true {
                                        let mut v27 = C::inst_data_value_etor_returns::default();
                                        C::inst_data_value_etor(ctx, v14.2, &mut v27);
                                        let mut v27 = v27.into_context_iter();
                                        while let Some(v28) = v27.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v31,
                                                imm: v32,
                                            } = &v28.1 {
                                                if let &Opcode::Iconst = v31 {
                                                    let v33 = C::u64_from_imm64(ctx, v32);
                                                    if v33 == 0x0_u64 {
                                                        // Rule at src/opts/bitops.isle line 113.
                                                        returns.extend(Some(v14.0));
                                                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &InstructionData::Unary {
                opcode: ref v5,
                arg: v6,
            } => {
                match v5 {
                    &Opcode::Ineg => {
                        // Rule at src/opts/bitops.isle line 107.
                        returns.extend(Some(v6));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Bitrev => {
                        // Rule at src/opts/bitops.isle line 109.
                        returns.extend(Some(v6));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Bswap => {
                        // Rule at src/opts/bitops.isle line 108.
                        returns.extend(Some(v6));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Popcnt => {
                        // Rule at src/opts/bitops.isle line 110.
                        returns.extend(Some(v6));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Bmask => {
                        // Rule at src/opts/bitops.isle line 106.
                        returns.extend(Some(v6));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Uextend => {
                        // Rule at src/opts/bitops.isle line 105.
                        returns.extend(Some(v6));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    &Opcode::Sextend => {
                        // Rule at src/opts/bitops.isle line 104.
                        returns.extend(Some(v6));
                        if returns.len() >= MAX_ISLE_RETURNS { return; }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }
}

// Generated as internal constructor for term splat8.
pub fn constructor_splat8<C: Context>(
    ctx: &mut C,
    arg0: u64,
) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x8_u32);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat16(ctx, v3);
    // Rule at src/opts/cprop.isle line 240.
    return v4;
}

// Generated as internal constructor for term splat16.
pub fn constructor_splat16<C: Context>(
    ctx: &mut C,
    arg0: u64,
) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x10_u32);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat32(ctx, v3);
    // Rule at src/opts/cprop.isle line 242.
    return v4;
}

// Generated as internal constructor for term splat32.
pub fn constructor_splat32<C: Context>(
    ctx: &mut C,
    arg0: u64,
) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x20_u32);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = C::splat64(ctx, v3);
    // Rule at src/opts/cprop.isle line 244.
    return v4;
}

// Generated as internal constructor for term intcc_comparable.
pub fn constructor_intcc_comparable<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: &IntCC,
) -> Option<bool> {
    let v2 = constructor_intcc_class(ctx, arg0);
    let v3 = constructor_intcc_class(ctx, arg1);
    let v4 = C::u64_and(ctx, v2, v3);
    let v5 = C::u64_matches_non_zero(ctx, v4);
    if let Some(v6) = v5 {
        if v6 == true {
            let v8 = C::u64_eq(ctx, 0x2_u64, v4);
            let v9 = Some(v8);
            // Rule at src/opts/icmp.isle line 204.
            return v9;
        }
    }
    None
}

// Generated as internal constructor for term decompose_intcc.
pub fn constructor_decompose_intcc<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 209.
            return 0x1_u64;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 218.
            return 0x6_u64;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 215.
            return 0x4_u64;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 217.
            return 0x5_u64;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 211.
            return 0x2_u64;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 213.
            return 0x3_u64;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 214.
            return 0x4_u64;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 216.
            return 0x5_u64;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 210.
            return 0x2_u64;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 212.
            return 0x3_u64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "decompose_intcc", "src/opts/icmp.isle line 208")
}

// Generated as internal constructor for term compose_icmp.
pub fn constructor_compose_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
    arg2: bool,
    arg3: Value,
    arg4: Value,
) -> Value {
    match arg1 {
        0x0_u64 => {
            let v6 = constructor_iconst_u(ctx, arg0, 0x0_u64);
            let v7 = C::subsume(ctx, v6);
            // Rule at src/opts/icmp.isle line 221.
            return v7;
        }
        0x1_u64 => {
            let v9 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg3, arg4);
            // Rule at src/opts/icmp.isle line 222.
            return v9;
        }
        0x2_u64 => {
            match arg2 {
                false => {
                    let v11 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 223.
                    return v11;
                }
                true => {
                    let v13 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 224.
                    return v13;
                }
                _ => {}
            }
        }
        0x3_u64 => {
            match arg2 {
                false => {
                    let v15 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 225.
                    return v15;
                }
                true => {
                    let v17 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 226.
                    return v17;
                }
                _ => {}
            }
        }
        0x4_u64 => {
            match arg2 {
                false => {
                    let v19 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 227.
                    return v19;
                }
                true => {
                    let v21 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 228.
                    return v21;
                }
                _ => {}
            }
        }
        0x5_u64 => {
            match arg2 {
                false => {
                    let v23 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 229.
                    return v23;
                }
                true => {
                    let v25 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 230.
                    return v25;
                }
                _ => {}
            }
        }
        0x6_u64 => {
            let v27 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg3, arg4);
            // Rule at src/opts/icmp.isle line 231.
            return v27;
        }
        0x7_u64 => {
            let v29 = constructor_iconst_u(ctx, arg0, 0x1_u64);
            let v30 = C::subsume(ctx, v29);
            // Rule at src/opts/icmp.isle line 232.
            return v30;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "compose_icmp", "src/opts/icmp.isle line 220")
}

// Generated as internal constructor for term intcc_class.
pub fn constructor_intcc_class<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 243.
            return 0x3_u64;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 244.
            return 0x3_u64;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 241.
            return 0x2_u64;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 242.
            return 0x2_u64;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 239.
            return 0x2_u64;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 240.
            return 0x2_u64;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 237.
            return 0x1_u64;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 238.
            return 0x1_u64;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 235.
            return 0x1_u64;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 236.
            return 0x1_u64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "intcc_class", "src/opts/icmp.isle line 234")
}

// Generated as internal constructor for term shift_amt_to_type.
pub fn constructor_shift_amt_to_type<C: Context>(
    ctx: &mut C,
    arg0: u64,
) -> Option<Type> {
    match arg0 {
        0x8_u64 => {
            let v2 = Some(I8);
            // Rule at src/opts/shifts.isle line 93.
            return v2;
        }
        0x10_u64 => {
            let v4 = Some(I16);
            // Rule at src/opts/shifts.isle line 94.
            return v4;
        }
        0x20_u64 => {
            let v6 = Some(I32);
            // Rule at src/opts/shifts.isle line 95.
            return v6;
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term iadd_uextend.
pub fn constructor_iadd_uextend<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Value {
    let v3 = C::value_type(ctx, arg1);
    let v6 = C::ty_bits_u64(ctx, v3);
    let v1 = C::value_type(ctx, arg0);
    let v5 = C::ty_bits_u64(ctx, v1);
    let v10 = C::u64_lt(ctx, v6, v5);
    if v10 == true {
        let v11 = constructor_uextend(ctx, v1, arg1);
        let v12 = constructor_iadd(ctx, v1, arg0, v11);
        // Rule at src/opts/shifts.isle line 214.
        return v12;
    }
    let v7 = C::u64_lt(ctx, v5, v6);
    if v7 == true {
        let v8 = constructor_uextend(ctx, v3, arg0);
        let v9 = constructor_iadd(ctx, v3, v8, arg1);
        // Rule at src/opts/shifts.isle line 211.
        return v9;
    }
    if v1 == v3 {
        let v4 = constructor_iadd(ctx, v1, arg0, arg1);
        // Rule at src/opts/shifts.isle line 209.
        return v4;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "iadd_uextend", "src/opts/shifts.isle line 208")
}

// Generated as internal constructor for term isub_uextend.
pub fn constructor_isub_uextend<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Value {
    let v3 = C::value_type(ctx, arg1);
    let v6 = C::ty_bits_u64(ctx, v3);
    let v1 = C::value_type(ctx, arg0);
    let v5 = C::ty_bits_u64(ctx, v1);
    let v10 = C::u64_lt(ctx, v6, v5);
    if v10 == true {
        let v11 = constructor_uextend(ctx, v1, arg1);
        let v12 = constructor_isub(ctx, v1, arg0, v11);
        // Rule at src/opts/shifts.isle line 226.
        return v12;
    }
    let v7 = C::u64_lt(ctx, v5, v6);
    if v7 == true {
        let v8 = constructor_uextend(ctx, v3, arg0);
        let v9 = constructor_isub(ctx, v3, v8, arg1);
        // Rule at src/opts/shifts.isle line 223.
        return v9;
    }
    if v1 == v3 {
        let v4 = constructor_isub(ctx, v1, arg0, arg1);
        // Rule at src/opts/shifts.isle line 221.
        return v4;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "isub_uextend", "src/opts/shifts.isle line 220")
}

// Generated as internal constructor for term jump.
pub fn constructor_jump<C: Context>(
    ctx: &mut C,
    arg0: BlockCall,
) -> Inst {
    let v2 = InstructionData::Jump {
        opcode: Opcode::Jump,
        destination: arg0,
    };
    let v3 = C::make_skeleton_inst_ctor(ctx, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 368.
    return v3;
}

// Generated as internal constructor for term brif.
pub fn constructor_brif<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: BlockCall,
    arg2: BlockCall,
) -> Inst {
    let v4 = &C::pack_block_array_2(ctx, arg1, arg2);
    let v5 = InstructionData::Brif {
        opcode: Opcode::Brif,
        arg: arg0,
        blocks: v4.clone(),
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 377.
    return v6;
}

// Generated as internal constructor for term br_table.
pub fn constructor_br_table<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: JumpTable,
) -> Inst {
    let v3 = InstructionData::BranchTable {
        opcode: Opcode::BrTable,
        arg: arg0,
        table: arg1,
    };
    let v4 = C::make_skeleton_inst_ctor(ctx, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 386.
    return v4;
}

// Generated as internal constructor for term debugtrap.
pub fn constructor_debugtrap<C: Context>(
    ctx: &mut C,
) -> Inst {
    let v1 = InstructionData::NullAry {
        opcode: Opcode::Debugtrap,
    };
    let v2 = C::make_skeleton_inst_ctor(ctx, &v1);
    // Rule at <OUT_DIR>/clif_opt.isle line 395.
    return v2;
}

// Generated as internal constructor for term trap.
pub fn constructor_trap<C: Context>(
    ctx: &mut C,
    arg0: &TrapCode,
) -> Inst {
    let v2 = InstructionData::Trap {
        opcode: Opcode::Trap,
        code: arg0.clone(),
    };
    let v3 = C::make_skeleton_inst_ctor(ctx, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 404.
    return v3;
}

// Generated as internal constructor for term trapz.
pub fn constructor_trapz<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: &TrapCode,
) -> Inst {
    let v3 = InstructionData::CondTrap {
        opcode: Opcode::Trapz,
        arg: arg0,
        code: arg1.clone(),
    };
    let v4 = C::make_skeleton_inst_ctor(ctx, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 413.
    return v4;
}

// Generated as internal constructor for term trapnz.
pub fn constructor_trapnz<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: &TrapCode,
) -> Inst {
    let v3 = InstructionData::CondTrap {
        opcode: Opcode::Trapnz,
        arg: arg0,
        code: arg1.clone(),
    };
    let v4 = C::make_skeleton_inst_ctor(ctx, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 422.
    return v4;
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: FuncRef,
) -> Value {
    let v3 = InstructionData::FuncAddr {
        opcode: Opcode::FuncAddr,
        func_ref: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 431.
    return v4;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Splat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 440.
    return v4;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Swizzle,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 449.
    return v6;
}

// Generated as internal constructor for term x86_pshufb.
pub fn constructor_x86_pshufb<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pshufb,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 458.
    return v6;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::TernaryImm8 {
        opcode: Opcode::Insertlane,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 467.
    return v7;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::Extractlane,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 476.
    return v5;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 485.
    return v6;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 494.
    return v6;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 503.
    return v6;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 512.
    return v6;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::AvgRound,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 521.
    return v6;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 530.
    return v6;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 539.
    return v6;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 548.
    return v6;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 557.
    return v6;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Load,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 566.
    return v6;
}

// Generated as internal constructor for term store.
pub fn constructor_store<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> Inst {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Store {
        opcode: Opcode::Store,
        args: v5.clone(),
        flags: arg0,
        offset: arg3,
    };
    let v7 = C::make_skeleton_inst_ctor(ctx, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 575.
    return v7;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 584.
    return v6;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 593.
    return v6;
}

// Generated as internal constructor for term istore8.
pub fn constructor_istore8<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> Inst {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Store {
        opcode: Opcode::Istore8,
        args: v5.clone(),
        flags: arg0,
        offset: arg3,
    };
    let v7 = C::make_skeleton_inst_ctor(ctx, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 602.
    return v7;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 611.
    return v6;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 620.
    return v6;
}

// Generated as internal constructor for term istore16.
pub fn constructor_istore16<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> Inst {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Store {
        opcode: Opcode::Istore16,
        args: v5.clone(),
        flags: arg0,
        offset: arg3,
    };
    let v7 = C::make_skeleton_inst_ctor(ctx, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 629.
    return v7;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 638.
    return v6;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 647.
    return v6;
}

// Generated as internal constructor for term istore32.
pub fn constructor_istore32<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> Inst {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Store {
        opcode: Opcode::Istore32,
        args: v5.clone(),
        flags: arg0,
        offset: arg3,
    };
    let v7 = C::make_skeleton_inst_ctor(ctx, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 656.
    return v7;
}

// Generated as internal constructor for term stack_switch.
pub fn constructor_stack_switch<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: Value,
) -> Inst {
    let v4 = &C::value_array_3_ctor(ctx, arg0, arg1, arg2);
    let v5 = InstructionData::Ternary {
        opcode: Opcode::StackSwitch,
        args: v4.clone(),
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 665.
    return v6;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 674.
    return v6;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 683.
    return v6;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 692.
    return v6;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 701.
    return v6;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 710.
    return v6;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 719.
    return v6;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackLoad,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 728.
    return v5;
}

// Generated as internal constructor for term stack_store.
pub fn constructor_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: StackSlot,
    arg2: Offset32,
) -> Inst {
    let v4 = InstructionData::StackStore {
        opcode: Opcode::StackStore,
        arg: arg0,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 737.
    return v5;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackAddr,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 746.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackLoad,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 755.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_store.
pub fn constructor_dynamic_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: DynamicStackSlot,
) -> Inst {
    let v3 = InstructionData::DynamicStackStore {
        opcode: Opcode::DynamicStackStore,
        arg: arg0,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_skeleton_inst_ctor(ctx, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 764.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackAddr,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 773.
    return v4;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: GlobalValue,
) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::GlobalValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 782.
    return v4;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: GlobalValue,
) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::SymbolValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 791.
    return v4;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: GlobalValue,
) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::TlsValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 800.
    return v4;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(
    ctx: &mut C,
) -> Inst {
    let v1 = InstructionData::NullAry {
        opcode: Opcode::GetPinnedReg,
    };
    let v2 = C::make_skeleton_inst_ctor(ctx, &v1);
    // Rule at <OUT_DIR>/clif_opt.isle line 809.
    return v2;
}

// Generated as internal constructor for term set_pinned_reg.
pub fn constructor_set_pinned_reg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Inst {
    let v2 = InstructionData::Unary {
        opcode: Opcode::SetPinnedReg,
        arg: arg0,
    };
    let v3 = C::make_skeleton_inst_ctor(ctx, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 818.
    return v3;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetFramePointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 827.
    return v3;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetStackPointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 836.
    return v3;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetReturnAddress,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 845.
    return v3;
}

// Generated as internal constructor for term get_exception_handler_address.
pub fn constructor_get_exception_handler_address<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Block,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::ExceptionHandlerAddress {
        opcode: Opcode::GetExceptionHandlerAddress,
        block: arg1.clone(),
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 854.
    return v5;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Imm64,
) -> Value {
    let v3 = InstructionData::UnaryImm {
        opcode: Opcode::Iconst,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 863.
    return v4;
}

// Generated as internal constructor for term f16const.
pub fn constructor_f16const<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Ieee16,
) -> Value {
    let v3 = InstructionData::UnaryIeee16 {
        opcode: Opcode::F16const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 872.
    return v4;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Ieee32,
) -> Value {
    let v3 = InstructionData::UnaryIeee32 {
        opcode: Opcode::F32const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 881.
    return v4;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Ieee64,
) -> Value {
    let v3 = InstructionData::UnaryIeee64 {
        opcode: Opcode::F64const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 890.
    return v4;
}

// Generated as internal constructor for term f128const.
pub fn constructor_f128const<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Constant,
) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::F128const,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 899.
    return v4;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Constant,
) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::Vconst,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 908.
    return v4;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Shuffle {
        opcode: Opcode::Shuffle,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 917.
    return v7;
}

// Generated as internal constructor for term nop.
pub fn constructor_nop<C: Context>(
    ctx: &mut C,
) -> Inst {
    let v1 = InstructionData::NullAry {
        opcode: Opcode::Nop,
    };
    let v2 = C::make_skeleton_inst_ctor(ctx, &v1);
    // Rule at <OUT_DIR>/clif_opt.isle line 926.
    return v2;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Select,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 935.
    return v7;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::SelectSpectreGuard,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 944.
    return v7;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Bitselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 953.
    return v7;
}

// Generated as internal constructor for term x86_blendv.
pub fn constructor_x86_blendv<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::X86Blendv,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 962.
    return v7;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VanyTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 971.
    return v4;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VallTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 980.
    return v4;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VhighBits,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 989.
    return v4;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::IntCompare {
        opcode: Opcode::Icmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 998.
    return v7;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let v5 = InstructionData::IntCompareImm {
        opcode: Opcode::IcmpImm,
        arg: arg2,
        cond: arg1.clone(),
        imm: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1007.
    return v6;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1016.
    return v6;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Isub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1025.
    return v6;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ineg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1034.
    return v4;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Iabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1043.
    return v4;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Imul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1052.
    return v6;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1061.
    return v6;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1070.
    return v6;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SqmulRoundSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1079.
    return v6;
}

// Generated as internal constructor for term x86_pmulhrsw.
pub fn constructor_x86_pmulhrsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmulhrsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1088.
    return v6;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::Udiv,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1097.
    return v5;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::Sdiv,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1106.
    return v5;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::Urem,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1115.
    return v5;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::Srem,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1124.
    return v5;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IaddImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1133.
    return v5;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::ImulImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1142.
    return v5;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1151.
    return v5;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1160.
    return v5;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1169.
    return v5;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1178.
    return v5;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IrsubImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1187.
    return v5;
}

// Generated as internal constructor for term sadd_overflow_cin.
pub fn constructor_sadd_overflow_cin<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: Value,
) -> Inst {
    let v4 = &C::value_array_3_ctor(ctx, arg0, arg1, arg2);
    let v5 = InstructionData::Ternary {
        opcode: Opcode::SaddOverflowCin,
        args: v4.clone(),
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1196.
    return v6;
}

// Generated as internal constructor for term uadd_overflow_cin.
pub fn constructor_uadd_overflow_cin<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: Value,
) -> Inst {
    let v4 = &C::value_array_3_ctor(ctx, arg0, arg1, arg2);
    let v5 = InstructionData::Ternary {
        opcode: Opcode::UaddOverflowCin,
        args: v4.clone(),
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1205.
    return v6;
}

// Generated as internal constructor for term uadd_overflow.
pub fn constructor_uadd_overflow<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::UaddOverflow,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1214.
    return v5;
}

// Generated as internal constructor for term sadd_overflow.
pub fn constructor_sadd_overflow<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::SaddOverflow,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1223.
    return v5;
}

// Generated as internal constructor for term usub_overflow.
pub fn constructor_usub_overflow<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::UsubOverflow,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1232.
    return v5;
}

// Generated as internal constructor for term ssub_overflow.
pub fn constructor_ssub_overflow<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::SsubOverflow,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1241.
    return v5;
}

// Generated as internal constructor for term umul_overflow.
pub fn constructor_umul_overflow<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::UmulOverflow,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1250.
    return v5;
}

// Generated as internal constructor for term smul_overflow.
pub fn constructor_smul_overflow<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Inst {
    let v3 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v4 = InstructionData::Binary {
        opcode: Opcode::SmulOverflow,
        args: v3.clone(),
    };
    let v5 = C::make_skeleton_inst_ctor(ctx, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1259.
    return v5;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: &TrapCode,
) -> Inst {
    let v4 = &C::value_array_2_ctor(ctx, arg0, arg1);
    let v5 = InstructionData::IntAddTrap {
        opcode: Opcode::UaddOverflowTrap,
        args: v4.clone(),
        code: arg2.clone(),
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1268.
    return v6;
}

// Generated as internal constructor for term ssub_overflow_bin.
pub fn constructor_ssub_overflow_bin<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: Value,
) -> Inst {
    let v4 = &C::value_array_3_ctor(ctx, arg0, arg1, arg2);
    let v5 = InstructionData::Ternary {
        opcode: Opcode::SsubOverflowBin,
        args: v4.clone(),
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1277.
    return v6;
}

// Generated as internal constructor for term usub_overflow_bin.
pub fn constructor_usub_overflow_bin<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: Value,
) -> Inst {
    let v4 = &C::value_array_3_ctor(ctx, arg0, arg1, arg2);
    let v5 = InstructionData::Ternary {
        opcode: Opcode::UsubOverflowBin,
        args: v4.clone(),
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1286.
    return v6;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Band,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1295.
    return v6;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1304.
    return v6;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bxor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1313.
    return v6;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bnot,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1322.
    return v4;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BandNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1331.
    return v6;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1340.
    return v6;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BxorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1349.
    return v6;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BandImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1358.
    return v5;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1367.
    return v5;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BxorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1376.
    return v5;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1385.
    return v6;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1394.
    return v6;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1403.
    return v5;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1412.
    return v5;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ishl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1421.
    return v6;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ushr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1430.
    return v6;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sshr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1439.
    return v6;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IshlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1448.
    return v5;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1457.
    return v5;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1466.
    return v5;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bitrev,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1475.
    return v4;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Clz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1484.
    return v4;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Cls,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1493.
    return v4;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ctz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1502.
    return v4;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bswap,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1511.
    return v4;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Popcnt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1520.
    return v4;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::FloatCompare {
        opcode: Opcode::Fcmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 1529.
    return v7;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1538.
    return v6;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fsub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1547.
    return v6;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1556.
    return v6;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1565.
    return v6;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sqrt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1574.
    return v4;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Fma,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 1583.
    return v7;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fneg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1592.
    return v4;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1601.
    return v4;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fcopysign,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1610.
    return v6;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1619.
    return v6;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1628.
    return v6;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ceil,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1637.
    return v4;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Floor,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1646.
    return v4;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Trunc,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1655.
    return v4;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Nearest,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1664.
    return v4;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::Bitcast,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1673.
    return v5;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::ScalarToVector,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1682.
    return v4;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bmask,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1691.
    return v4;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ireduce,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1700.
    return v4;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Snarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1709.
    return v6;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Unarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1718.
    return v6;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Uunarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1727.
    return v6;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1736.
    return v4;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1745.
    return v4;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1754.
    return v4;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1763.
    return v4;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddPairwise,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1772.
    return v6;
}

// Generated as internal constructor for term x86_pmaddubsw.
pub fn constructor_x86_pmaddubsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmaddubsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1781.
    return v6;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Uextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1790.
    return v4;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1799.
    return v4;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fpromote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1808.
    return v4;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1817.
    return v4;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fvdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1826.
    return v4;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FvpromoteLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1835.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Inst {
    let v2 = InstructionData::Unary {
        opcode: Opcode::FcvtToUint,
        arg: arg0,
    };
    let v3 = C::make_skeleton_inst_ctor(ctx, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 1844.
    return v3;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Inst {
    let v2 = InstructionData::Unary {
        opcode: Opcode::FcvtToSint,
        arg: arg0,
    };
    let v3 = C::make_skeleton_inst_ctor(ctx, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 1853.
    return v3;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1862.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1871.
    return v4;
}

// Generated as internal constructor for term x86_cvtt2dq.
pub fn constructor_x86_cvtt2dq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::X86Cvtt2dq,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1880.
    return v4;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1889.
    return v4;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1898.
    return v4;
}

// Generated as internal constructor for term isplit.
pub fn constructor_isplit<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Inst {
    let v2 = InstructionData::Unary {
        opcode: Opcode::Isplit,
        arg: arg0,
    };
    let v3 = C::make_skeleton_inst_ctor(ctx, &v2);
    // Rule at <OUT_DIR>/clif_opt.isle line 1907.
    return v3;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iconcat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1916.
    return v6;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: &AtomicRmwOp,
    arg2: Value,
    arg3: Value,
) -> Inst {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::AtomicRmw {
        opcode: Opcode::AtomicRmw,
        args: v5.clone(),
        flags: arg0,
        op: arg1.clone(),
    };
    let v7 = C::make_skeleton_inst_ctor(ctx, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 1925.
    return v7;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Inst {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::AtomicCas {
        opcode: Opcode::AtomicCas,
        args: v5.clone(),
        flags: arg0,
    };
    let v7 = C::make_skeleton_inst_ctor(ctx, &v6);
    // Rule at <OUT_DIR>/clif_opt.isle line 1934.
    return v7;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
) -> Inst {
    let v3 = InstructionData::LoadNoOffset {
        opcode: Opcode::AtomicLoad,
        arg: arg1,
        flags: arg0,
    };
    let v4 = C::make_skeleton_inst_ctor(ctx, &v3);
    // Rule at <OUT_DIR>/clif_opt.isle line 1943.
    return v4;
}

// Generated as internal constructor for term atomic_store.
pub fn constructor_atomic_store<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
) -> Inst {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::StoreNoOffset {
        opcode: Opcode::AtomicStore,
        args: v4.clone(),
        flags: arg0,
    };
    let v6 = C::make_skeleton_inst_ctor(ctx, &v5);
    // Rule at <OUT_DIR>/clif_opt.isle line 1952.
    return v6;
}

// Generated as internal constructor for term fence.
pub fn constructor_fence<C: Context>(
    ctx: &mut C,
) -> Inst {
    let v1 = InstructionData::NullAry {
        opcode: Opcode::Fence,
    };
    let v2 = C::make_skeleton_inst_ctor(ctx, &v1);
    // Rule at <OUT_DIR>/clif_opt.isle line 1961.
    return v2;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::ExtractVector,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at <OUT_DIR>/clif_opt.isle line 1970.
    return v5;
}

// Generated as internal constructor for term sequence_point.
pub fn constructor_sequence_point<C: Context>(
    ctx: &mut C,
) -> Inst {
    let v1 = InstructionData::NullAry {
        opcode: Opcode::SequencePoint,
    };
    let v2 = C::make_skeleton_inst_ctor(ctx, &v1);
    // Rule at <OUT_DIR>/clif_opt.isle line 1979.
    return v2;
}
