// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_lower.isle
// - src/isa/pulley_shared/inst.isle
// - src/isa/pulley_shared/lower.isle
// - <OUT_DIR>/numerics.isle
// - <OUT_DIR>/pulley_gen.isle
// - <OUT_DIR>/clif_lower.isle

use super::*;  // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self, ) -> Unit;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> i32;
    fn checked_add_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> Option<u64>;
    fn add_overflows_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> bool;
    fn imm64_sdiv(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_srem(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn i64_sextend_u64(&mut self, arg0: Type, arg1: u64) -> i64;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn imm64_clz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn imm64_ctz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn u128_replicated_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_replicated_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u32_replicated_u16(&mut self, arg0: u64) -> Option<u64>;
    fn u16_replicated_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u128_low_bits(&mut self, arg0: u128) -> u64;
    fn u128_high_bits(&mut self, arg0: u128) -> u64;
    fn f16_min(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_max(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_neg(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_abs(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_copysign(&mut self, arg0: Ieee16, arg1: Ieee16) -> Ieee16;
    fn f32_add(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sub(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_mul(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_div(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sqrt(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_ceil(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_floor(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_trunc(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_nearest(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_min(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_max(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_neg(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_abs(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_copysign(&mut self, arg0: Ieee32, arg1: Ieee32) -> Ieee32;
    fn f64_add(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sub(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_mul(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_div(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sqrt(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_ceil(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_floor(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_trunc(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_nearest(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_min(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_max(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_neg(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_abs(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_copysign(&mut self, arg0: Ieee64, arg1: Ieee64) -> Ieee64;
    fn f128_min(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_max(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_neg(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_abs(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_copysign(&mut self, arg0: Ieee128, arg1: Ieee128) -> Ieee128;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_count(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn ty_half_lanes(&mut self, arg0: Type) -> Option<Type>;
    fn ty_half_width(&mut self, arg0: Type) -> Option<Type>;
    fn ty_equal(&mut self, arg0: Type, arg1: Type) -> bool;
    fn mem_flags_trusted(&mut self, ) -> MemFlags;
    fn little_or_native_endian(&mut self, arg0: MemFlags) -> Option<MemFlags>;
    fn intcc_swap_args(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_complement(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_without_eq(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_swap_args(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_complement(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16_or_32(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u16_from_ieee16(&mut self, arg0: Ieee16) -> u16;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_i32(&mut self, arg0: Offset32) -> i32;
    fn i32_to_offset32(&mut self, arg0: i32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self, ) -> TrapCode;
    fn trap_code_integer_overflow(&mut self, ) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self, ) -> TrapCode;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn writable_value_reg(&mut self, arg0: WritableReg) -> WritableValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn writable_value_regs(&mut self, arg0: WritableReg, arg1: WritableReg) -> WritableValueRegs;
    fn value_regs_invalid(&mut self, ) -> ValueRegs;
    fn output_none(&mut self, ) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_vec(&mut self, arg0: &ValueRegsVec) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn is_valid_reg(&mut self, arg0: Reg) -> bool;
    fn invalid_reg(&mut self, ) -> Reg;
    fn mark_value_used(&mut self, arg0: Value) -> Unit;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn put_in_regs_vec(&mut self, arg0: ValueSlice) -> ValueRegsVec;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn value_regs_len(&mut self, arg0: ValueRegs) -> usize;
    fn preg_to_reg(&mut self, arg0: PReg) -> Reg;
    fn add_range_fact(&mut self, arg0: Reg, arg1: u16, arg2: u64, arg3: u64) -> Reg;
    fn single_target(&mut self, arg0: &MachLabelSlice) -> Option<MachLabel>;
    fn two_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, MachLabel)>;
    fn jump_table_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, BoxVecMachLabel)>;
    fn jump_table_size(&mut self, arg0: &BoxVecMachLabel) -> u32;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn value_is_unused(&mut self, arg0: Value) -> bool;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data_value(&mut self, arg0: Inst) -> InstructionData;
    fn i64_from_iconst(&mut self, arg0: Value) -> Option<i64>;
    fn zero_value(&mut self, arg0: Value) -> Option<Value>;
    fn is_sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn maybe_uextend(&mut self, arg0: Value) -> Option<Value>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn block_exn_successor_label(&mut self, arg0: &Block, arg1: u64) -> MachLabel;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn sink_inst(&mut self, arg0: Inst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u64_be_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u128_le_const(&mut self, arg0: u128) -> VCodeConstant;
    fn emit_u128_be_const(&mut self, arg0: u128) -> VCodeConstant;
    fn const_to_vconst(&mut self, arg0: Constant) -> VCodeConstant;
    fn tls_model(&mut self, arg0: Type) -> TlsModel;
    fn tls_model_is_elf_gd(&mut self, ) -> Option<Unit>;
    fn tls_model_is_macho(&mut self, ) -> Option<Unit>;
    fn tls_model_is_coff(&mut self, ) -> Option<Unit>;
    fn preserve_frame_pointers(&mut self, ) -> Option<Unit>;
    fn stack_switch_model(&mut self, ) -> Option<StackSwitchModel>;
    fn box_external_name(&mut self, arg0: ExternalName) -> BoxExternalName;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn exception_sig(&mut self, arg0: ExceptionTable) -> SigRef;
    fn symbol_value_data(&mut self, arg0: GlobalValue) -> Option<(ExternalName, RelocDistance, i64)>;
    fn vec_mask_from_immediate(&mut self, arg0: Immediate) -> Option<VecMask>;
    fn u128_from_immediate(&mut self, arg0: Immediate) -> Option<u128>;
    fn vconst_from_immediate(&mut self, arg0: Immediate) -> Option<VCodeConstant>;
    fn u128_from_constant(&mut self, arg0: Constant) -> Option<u128>;
    fn u64_from_constant(&mut self, arg0: Constant) -> Option<u64>;
    fn shuffle64_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8)>;
    fn shuffle32_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8)>;
    fn shuffle16_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8, u8, u8, u8, u8)>;
    fn only_writable_reg(&mut self, arg0: WritableValueRegs) -> Option<WritableReg>;
    fn writable_regs_get(&mut self, arg0: WritableValueRegs, arg1: usize) -> WritableReg;
    fn abi_sig(&mut self, arg0: SigRef) -> Sig;
    fn abi_num_args(&mut self, arg0: Sig) -> usize;
    fn abi_get_arg(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_num_rets(&mut self, arg0: Sig) -> usize;
    fn abi_get_ret(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_ret_arg(&mut self, arg0: Sig) -> Option<ABIArg>;
    fn abi_no_ret_arg(&mut self, arg0: Sig) -> Option<()>;
    fn abi_unwrap_ret_area_ptr(&mut self, ) -> Reg;
    fn abi_stackslot_addr(&mut self, arg0: WritableReg, arg1: StackSlot, arg2: Offset32) -> MInst;
    fn abi_stackslot_offset_into_slot_region(&mut self, arg0: StackSlot, arg1: Offset32, arg2: Offset32) -> i32;
    fn abi_dynamic_stackslot_addr(&mut self, arg0: WritableReg, arg1: DynamicStackSlot) -> MInst;
    fn abi_arg_only_slot(&mut self, arg0: &ABIArg) -> Option<ABIArgSlot>;
    fn abi_arg_implicit_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, Type)>;
    fn real_reg_to_reg(&mut self, arg0: RealReg) -> Reg;
    fn real_reg_to_writable_reg(&mut self, arg0: RealReg) -> WritableReg;
    fn gen_move(&mut self, arg0: Type, arg1: WritableReg, arg2: Reg) -> MInst;
    fn gen_return(&mut self, arg0: &ValueRegsVec) -> Unit;
    fn gen_call_output(&mut self, arg0: SigRef) -> ValueRegsVec;
    fn gen_call_args(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallArgList;
    fn gen_return_call_args(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallArgList;
    fn gen_call_rets(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallRetList;
    fn gen_try_call_rets(&mut self, arg0: Sig) -> CallRetList;
    fn try_call_info(&mut self, arg0: ExceptionTable, arg1: &MachLabelSlice) -> OptionTryCallInfo;
    fn try_call_none(&mut self, ) -> OptionTryCallInfo;
    fn safe_divisor_from_imm64(&mut self, arg0: Type, arg1: Imm64) -> Option<u64>;
    fn cond_invert(&mut self, arg0: &Cond) -> Cond;
    fn endianness(&mut self, arg0: MemFlags) -> Endianness;
    fn is_native_endianness(&mut self, arg0: &Endianness) -> bool;
    fn pointer_width(&mut self, ) -> PointerWidth;
    fn memflags_nontrapping(&mut self, arg0: MemFlags) -> bool;
    fn memflags_is_wasm(&mut self, arg0: MemFlags) -> bool;
    fn g32_offset(&mut self, arg0: i32, arg1: Type, arg2: u64) -> Option<u16>;
    fn xreg_new(&mut self, arg0: Reg) -> XReg;
    fn writable_xreg_new(&mut self, arg0: WritableReg) -> WritableXReg;
    fn writable_xreg_to_xreg(&mut self, arg0: WritableXReg) -> XReg;
    fn writable_xreg_to_writable_reg(&mut self, arg0: WritableXReg) -> WritableReg;
    fn xreg_to_reg(&mut self, arg0: XReg) -> Reg;
    fn freg_new(&mut self, arg0: Reg) -> FReg;
    fn writable_freg_new(&mut self, arg0: WritableReg) -> WritableFReg;
    fn writable_freg_to_freg(&mut self, arg0: WritableFReg) -> FReg;
    fn writable_freg_to_writable_reg(&mut self, arg0: WritableFReg) -> WritableReg;
    fn freg_to_reg(&mut self, arg0: FReg) -> Reg;
    fn vreg_new(&mut self, arg0: Reg) -> VReg;
    fn writable_vreg_new(&mut self, arg0: WritableReg) -> WritableVReg;
    fn writable_vreg_to_vreg(&mut self, arg0: WritableVReg) -> VReg;
    fn writable_vreg_to_writable_reg(&mut self, arg0: WritableVReg) -> WritableReg;
    fn vreg_to_reg(&mut self, arg0: VReg) -> Reg;
    fn sp_reg(&mut self, ) -> XReg;
    fn gen_call_info(&mut self, arg0: Sig, arg1: ExternalName, arg2: CallArgList, arg3: CallRetList, arg4: OptionTryCallInfo) -> BoxCallInfo;
    fn gen_call_ind_info(&mut self, arg0: Sig, arg1: Reg, arg2: CallArgList, arg3: CallRetList, arg4: OptionTryCallInfo) -> BoxCallIndInfo;
    fn gen_call_host_info(&mut self, arg0: Sig, arg1: ExternalName, arg2: CallArgList, arg3: CallRetList, arg4: OptionTryCallInfo) -> BoxCallIndirectHostInfo;
    fn gen_return_call_info(&mut self, arg0: Sig, arg1: ExternalName, arg2: CallArgList) -> BoxReturnCallInfo;
    fn gen_return_call_ind_info(&mut self, arg0: Sig, arg1: Reg, arg2: CallArgList) -> BoxReturnCallIndInfo;
    fn u6_from_u8(&mut self, arg0: u8) -> Option<U6>;
    fn i8_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_ne(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_checked_add(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_sub(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_mul(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_div(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_rem(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_rem(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_and(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_or(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_xor(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_not(&mut self, arg0: i8) -> i8;
    fn i8_checked_shl(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_checked_shr(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_is_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_non_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_non_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_odd(&mut self, arg0: i8) -> bool;
    fn i8_matches_odd(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_even(&mut self, arg0: i8) -> bool;
    fn i8_matches_even(&mut self, arg0: i8) -> Option<bool>;
    fn i8_checked_ilog2(&mut self, arg0: i8) -> Option<u32>;
    fn i8_ilog2(&mut self, arg0: i8) -> u32;
    fn i8_trailing_zeros(&mut self, arg0: i8) -> u32;
    fn i8_trailing_ones(&mut self, arg0: i8) -> u32;
    fn i8_leading_zeros(&mut self, arg0: i8) -> u32;
    fn i8_leading_ones(&mut self, arg0: i8) -> u32;
    fn i8_checked_neg(&mut self, arg0: i8) -> Option<i8>;
    fn i8_wrapping_neg(&mut self, arg0: i8) -> i8;
    fn i8_neg(&mut self, arg0: i8) -> i8;
    fn u8_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_ne(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_checked_add(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_sub(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_mul(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_div(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_rem(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_rem(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_or(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_xor(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_not(&mut self, arg0: u8) -> u8;
    fn u8_checked_shl(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_checked_shr(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_is_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_non_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_non_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_odd(&mut self, arg0: u8) -> bool;
    fn u8_matches_odd(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_even(&mut self, arg0: u8) -> bool;
    fn u8_matches_even(&mut self, arg0: u8) -> Option<bool>;
    fn u8_checked_ilog2(&mut self, arg0: u8) -> Option<u32>;
    fn u8_ilog2(&mut self, arg0: u8) -> u32;
    fn u8_trailing_zeros(&mut self, arg0: u8) -> u32;
    fn u8_trailing_ones(&mut self, arg0: u8) -> u32;
    fn u8_leading_zeros(&mut self, arg0: u8) -> u32;
    fn u8_leading_ones(&mut self, arg0: u8) -> u32;
    fn u8_is_power_of_two(&mut self, arg0: u8) -> bool;
    fn u8_matches_power_of_two(&mut self, arg0: u8) -> Option<bool>;
    fn i16_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_ne(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_checked_add(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_sub(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_mul(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_div(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_rem(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_rem(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_and(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_or(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_xor(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_not(&mut self, arg0: i16) -> i16;
    fn i16_checked_shl(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_checked_shr(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_is_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_non_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_non_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_odd(&mut self, arg0: i16) -> bool;
    fn i16_matches_odd(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_even(&mut self, arg0: i16) -> bool;
    fn i16_matches_even(&mut self, arg0: i16) -> Option<bool>;
    fn i16_checked_ilog2(&mut self, arg0: i16) -> Option<u32>;
    fn i16_ilog2(&mut self, arg0: i16) -> u32;
    fn i16_trailing_zeros(&mut self, arg0: i16) -> u32;
    fn i16_trailing_ones(&mut self, arg0: i16) -> u32;
    fn i16_leading_zeros(&mut self, arg0: i16) -> u32;
    fn i16_leading_ones(&mut self, arg0: i16) -> u32;
    fn i16_checked_neg(&mut self, arg0: i16) -> Option<i16>;
    fn i16_wrapping_neg(&mut self, arg0: i16) -> i16;
    fn i16_neg(&mut self, arg0: i16) -> i16;
    fn u16_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_ne(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_checked_add(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_sub(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_mul(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_div(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_rem(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_rem(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_and(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_or(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_xor(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_not(&mut self, arg0: u16) -> u16;
    fn u16_checked_shl(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_checked_shr(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_is_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_non_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_non_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_odd(&mut self, arg0: u16) -> bool;
    fn u16_matches_odd(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_even(&mut self, arg0: u16) -> bool;
    fn u16_matches_even(&mut self, arg0: u16) -> Option<bool>;
    fn u16_checked_ilog2(&mut self, arg0: u16) -> Option<u32>;
    fn u16_ilog2(&mut self, arg0: u16) -> u32;
    fn u16_trailing_zeros(&mut self, arg0: u16) -> u32;
    fn u16_trailing_ones(&mut self, arg0: u16) -> u32;
    fn u16_leading_zeros(&mut self, arg0: u16) -> u32;
    fn u16_leading_ones(&mut self, arg0: u16) -> u32;
    fn u16_is_power_of_two(&mut self, arg0: u16) -> bool;
    fn u16_matches_power_of_two(&mut self, arg0: u16) -> Option<bool>;
    fn i32_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_ne(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_checked_add(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_sub(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_mul(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_div(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_rem(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_rem(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_and(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_or(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_xor(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_not(&mut self, arg0: i32) -> i32;
    fn i32_checked_shl(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_checked_shr(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_is_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_non_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_non_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_odd(&mut self, arg0: i32) -> bool;
    fn i32_matches_odd(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_even(&mut self, arg0: i32) -> bool;
    fn i32_matches_even(&mut self, arg0: i32) -> Option<bool>;
    fn i32_checked_ilog2(&mut self, arg0: i32) -> Option<u32>;
    fn i32_ilog2(&mut self, arg0: i32) -> u32;
    fn i32_trailing_zeros(&mut self, arg0: i32) -> u32;
    fn i32_trailing_ones(&mut self, arg0: i32) -> u32;
    fn i32_leading_zeros(&mut self, arg0: i32) -> u32;
    fn i32_leading_ones(&mut self, arg0: i32) -> u32;
    fn i32_checked_neg(&mut self, arg0: i32) -> Option<i32>;
    fn i32_wrapping_neg(&mut self, arg0: i32) -> i32;
    fn i32_neg(&mut self, arg0: i32) -> i32;
    fn u32_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_ne(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_checked_add(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_sub(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_mul(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_div(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_rem(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_rem(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_or(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_xor(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_not(&mut self, arg0: u32) -> u32;
    fn u32_checked_shl(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_shr(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_is_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_non_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_non_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_odd(&mut self, arg0: u32) -> bool;
    fn u32_matches_odd(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_even(&mut self, arg0: u32) -> bool;
    fn u32_matches_even(&mut self, arg0: u32) -> Option<bool>;
    fn u32_checked_ilog2(&mut self, arg0: u32) -> Option<u32>;
    fn u32_ilog2(&mut self, arg0: u32) -> u32;
    fn u32_trailing_zeros(&mut self, arg0: u32) -> u32;
    fn u32_trailing_ones(&mut self, arg0: u32) -> u32;
    fn u32_leading_zeros(&mut self, arg0: u32) -> u32;
    fn u32_leading_ones(&mut self, arg0: u32) -> u32;
    fn u32_is_power_of_two(&mut self, arg0: u32) -> bool;
    fn u32_matches_power_of_two(&mut self, arg0: u32) -> Option<bool>;
    fn i64_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_ne(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_checked_add(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_sub(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_mul(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_div(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_rem(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_rem(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_and(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_or(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_xor(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_not(&mut self, arg0: i64) -> i64;
    fn i64_checked_shl(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_checked_shr(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_is_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_non_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_non_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_odd(&mut self, arg0: i64) -> bool;
    fn i64_matches_odd(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_even(&mut self, arg0: i64) -> bool;
    fn i64_matches_even(&mut self, arg0: i64) -> Option<bool>;
    fn i64_checked_ilog2(&mut self, arg0: i64) -> Option<u32>;
    fn i64_ilog2(&mut self, arg0: i64) -> u32;
    fn i64_trailing_zeros(&mut self, arg0: i64) -> u32;
    fn i64_trailing_ones(&mut self, arg0: i64) -> u32;
    fn i64_leading_zeros(&mut self, arg0: i64) -> u32;
    fn i64_leading_ones(&mut self, arg0: i64) -> u32;
    fn i64_checked_neg(&mut self, arg0: i64) -> Option<i64>;
    fn i64_wrapping_neg(&mut self, arg0: i64) -> i64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_ne(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_checked_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_mul(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_div(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_rem(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_rem(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_checked_shl(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_checked_shr(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_non_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_non_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn u64_matches_odd(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_even(&mut self, arg0: u64) -> bool;
    fn u64_matches_even(&mut self, arg0: u64) -> Option<bool>;
    fn u64_checked_ilog2(&mut self, arg0: u64) -> Option<u32>;
    fn u64_ilog2(&mut self, arg0: u64) -> u32;
    fn u64_trailing_zeros(&mut self, arg0: u64) -> u32;
    fn u64_trailing_ones(&mut self, arg0: u64) -> u32;
    fn u64_leading_zeros(&mut self, arg0: u64) -> u32;
    fn u64_leading_ones(&mut self, arg0: u64) -> u32;
    fn u64_is_power_of_two(&mut self, arg0: u64) -> bool;
    fn u64_matches_power_of_two(&mut self, arg0: u64) -> Option<bool>;
    fn i128_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_ne(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_checked_add(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_sub(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_mul(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_div(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_rem(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_rem(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_and(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_or(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_xor(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_not(&mut self, arg0: i128) -> i128;
    fn i128_checked_shl(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_checked_shr(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_is_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_non_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_non_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_odd(&mut self, arg0: i128) -> bool;
    fn i128_matches_odd(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_even(&mut self, arg0: i128) -> bool;
    fn i128_matches_even(&mut self, arg0: i128) -> Option<bool>;
    fn i128_checked_ilog2(&mut self, arg0: i128) -> Option<u32>;
    fn i128_ilog2(&mut self, arg0: i128) -> u32;
    fn i128_trailing_zeros(&mut self, arg0: i128) -> u32;
    fn i128_trailing_ones(&mut self, arg0: i128) -> u32;
    fn i128_leading_zeros(&mut self, arg0: i128) -> u32;
    fn i128_leading_ones(&mut self, arg0: i128) -> u32;
    fn i128_checked_neg(&mut self, arg0: i128) -> Option<i128>;
    fn i128_wrapping_neg(&mut self, arg0: i128) -> i128;
    fn i128_neg(&mut self, arg0: i128) -> i128;
    fn u128_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_ne(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_checked_add(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_sub(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_mul(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_div(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_rem(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_rem(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_and(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_or(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_xor(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_not(&mut self, arg0: u128) -> u128;
    fn u128_checked_shl(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_checked_shr(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_is_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_non_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_non_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_odd(&mut self, arg0: u128) -> bool;
    fn u128_matches_odd(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_even(&mut self, arg0: u128) -> bool;
    fn u128_matches_even(&mut self, arg0: u128) -> Option<bool>;
    fn u128_checked_ilog2(&mut self, arg0: u128) -> Option<u32>;
    fn u128_ilog2(&mut self, arg0: u128) -> u32;
    fn u128_trailing_zeros(&mut self, arg0: u128) -> u32;
    fn u128_trailing_ones(&mut self, arg0: u128) -> u32;
    fn u128_leading_zeros(&mut self, arg0: u128) -> u32;
    fn u128_leading_ones(&mut self, arg0: u128) -> u32;
    fn u128_is_power_of_two(&mut self, arg0: u128) -> bool;
    fn u128_matches_power_of_two(&mut self, arg0: u128) -> Option<bool>;
    fn i8_try_into_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_unwrap_into_u8(&mut self, arg0: i8) -> u8;
    fn i8_cast_unsigned(&mut self, arg0: i8) -> u8;
    fn i8_from_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_into_i16(&mut self, arg0: i8) -> i16;
    fn i8_from_i16(&mut self, arg0: i8) -> Option<i16>;
    fn i8_try_into_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_unwrap_into_u16(&mut self, arg0: i8) -> u16;
    fn i8_from_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_into_i32(&mut self, arg0: i8) -> i32;
    fn i8_from_i32(&mut self, arg0: i8) -> Option<i32>;
    fn i8_try_into_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_unwrap_into_u32(&mut self, arg0: i8) -> u32;
    fn i8_from_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_into_i64(&mut self, arg0: i8) -> i64;
    fn i8_from_i64(&mut self, arg0: i8) -> Option<i64>;
    fn i8_try_into_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_unwrap_into_u64(&mut self, arg0: i8) -> u64;
    fn i8_from_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_into_i128(&mut self, arg0: i8) -> i128;
    fn i8_from_i128(&mut self, arg0: i8) -> Option<i128>;
    fn i8_try_into_u128(&mut self, arg0: i8) -> Option<u128>;
    fn i8_unwrap_into_u128(&mut self, arg0: i8) -> u128;
    fn i8_from_u128(&mut self, arg0: i8) -> Option<u128>;
    fn u8_try_into_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_unwrap_into_i8(&mut self, arg0: u8) -> i8;
    fn u8_cast_signed(&mut self, arg0: u8) -> i8;
    fn u8_from_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_into_i16(&mut self, arg0: u8) -> i16;
    fn u8_from_i16(&mut self, arg0: u8) -> Option<i16>;
    fn u8_into_u16(&mut self, arg0: u8) -> u16;
    fn u8_from_u16(&mut self, arg0: u8) -> Option<u16>;
    fn u8_into_i32(&mut self, arg0: u8) -> i32;
    fn u8_from_i32(&mut self, arg0: u8) -> Option<i32>;
    fn u8_into_u32(&mut self, arg0: u8) -> u32;
    fn u8_from_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_into_i64(&mut self, arg0: u8) -> i64;
    fn u8_from_i64(&mut self, arg0: u8) -> Option<i64>;
    fn u8_into_u64(&mut self, arg0: u8) -> u64;
    fn u8_from_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u8_into_i128(&mut self, arg0: u8) -> i128;
    fn u8_from_i128(&mut self, arg0: u8) -> Option<i128>;
    fn u8_into_u128(&mut self, arg0: u8) -> u128;
    fn u8_from_u128(&mut self, arg0: u8) -> Option<u128>;
    fn i16_try_into_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_unwrap_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_truncate_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_from_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_try_into_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_unwrap_into_u8(&mut self, arg0: i16) -> u8;
    fn i16_from_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_try_into_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_unwrap_into_u16(&mut self, arg0: i16) -> u16;
    fn i16_cast_unsigned(&mut self, arg0: i16) -> u16;
    fn i16_from_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_into_i32(&mut self, arg0: i16) -> i32;
    fn i16_from_i32(&mut self, arg0: i16) -> Option<i32>;
    fn i16_try_into_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_unwrap_into_u32(&mut self, arg0: i16) -> u32;
    fn i16_from_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_into_i64(&mut self, arg0: i16) -> i64;
    fn i16_from_i64(&mut self, arg0: i16) -> Option<i64>;
    fn i16_try_into_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_unwrap_into_u64(&mut self, arg0: i16) -> u64;
    fn i16_from_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_into_i128(&mut self, arg0: i16) -> i128;
    fn i16_from_i128(&mut self, arg0: i16) -> Option<i128>;
    fn i16_try_into_u128(&mut self, arg0: i16) -> Option<u128>;
    fn i16_unwrap_into_u128(&mut self, arg0: i16) -> u128;
    fn i16_from_u128(&mut self, arg0: i16) -> Option<u128>;
    fn u16_try_into_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_unwrap_into_i8(&mut self, arg0: u16) -> i8;
    fn u16_from_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_try_into_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_unwrap_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_truncate_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_from_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_try_into_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_unwrap_into_i16(&mut self, arg0: u16) -> i16;
    fn u16_cast_signed(&mut self, arg0: u16) -> i16;
    fn u16_from_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_into_i32(&mut self, arg0: u16) -> i32;
    fn u16_from_i32(&mut self, arg0: u16) -> Option<i32>;
    fn u16_into_u32(&mut self, arg0: u16) -> u32;
    fn u16_from_u32(&mut self, arg0: u16) -> Option<u32>;
    fn u16_into_i64(&mut self, arg0: u16) -> i64;
    fn u16_from_i64(&mut self, arg0: u16) -> Option<i64>;
    fn u16_into_u64(&mut self, arg0: u16) -> u64;
    fn u16_from_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u16_into_i128(&mut self, arg0: u16) -> i128;
    fn u16_from_i128(&mut self, arg0: u16) -> Option<i128>;
    fn u16_into_u128(&mut self, arg0: u16) -> u128;
    fn u16_from_u128(&mut self, arg0: u16) -> Option<u128>;
    fn i32_try_into_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_unwrap_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_truncate_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_from_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_try_into_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_unwrap_into_u8(&mut self, arg0: i32) -> u8;
    fn i32_from_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_try_into_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_unwrap_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_truncate_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_from_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_try_into_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_unwrap_into_u16(&mut self, arg0: i32) -> u16;
    fn i32_from_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_try_into_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_unwrap_into_u32(&mut self, arg0: i32) -> u32;
    fn i32_cast_unsigned(&mut self, arg0: i32) -> u32;
    fn i32_from_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_into_i64(&mut self, arg0: i32) -> i64;
    fn i32_from_i64(&mut self, arg0: i32) -> Option<i64>;
    fn i32_try_into_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_unwrap_into_u64(&mut self, arg0: i32) -> u64;
    fn i32_from_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_into_i128(&mut self, arg0: i32) -> i128;
    fn i32_from_i128(&mut self, arg0: i32) -> Option<i128>;
    fn i32_try_into_u128(&mut self, arg0: i32) -> Option<u128>;
    fn i32_unwrap_into_u128(&mut self, arg0: i32) -> u128;
    fn i32_from_u128(&mut self, arg0: i32) -> Option<u128>;
    fn u32_try_into_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_unwrap_into_i8(&mut self, arg0: u32) -> i8;
    fn u32_from_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_try_into_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_unwrap_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_truncate_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_from_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_try_into_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_unwrap_into_i16(&mut self, arg0: u32) -> i16;
    fn u32_from_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_try_into_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_unwrap_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_truncate_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_from_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_try_into_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_unwrap_into_i32(&mut self, arg0: u32) -> i32;
    fn u32_cast_signed(&mut self, arg0: u32) -> i32;
    fn u32_from_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_into_i64(&mut self, arg0: u32) -> i64;
    fn u32_from_i64(&mut self, arg0: u32) -> Option<i64>;
    fn u32_into_u64(&mut self, arg0: u32) -> u64;
    fn u32_from_u64(&mut self, arg0: u32) -> Option<u64>;
    fn u32_into_i128(&mut self, arg0: u32) -> i128;
    fn u32_from_i128(&mut self, arg0: u32) -> Option<i128>;
    fn u32_into_u128(&mut self, arg0: u32) -> u128;
    fn u32_from_u128(&mut self, arg0: u32) -> Option<u128>;
    fn i64_try_into_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_unwrap_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_truncate_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_from_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_try_into_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_unwrap_into_u8(&mut self, arg0: i64) -> u8;
    fn i64_from_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_try_into_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_unwrap_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_truncate_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_from_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_try_into_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_unwrap_into_u16(&mut self, arg0: i64) -> u16;
    fn i64_from_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_try_into_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_unwrap_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_truncate_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_from_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_try_into_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_unwrap_into_u32(&mut self, arg0: i64) -> u32;
    fn i64_from_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_try_into_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_unwrap_into_u64(&mut self, arg0: i64) -> u64;
    fn i64_cast_unsigned(&mut self, arg0: i64) -> u64;
    fn i64_from_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_into_i128(&mut self, arg0: i64) -> i128;
    fn i64_from_i128(&mut self, arg0: i64) -> Option<i128>;
    fn i64_try_into_u128(&mut self, arg0: i64) -> Option<u128>;
    fn i64_unwrap_into_u128(&mut self, arg0: i64) -> u128;
    fn i64_from_u128(&mut self, arg0: i64) -> Option<u128>;
    fn u64_try_into_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_unwrap_into_i8(&mut self, arg0: u64) -> i8;
    fn u64_from_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_try_into_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_unwrap_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_truncate_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_from_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_try_into_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_unwrap_into_i16(&mut self, arg0: u64) -> i16;
    fn u64_from_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_try_into_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_unwrap_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_truncate_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_from_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_try_into_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_unwrap_into_i32(&mut self, arg0: u64) -> i32;
    fn u64_from_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_try_into_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_unwrap_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_truncate_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_from_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_try_into_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_unwrap_into_i64(&mut self, arg0: u64) -> i64;
    fn u64_cast_signed(&mut self, arg0: u64) -> i64;
    fn u64_from_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_into_i128(&mut self, arg0: u64) -> i128;
    fn u64_from_i128(&mut self, arg0: u64) -> Option<i128>;
    fn u64_into_u128(&mut self, arg0: u64) -> u128;
    fn u64_from_u128(&mut self, arg0: u64) -> Option<u128>;
    fn i128_try_into_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_unwrap_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_truncate_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_from_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_try_into_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_unwrap_into_u8(&mut self, arg0: i128) -> u8;
    fn i128_from_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_try_into_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_unwrap_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_truncate_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_from_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_try_into_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_unwrap_into_u16(&mut self, arg0: i128) -> u16;
    fn i128_from_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_try_into_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_unwrap_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_truncate_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_from_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_try_into_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_unwrap_into_u32(&mut self, arg0: i128) -> u32;
    fn i128_from_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_try_into_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_unwrap_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_truncate_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_from_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_try_into_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_unwrap_into_u64(&mut self, arg0: i128) -> u64;
    fn i128_from_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_try_into_u128(&mut self, arg0: i128) -> Option<u128>;
    fn i128_unwrap_into_u128(&mut self, arg0: i128) -> u128;
    fn i128_cast_unsigned(&mut self, arg0: i128) -> u128;
    fn i128_from_u128(&mut self, arg0: i128) -> Option<u128>;
    fn u128_try_into_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_unwrap_into_i8(&mut self, arg0: u128) -> i8;
    fn u128_from_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_try_into_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_unwrap_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_truncate_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_from_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_try_into_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_unwrap_into_i16(&mut self, arg0: u128) -> i16;
    fn u128_from_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_try_into_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_unwrap_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_truncate_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_from_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_try_into_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_unwrap_into_i32(&mut self, arg0: u128) -> i32;
    fn u128_from_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_try_into_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_unwrap_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_truncate_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_from_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_try_into_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_unwrap_into_i64(&mut self, arg0: u128) -> i64;
    fn u128_from_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_try_into_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_unwrap_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_truncate_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_from_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_try_into_i128(&mut self, arg0: u128) -> Option<i128>;
    fn u128_unwrap_into_i128(&mut self, arg0: u128) -> i128;
    fn u128_cast_signed(&mut self, arg0: u128) -> i128;
    fn u128_from_i128(&mut self, arg0: u128) -> Option<i128>;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
}

pub trait IntoContextIter {
    type Context;
    type Output;
    type IntoIter: ContextIter<Context = Self::Context, Output = Self::Output>;
    fn into_context_iter(self) -> Self::IntoIter;
}

pub trait Length {
    fn len(&self) -> usize;
}

impl<T> Length for std::vec::Vec<T> {
    fn len(&self) -> usize {
        std::vec::Vec::len(self)
    }
}

pub struct ContextIterWrapper<I, C> {
    iter: I,
    _ctx: std::marker::PhantomData<C>,
}
impl<I: Default, C> Default for ContextIterWrapper<I, C> {
    fn default() -> Self {
        ContextIterWrapper {
            iter: I::default(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<I, C> std::ops::Deref for ContextIterWrapper<I, C> {
    type Target = I;
    fn deref(&self) -> &I {
        &self.iter
    }
}
impl<I, C> std::ops::DerefMut for ContextIterWrapper<I, C> {
    fn deref_mut(&mut self) -> &mut I {
        &mut self.iter
    }
}
impl<I: Iterator, C: Context> From<I> for ContextIterWrapper<I, C> {
    fn from(iter: I) -> Self {
        Self { iter, _ctx: std::marker::PhantomData }
    }
}
impl<I: Iterator, C: Context> ContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}
impl<I: IntoIterator, C: Context> IntoContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    type IntoIter = ContextIterWrapper<I::IntoIter, C>;
    fn into_context_iter(self) -> Self::IntoIter {
        ContextIterWrapper {
            iter: self.iter.into_iter(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<T, E: Extend<T>, C> Extend<T> for ContextIterWrapper<E, C> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        self.iter.extend(iter);
    }
}
impl<L: Length, C> Length for ContextIterWrapper<L, C> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}
           

/// Internal type MultiReg: defined at src/prelude_lower.isle line 16.
#[derive(Clone, Debug)]
pub enum MultiReg {
    Empty,
    One {
        a: Reg,
    },
    Two {
        a: Reg,
        b: Reg,
    },
    Three {
        a: Reg,
        b: Reg,
        c: Reg,
    },
    Four {
        a: Reg,
        b: Reg,
        c: Reg,
        d: Reg,
    },
}

/// Internal type SideEffectNoResult: defined at src/prelude_lower.isle line 439.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst {
        inst: MInst,
    },
    Inst2 {
        inst1: MInst,
        inst2: MInst,
    },
    Inst3 {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
    },
}

/// Internal type ProducesFlags: defined at src/prelude_lower.isle line 492.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    AlreadyExistingFlags,
    ProducesFlagsSideEffect {
        inst: MInst,
    },
    ProducesFlagsTwiceSideEffect {
        inst1: MInst,
        inst2: MInst,
    },
    ProducesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ProducesFlagsReturnsResultWithConsumer {
        inst: MInst,
        result: Reg,
    },
}

/// Internal type ConsumesAndProducesFlags: defined at src/prelude_lower.isle line 511.
#[derive(Clone, Debug)]
pub enum ConsumesAndProducesFlags {
    SideEffect {
        inst: MInst,
    },
    ReturnsReg {
        inst: MInst,
        result: Reg,
    },
}

/// Internal type ConsumesFlags: defined at src/prelude_lower.isle line 519.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsSideEffect {
        inst: MInst,
    },
    ConsumesFlagsSideEffect2 {
        inst1: MInst,
        inst2: MInst,
    },
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src/isa/pulley_shared/inst.isle line 10.
#[derive(Clone, Debug)]
pub enum MInst {
    Args {
        args: VecArgPair,
    },
    Rets {
        rets: VecRetPair,
    },
    DummyUse {
        reg: Reg,
    },
    BrTable {
        idx: XReg,
        default: MachLabel,
        targets: BoxVecMachLabel,
    },
    TrapIf {
        cond: Cond,
        code: TrapCode,
    },
    Nop,
    GetSpecial {
        dst: WritableXReg,
        reg: XReg,
    },
    LoadExtNameNear {
        dst: WritableXReg,
        name: BoxExternalName,
        offset: i64,
    },
    LoadExtNameFar {
        dst: WritableXReg,
        name: BoxExternalName,
        offset: i64,
    },
    Call {
        info: BoxCallInfo,
    },
    IndirectCall {
        info: BoxCallIndInfo,
    },
    ReturnCall {
        info: BoxReturnCallInfo,
    },
    ReturnIndirectCall {
        info: BoxReturnCallIndInfo,
    },
    IndirectCallHost {
        info: BoxCallIndirectHostInfo,
    },
    Jump {
        label: MachLabel,
    },
    BrIf {
        cond: Cond,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    LoadAddr {
        dst: WritableXReg,
        mem: Amode,
    },
    XLoad {
        dst: WritableXReg,
        mem: Amode,
        ty: Type,
        flags: MemFlags,
    },
    FLoad {
        dst: WritableFReg,
        mem: Amode,
        ty: Type,
        flags: MemFlags,
    },
    VLoad {
        dst: WritableVReg,
        mem: Amode,
        ty: Type,
        flags: MemFlags,
    },
    XStore {
        mem: Amode,
        src: XReg,
        ty: Type,
        flags: MemFlags,
    },
    FStore {
        mem: Amode,
        src: FReg,
        ty: Type,
        flags: MemFlags,
    },
    VStore {
        mem: Amode,
        src: VReg,
        ty: Type,
        flags: MemFlags,
    },
    Raw {
        raw: RawInst,
    },
    EmitIsland {
        space_needed: u32,
    },
    LabelAddress {
        dst: WritableXReg,
        label: MachLabel,
    },
    SequencePoint,
}

/// Internal type Cond: defined at src/isa/pulley_shared/inst.isle line 107.
#[derive(Clone, Debug)]
pub enum Cond {
    If32 {
        reg: XReg,
    },
    IfNot32 {
        reg: XReg,
    },
    IfXeq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXneq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXslt32 {
        src1: XReg,
        src2: XReg,
    },
    IfXslteq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXult32 {
        src1: XReg,
        src2: XReg,
    },
    IfXulteq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXeq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXneq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslt32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslteq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXult32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXulteq32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXsgt32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXsgteq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXugt32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXugteq32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXeq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXneq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXslt64 {
        src1: XReg,
        src2: XReg,
    },
    IfXslteq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXult64 {
        src1: XReg,
        src2: XReg,
    },
    IfXulteq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXeq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXneq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslt64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslteq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXult64I32 {
        src1: XReg,
        src2: u32,
    },
    IfXulteq64I32 {
        src1: XReg,
        src2: u32,
    },
    IfXsgt64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXsgteq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXugt64I32 {
        src1: XReg,
        src2: u32,
    },
    IfXugteq64I32 {
        src1: XReg,
        src2: u32,
    },
}

/// Internal type ExtKind: defined at src/isa/pulley_shared/inst.isle line 172.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ExtKind {
    None,
    Sign32,
    Sign64,
    Zero32,
    Zero64,
}

/// Internal type VExtKind: defined at src/isa/pulley_shared/inst.isle line 173.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum VExtKind {
    None,
    S8x8,
    U8x8,
    S16x4,
    U16x4,
    S32x2,
    U32x2,
}

/// Internal type ValueOffset: defined at src/isa/pulley_shared/inst.isle line 181.
#[derive(Clone, Debug)]
pub enum ValueOffset {
    Both {
        value: Value,
        offset: i32,
    },
}

/// Internal type Amode: defined at src/isa/pulley_shared/inst.isle line 190.
#[derive(Clone, Debug)]
pub enum Amode {
    SpOffset {
        offset: i32,
    },
    RegOffset {
        base: XReg,
        offset: i32,
    },
    Stack {
        amode: StackAMode,
    },
}

/// Internal type AddrO32: defined at src/isa/pulley_shared/inst.isle line 204.
#[derive(Clone, Debug)]
pub enum AddrO32 {
    Base {
        addr: XReg,
        offset: i32,
    },
}

/// Internal type AddrZ: defined at src/isa/pulley_shared/inst.isle line 217.
#[derive(Clone, Debug)]
pub enum AddrZ {
    Base {
        addr: XReg,
        offset: i32,
    },
}

/// Internal type AddrG32: defined at src/isa/pulley_shared/inst.isle line 230.
#[derive(Clone, Debug)]
pub enum AddrG32 {
    RegisterBound {
        host_heap_base: XReg,
        host_heap_bound: XReg,
        wasm_addr: XReg,
        offset: u16,
    },
}

/// Internal type AddrG32Bne: defined at src/isa/pulley_shared/inst.isle line 239.
#[derive(Clone, Debug)]
pub enum AddrG32Bne {
    BoundNe {
        host_heap_base: XReg,
        host_heap_bound_addr: XReg,
        host_heap_bound_offset: u8,
        wasm_addr: XReg,
        offset: u8,
    },
}

/// Internal type SinkableLoad: defined at src/isa/pulley_shared/inst.isle line 269.
#[derive(Clone, Debug)]
pub enum SinkableLoad {
    Load {
        inst: Inst,
        ty: Type,
        addr: Value,
        offset: u8,
    },
}

/// Internal type SunkLoad: defined at src/isa/pulley_shared/inst.isle line 284.
#[derive(Clone, Debug)]
pub enum SunkLoad {
    Load {
        ty: Type,
        addr: Value,
        offset: u8,
    },
}

/// Internal type G32: defined at src/isa/pulley_shared/inst.isle line 304.
#[derive(Clone, Debug)]
pub enum G32 {
    All {
        heap_base: Value,
        heap_bound: Value,
        wasm_addr: Value,
        offset: u16,
    },
}

/// Internal type G32Bne: defined at src/isa/pulley_shared/inst.isle line 313.
#[derive(Clone, Debug)]
pub enum G32Bne {
    All {
        heap_base: Value,
        heap_bound: SinkableLoad,
        wasm_addr: Value,
        offset: u8,
    },
}

/// Internal type HostOffset: defined at src/isa/pulley_shared/inst.isle line 381.
#[derive(Clone, Debug)]
pub enum HostOffset {
    All {
        a: Value,
        b: i32,
    },
}

/// Internal type OobSelect: defined at src/isa/pulley_shared/inst.isle line 390.
#[derive(Clone, Debug)]
pub enum OobSelect {
    All {
        a: Value,
        b: Value,
        c: Value,
        d: u64,
    },
}

/// Internal type OobCond: defined at src/isa/pulley_shared/inst.isle line 428.
#[derive(Clone, Debug)]
pub enum OobCond {
    All {
        a: Value,
        b: u64,
    },
}

/// Internal type RawInst: defined at <OUT_DIR>/pulley_gen.isle line 0.
#[derive(Clone, Debug)]
pub enum RawInst {
    Ret,
    XJump {
        reg: XReg,
    },
    Xmov {
        dst: WritableXReg,
        src: XReg,
    },
    Xzero {
        dst: WritableXReg,
    },
    Xone {
        dst: WritableXReg,
    },
    Xconst8 {
        dst: WritableXReg,
        imm: i8,
    },
    Xconst16 {
        dst: WritableXReg,
        imm: i16,
    },
    Xconst32 {
        dst: WritableXReg,
        imm: i32,
    },
    Xconst64 {
        dst: WritableXReg,
        imm: i64,
    },
    Xadd32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xadd32U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xadd32U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    Xadd64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xadd64U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xadd64U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    Xmadd32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        src3: XReg,
    },
    Xmadd64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        src3: XReg,
    },
    Xsub32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xsub32U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xsub32U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    Xsub64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xsub64U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xsub64U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    XMul32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmul32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xmul32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XMul64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmul64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xmul64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    Xctz32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xctz64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xclz32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xclz64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xpopcnt32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xpopcnt64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xrotl32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xrotl64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xrotr32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xrotr64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshl32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshl64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshl32U6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr32SU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr32UU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshl64U6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr64SU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr64UU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xneg32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xneg64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xeq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xneq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslt64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslteq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xult64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xulteq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xeq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xneq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslt32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslteq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xult32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xulteq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XLoad8U32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad8S32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad16LeU32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad16LeS32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad32LeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad64LeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XStore8O32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore16LeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore32LeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore64LeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XLoad8U32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad8S32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad16LeU32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad16LeS32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad32LeZ {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad64LeZ {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XStore8Z {
        addr: AddrZ,
        src: XReg,
    },
    XStore16LeZ {
        addr: AddrZ,
        src: XReg,
    },
    XStore32LeZ {
        addr: AddrZ,
        src: XReg,
    },
    XStore64LeZ {
        addr: AddrZ,
        src: XReg,
    },
    XLoad8U32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad8S32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad16LeU32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad16LeS32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad32LeG32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad64LeG32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XStore8G32 {
        addr: AddrG32,
        src: XReg,
    },
    XStore16LeG32 {
        addr: AddrG32,
        src: XReg,
    },
    XStore32LeG32 {
        addr: AddrG32,
        src: XReg,
    },
    XStore64LeG32 {
        addr: AddrG32,
        src: XReg,
    },
    XLoad8U32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad8S32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad16LeU32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad16LeS32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad32LeG32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad64LeG32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XStore8G32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    XStore16LeG32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    XStore32LeG32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    XStore64LeG32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    PushFrame,
    PopFrame,
    PushFrameSave {
        amt: u16,
        regs: UpperXRegSet,
    },
    PopFrameRestore {
        amt: u16,
        regs: UpperXRegSet,
    },
    StackAlloc32 {
        amt: u32,
    },
    StackFree32 {
        amt: u32,
    },
    Zext8 {
        dst: WritableXReg,
        src: XReg,
    },
    Zext16 {
        dst: WritableXReg,
        src: XReg,
    },
    Zext32 {
        dst: WritableXReg,
        src: XReg,
    },
    Sext8 {
        dst: WritableXReg,
        src: XReg,
    },
    Sext16 {
        dst: WritableXReg,
        src: XReg,
    },
    Sext32 {
        dst: WritableXReg,
        src: XReg,
    },
    XAbs32 {
        dst: WritableXReg,
        src: XReg,
    },
    XAbs64 {
        dst: WritableXReg,
        src: XReg,
    },
    XDiv32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XDiv64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XDiv32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XDiv64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XBand32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xband32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xband32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBand64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xband64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xband64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBor32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbor32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbor32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBor64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbor64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbor64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBxor32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbxor32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbxor32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBxor64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbxor64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbxor64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBnot32 {
        dst: WritableXReg,
        src: XReg,
    },
    XBnot64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xmin32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmin32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmin64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmin64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XSelect32 {
        dst: WritableXReg,
        cond: XReg,
        if_nonzero: XReg,
        if_zero: XReg,
    },
    XSelect64 {
        dst: WritableXReg,
        cond: XReg,
        if_nonzero: XReg,
        if_zero: XReg,
    },
    Trap {
        code: TrapCode,
    },
    Nop,
    Xpcadd {
        dst: WritableXReg,
        offset: PcRelOffset,
    },
    XmovFp {
        dst: WritableXReg,
    },
    XmovLr {
        dst: WritableXReg,
    },
    Bswap32 {
        dst: WritableXReg,
        src: XReg,
    },
    Bswap64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xadd32UoverflowTrap {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        code: TrapCode,
    },
    Xadd64UoverflowTrap {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        code: TrapCode,
    },
    XMulHi64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XMulHi64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbmask32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xbmask64 {
        dst: WritableXReg,
        src: XReg,
    },
    XLoad16BeU32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad16BeS32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad32BeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad64BeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XStore16BeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore32BeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore64BeO32 {
        addr: AddrO32,
        src: XReg,
    },
    Fload32BeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fload64BeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fstore32BeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fstore64BeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fload32LeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fload64LeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fstore32LeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fstore64LeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fload32LeZ {
        dst: WritableFReg,
        addr: AddrZ,
    },
    Fload64LeZ {
        dst: WritableFReg,
        addr: AddrZ,
    },
    Fstore32LeZ {
        addr: AddrZ,
        src: FReg,
    },
    Fstore64LeZ {
        addr: AddrZ,
        src: FReg,
    },
    Fload32LeG32 {
        dst: WritableFReg,
        addr: AddrG32,
    },
    Fload64LeG32 {
        dst: WritableFReg,
        addr: AddrG32,
    },
    Fstore32LeG32 {
        addr: AddrG32,
        src: FReg,
    },
    Fstore64LeG32 {
        addr: AddrG32,
        src: FReg,
    },
    VLoad128O32 {
        dst: WritableVReg,
        addr: AddrO32,
    },
    Vstore128LeO32 {
        addr: AddrO32,
        src: VReg,
    },
    VLoad128Z {
        dst: WritableVReg,
        addr: AddrZ,
    },
    Vstore128LeZ {
        addr: AddrZ,
        src: VReg,
    },
    VLoad128G32 {
        dst: WritableVReg,
        addr: AddrG32,
    },
    Vstore128LeG32 {
        addr: AddrG32,
        src: VReg,
    },
    Fmov {
        dst: WritableFReg,
        src: FReg,
    },
    Vmov {
        dst: WritableVReg,
        src: VReg,
    },
    BitcastIntFromFloat32 {
        dst: WritableXReg,
        src: FReg,
    },
    BitcastIntFromFloat64 {
        dst: WritableXReg,
        src: FReg,
    },
    BitcastFloatFromInt32 {
        dst: WritableFReg,
        src: XReg,
    },
    BitcastFloatFromInt64 {
        dst: WritableFReg,
        src: XReg,
    },
    FConst32 {
        dst: WritableFReg,
        bits: u32,
    },
    FConst64 {
        dst: WritableFReg,
        bits: u64,
    },
    Feq32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Fneq32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flt32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flteq32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Feq64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Fneq64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flt64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flteq64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    FSelect32 {
        dst: WritableFReg,
        cond: XReg,
        if_nonzero: FReg,
        if_zero: FReg,
    },
    FSelect64 {
        dst: WritableFReg,
        cond: XReg,
        if_nonzero: FReg,
        if_zero: FReg,
    },
    F32FromF64 {
        dst: WritableFReg,
        src: FReg,
    },
    F64FromF32 {
        dst: WritableFReg,
        src: FReg,
    },
    F32FromX32S {
        dst: WritableFReg,
        src: XReg,
    },
    F32FromX32U {
        dst: WritableFReg,
        src: XReg,
    },
    F32FromX64S {
        dst: WritableFReg,
        src: XReg,
    },
    F32FromX64U {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX32S {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX32U {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX64S {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX64U {
        dst: WritableFReg,
        src: XReg,
    },
    X32FromF32S {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF32U {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64S {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64U {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32S {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32U {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64S {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64U {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF32SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF32USat {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64USat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32USat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64USat {
        dst: WritableXReg,
        src: FReg,
    },
    FCopySign32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    FCopySign64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fadd32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fsub32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Vsubf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fmul32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Vmulf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fdiv32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Vdivf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fmaximum32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fminimum32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Ftrunc32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vtrunc32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vtrunc64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Ffloor32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vfloor32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vfloor64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fceil32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vceil32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vceil64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fnearest32 {
        dst: WritableFReg,
        src: FReg,
    },
    Fsqrt32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vsqrt32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vsqrt64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fneg32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vnegf32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Fabs32 {
        dst: WritableFReg,
        src: FReg,
    },
    Fadd64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fsub64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fmul64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fdiv64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    VDivF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fmaximum64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fminimum64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Ftrunc64 {
        dst: WritableFReg,
        src: FReg,
    },
    Ffloor64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fceil64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fnearest64 {
        dst: WritableFReg,
        src: FReg,
    },
    Vnearest32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vnearest64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fsqrt64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fneg64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fabs64 {
        dst: WritableFReg,
        src: FReg,
    },
    Vconst128 {
        dst: WritableVReg,
        imm: u128,
    },
    VAddI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddU8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddU16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddpairwiseI16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddpairwiseI32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VShlI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShlI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShlI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShlI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI8x16S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI64x2S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI8x16U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI64x2U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VSplatX8 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatX16 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatX32 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatX64 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatF32 {
        dst: WritableVReg,
        src: FReg,
    },
    VSplatF64 {
        dst: WritableVReg,
        src: FReg,
    },
    VLoad8x8SZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad8x8UZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad16x4LeSZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad16x4LeUZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad32x2LeSZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad32x2LeUZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VBand128 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VBor128 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VBxor128 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VBnot128 {
        dst: WritableVReg,
        src: VReg,
    },
    VBitselect128 {
        dst: WritableVReg,
        c: VReg,
        x: VReg,
        y: VReg,
    },
    Vbitmask8x16 {
        dst: WritableXReg,
        src: VReg,
    },
    Vbitmask16x8 {
        dst: WritableXReg,
        src: VReg,
    },
    Vbitmask32x4 {
        dst: WritableXReg,
        src: VReg,
    },
    Vbitmask64x2 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue8x16 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue16x8 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue32x4 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue64x2 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue8x16 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue16x8 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue32x4 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue64x2 {
        dst: WritableXReg,
        src: VReg,
    },
    VF32x4FromI32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VF32x4FromI32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    VF64x2FromI64x2S {
        dst: WritableVReg,
        src: VReg,
    },
    VF64x2FromI64x2U {
        dst: WritableVReg,
        src: VReg,
    },
    VI32x4FromF32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VI32x4FromF32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    VI64x2FromF64x2S {
        dst: WritableVReg,
        src: VReg,
    },
    VI64x2FromF64x2U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow8x16S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow8x16U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow16x8S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow16x8U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh8x16S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh8x16U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh16x8S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh16x8U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    Vnarrow16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow64x2S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow64x2U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vunarrow64x2U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VFpromoteLow {
        dst: WritableVReg,
        src: VReg,
    },
    VFdemote {
        dst: WritableVReg,
        src: VReg,
    },
    VSubI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubU8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubU16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VQmulrsI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VPopcnt8x16 {
        dst: WritableVReg,
        src: VReg,
    },
    XExtractV8x16 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    XExtractV16x8 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    XExtractV32x4 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    XExtractV64x2 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    FExtractV32x4 {
        dst: WritableFReg,
        src: VReg,
        lane: u8,
    },
    FExtractV64x2 {
        dst: WritableFReg,
        src: VReg,
        lane: u8,
    },
    VInsertX8 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertX16 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertX32 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertX64 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertF32 {
        dst: WritableVReg,
        src1: VReg,
        src2: FReg,
        lane: u8,
    },
    VInsertF64 {
        dst: WritableVReg,
        src1: VReg,
        src2: FReg,
        lane: u8,
    },
    Veq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Veq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Veq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Veq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneg8x16 {
        dst: WritableVReg,
        src: VReg,
    },
    Vneg16x8 {
        dst: WritableVReg,
        src: VReg,
    },
    Vneg32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vneg64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    VnegF64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Vmin8x16S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin8x16U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax8x16S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax8x16U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vabs8x16 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabs16x8 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabs32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabs64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabsf32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabsf64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Vmaximumf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmaximumf64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vminimumf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vminimumf64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VShuffle {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
        mask: u128,
    },
    Vswizzlei8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vavground8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vavground16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VeqF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VneqF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VltF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VlteqF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VeqF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VneqF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VltF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VlteqF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vfma32x4 {
        dst: WritableVReg,
        a: VReg,
        b: VReg,
        c: VReg,
    },
    Vfma64x2 {
        dst: WritableVReg,
        a: VReg,
        b: VReg,
        c: VReg,
    },
    Vselect {
        dst: WritableVReg,
        cond: XReg,
        if_nonzero: VReg,
        if_zero: VReg,
    },
    Xadd128 {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs_lo: XReg,
        lhs_hi: XReg,
        rhs_lo: XReg,
        rhs_hi: XReg,
    },
    Xsub128 {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs_lo: XReg,
        lhs_hi: XReg,
        rhs_lo: XReg,
        rhs_hi: XReg,
    },
    Xwidemul64S {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs: XReg,
        rhs: XReg,
    },
    Xwidemul64U {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs: XReg,
        rhs: XReg,
    },
}

// Generated as internal constructor for term ty_shift_mask.
pub fn constructor_ty_shift_mask<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> u64 {
    let v1 = C::lane_type(ctx, arg0);
    let v2 = C::ty_bits(ctx, v1);
    let v3 = C::u8_into_u64(ctx, v2);
    let v5 = C::u64_sub(ctx, v3, 0x1_u64);
    // Rule at src/prelude.isle line 293.
    return v5;
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> InstOutput {
    let v1 = C::value_reg(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src/prelude_lower.isle line 81.
    return v2;
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> InstOutput {
    let v1 = C::put_in_regs(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src/prelude_lower.isle line 85.
    return v2;
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Reg {
    let v1 = C::temp_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/prelude_lower.isle line 97.
    return v2;
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v1 = C::put_in_regs(ctx, arg0);
    let v3 = C::value_regs_get(ctx, v1, 0x0_usize);
    // Rule at src/prelude_lower.isle line 162.
    return v3;
}

// Generated as internal constructor for term multi_reg_to_pair_and_single.
pub fn constructor_multi_reg_to_pair_and_single<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::Three {
        a: v1,
        b: v2,
        c: v3,
    } = arg0 {
        let v4 = C::value_regs(ctx, v1, v2);
        let v5 = C::value_reg(ctx, v3);
        let v6 = C::output_pair(ctx, v4, v5);
        // Rule at src/prelude_lower.isle line 173.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_pair_and_single", "src/prelude_lower.isle line 172")
}

// Generated as internal constructor for term multi_reg_to_pair.
pub fn constructor_multi_reg_to_pair<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::Two {
        a: v1,
        b: v2,
    } = arg0 {
        let v3 = C::value_regs(ctx, v1, v2);
        let v4 = C::output(ctx, v3);
        // Rule at src/prelude_lower.isle line 178.
        return v4;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_pair", "src/prelude_lower.isle line 177")
}

// Generated as internal constructor for term multi_reg_to_single.
pub fn constructor_multi_reg_to_single<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::One {
        a: v1,
    } = arg0 {
        let v2 = C::value_reg(ctx, v1);
        let v3 = C::output(ctx, v2);
        // Rule at src/prelude_lower.isle line 183.
        return v3;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_single", "src/prelude_lower.isle line 182")
}

// Generated as internal constructor for term emit_side_effect.
pub fn constructor_emit_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> Unit {
    match arg0 {
        &SideEffectNoResult::Inst {
            inst: ref v1,
        } => {
            let v2 = C::emit(ctx, v1);
            // Rule at src/prelude_lower.isle line 451.
            return v2;
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v3,
            inst2: ref v4,
        } => {
            let v5 = C::emit(ctx, v3);
            let v6 = C::emit(ctx, v4);
            // Rule at src/prelude_lower.isle line 453.
            return v6;
        }
        &SideEffectNoResult::Inst3 {
            inst1: ref v7,
            inst2: ref v8,
            inst3: ref v9,
        } => {
            let v10 = C::emit(ctx, v7);
            let v11 = C::emit(ctx, v8);
            let v12 = C::emit(ctx, v9);
            // Rule at src/prelude_lower.isle line 456.
            return v12;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_side_effect", "src/prelude_lower.isle line 450")
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> InstOutput {
    let v1 = constructor_emit_side_effect(ctx, arg0);
    let v2 = C::output_none(ctx);
    // Rule at src/prelude_lower.isle line 466.
    return v2;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> SideEffectNoResult {
    match arg0 {
        &SideEffectNoResult::Inst {
            inst: ref v1,
        } => {
            match arg1 {
                &SideEffectNoResult::Inst {
                    inst: ref v3,
                } => {
                    let v4 = SideEffectNoResult::Inst2 {
                        inst1: v1.clone(),
                        inst2: v3.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 471.
                    return v4;
                }
                &SideEffectNoResult::Inst2 {
                    inst1: ref v5,
                    inst2: ref v6,
                } => {
                    let v7 = SideEffectNoResult::Inst3 {
                        inst1: v1.clone(),
                        inst2: v5.clone(),
                        inst3: v6.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 473.
                    return v7;
                }
                _ => {}
            }
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v8,
            inst2: ref v9,
        } => {
            if let &SideEffectNoResult::Inst {
                inst: ref v3,
            } = arg1 {
                let v10 = SideEffectNoResult::Inst3 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                    inst3: v3.clone(),
                };
                // Rule at src/prelude_lower.isle line 475.
                return v10;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "side_effect_concat", "src/prelude_lower.isle line 470")
}

// Generated as internal constructor for term side_effect_as_invalid.
pub fn constructor_side_effect_as_invalid<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> InstOutput {
    let v1 = constructor_side_effect(ctx, arg0);
    let v2 = C::invalid_reg(ctx);
    let v3 = constructor_output_reg(ctx, v2);
    // Rule at src/prelude_lower.isle line 481.
    return v3;
}

// Generated as internal constructor for term produces_flags_concat.
pub fn constructor_produces_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ProducesFlags,
) -> ProducesFlags {
    if let &ProducesFlags::ProducesFlagsSideEffect {
        inst: ref v1,
    } = arg0 {
        if let &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v3,
        } = arg1 {
            let v4 = ProducesFlags::ProducesFlagsTwiceSideEffect {
                inst1: v1.clone(),
                inst2: v3.clone(),
            };
            // Rule at src/prelude_lower.isle line 507.
            return v4;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_concat", "src/prelude_lower.isle line 506")
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Reg {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            // Rule at src/prelude_lower.isle line 537.
            return v2;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v3,
            result: v4,
        } => {
            // Rule at src/prelude_lower.isle line 538.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_get_reg", "src/prelude_lower.isle line 536")
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> ProducesFlags {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            let v3 = ProducesFlags::ProducesFlagsSideEffect {
                inst: v1.clone(),
            };
            // Rule at src/prelude_lower.isle line 543.
            return v3;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v4,
            result: v5,
        } => {
            let v6 = ProducesFlags::ProducesFlagsSideEffect {
                inst: v4.clone(),
            };
            // Rule at src/prelude_lower.isle line 545.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_ignore", "src/prelude_lower.isle line 542")
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> ConsumesFlags {
    match arg0 {
        &ConsumesFlags::ConsumesFlagsSideEffect {
            inst: ref v8,
        } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref v9,
            } = arg1 {
                let v10 = ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                };
                // Rule at src/prelude_lower.isle line 558.
                return v10;
            }
        }
        &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            if let &ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: ref v4,
                result: v5,
            } = arg1 {
                let v6 = C::value_regs(ctx, v2, v5);
                let v7 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: v1.clone(),
                    inst2: v4.clone(),
                    result: v6,
                };
                // Rule at src/prelude_lower.isle line 552.
                return v7;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_concat", "src/prelude_lower.isle line 551")
}

// Generated as internal constructor for term consumes_flags_get_reg.
pub fn constructor_consumes_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
) -> Reg {
    if let &ConsumesFlags::ConsumesFlagsReturnsReg {
        inst: ref v1,
        result: v2,
    } = arg0 {
        // Rule at src/prelude_lower.isle line 565.
        return v2;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_get_reg", "src/prelude_lower.isle line 564")
}

// Generated as internal constructor for term consumes_flags_get_regs.
pub fn constructor_consumes_flags_get_regs<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
) -> ValueRegs {
    if let &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
        inst1: ref v1,
        inst2: ref v2,
        result: v3,
    } = arg0 {
        // Rule at src/prelude_lower.isle line 567.
        return v3;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_get_regs", "src/prelude_lower.isle line 566")
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> ValueRegs {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v12,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v16 = C::emit(ctx, v13);
                    let v17 = C::value_reg(ctx, v14);
                    // Rule at src/prelude_lower.isle line 595.
                    return v17;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v21 = C::emit(ctx, v18);
                    let v22 = C::emit(ctx, v19);
                    // Rule at src/prelude_lower.isle line 601.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v28 = C::emit(ctx, v23);
                    let v29 = C::emit(ctx, v24);
                    let v30 = C::emit(ctx, v25);
                    let v31 = C::emit(ctx, v26);
                    // Rule at src/prelude_lower.isle line 613.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v32,
            inst2: ref v33,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v36 = C::emit(ctx, v13);
                    let v37 = C::value_reg(ctx, v14);
                    // Rule at src/prelude_lower.isle line 629.
                    return v37;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v38 = C::emit(ctx, v18);
                    let v39 = C::emit(ctx, v19);
                    // Rule at src/prelude_lower.isle line 636.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v40 = C::emit(ctx, v23);
                    let v41 = C::emit(ctx, v24);
                    let v42 = C::emit(ctx, v25);
                    let v43 = C::emit(ctx, v26);
                    // Rule at src/prelude_lower.isle line 649.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v1,
            result: v2,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v9,
                } => {
                    let v6 = C::emit(ctx, v1);
                    let v10 = C::emit(ctx, v9);
                    let v11 = C::value_reg(ctx, v2);
                    // Rule at src/prelude_lower.isle line 589.
                    return v11;
                }
                &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                    inst: ref v4,
                    result: v5,
                } => {
                    let v6 = C::emit(ctx, v1);
                    let v7 = C::emit(ctx, v4);
                    let v8 = C::value_regs(ctx, v2, v5);
                    // Rule at src/prelude_lower.isle line 581.
                    return v8;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags", "src/prelude_lower.isle line 579")
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Reg {
    let v2 = constructor_with_flags(ctx, arg0, arg1);
    let v4 = C::value_regs_get(ctx, v2, 0x0_usize);
    // Rule at src/prelude_lower.isle line 667.
    return v4;
}

// Generated as internal constructor for term flags_to_producesflags.
pub fn constructor_flags_to_producesflags<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> ProducesFlags {
    let v1 = C::mark_value_used(ctx, arg0);
    // Rule at src/prelude_lower.isle line 674.
    return ProducesFlags::AlreadyExistingFlags;
}

// Generated as internal constructor for term with_flags_side_effect.
pub fn constructor_with_flags_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> SideEffectNoResult {
    match arg0 {
        &ProducesFlags::AlreadyExistingFlags => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v2,
                } => {
                    let v3 = SideEffectNoResult::Inst {
                        inst: v2.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 685.
                    return v3;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v6 = SideEffectNoResult::Inst2 {
                        inst1: v4.clone(),
                        inst2: v5.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 690.
                    return v6;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v7,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v2,
                } => {
                    let v8 = SideEffectNoResult::Inst2 {
                        inst1: v7.clone(),
                        inst2: v2.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 695.
                    return v8;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v9 = SideEffectNoResult::Inst3 {
                        inst1: v7.clone(),
                        inst2: v4.clone(),
                        inst3: v5.clone(),
                    };
                    // Rule at src/prelude_lower.isle line 700.
                    return v9;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v10,
            inst2: ref v11,
        } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref v2,
            } = arg1 {
                let v12 = SideEffectNoResult::Inst3 {
                    inst1: v10.clone(),
                    inst2: v11.clone(),
                    inst3: v2.clone(),
                };
                // Rule at src/prelude_lower.isle line 705.
                return v12;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags_side_effect", "src/prelude_lower.isle line 683")
}

// Generated as internal constructor for term with_flags_chained.
pub fn constructor_with_flags_chained<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesAndProducesFlags,
    arg2: &ConsumesFlags,
) -> MultiReg {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v1,
        } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect {
                    inst: ref v3,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            // Rule at src/prelude_lower.isle line 714.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            // Rule at src/prelude_lower.isle line 722.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v17 = MultiReg::One {
                                a: v15,
                            };
                            // Rule at src/prelude_lower.isle line 731.
                            return v17;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v27 = MultiReg::Two {
                                a: v24,
                                b: v26,
                            };
                            // Rule at src/prelude_lower.isle line 739.
                            return v27;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v39 = MultiReg::Two {
                                a: v37,
                                b: v38,
                            };
                            // Rule at src/prelude_lower.isle line 748.
                            return v39;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v50 = MultiReg::One {
                                a: v48,
                            };
                            // Rule at src/prelude_lower.isle line 808.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v50 = MultiReg::One {
                                a: v48,
                            };
                            // Rule at src/prelude_lower.isle line 816.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v51 = MultiReg::Two {
                                a: v48,
                                b: v15,
                            };
                            // Rule at src/prelude_lower.isle line 825.
                            return v51;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v52 = MultiReg::Three {
                                a: v48,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src/prelude_lower.isle line 833.
                            return v52;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v53 = MultiReg::Three {
                                a: v48,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src/prelude_lower.isle line 842.
                            return v53;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v40,
            result: v41,
        } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect {
                    inst: ref v3,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            let v43 = MultiReg::One {
                                a: v41,
                            };
                            // Rule at src/prelude_lower.isle line 761.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v43 = MultiReg::One {
                                a: v41,
                            };
                            // Rule at src/prelude_lower.isle line 769.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v44 = MultiReg::Two {
                                a: v41,
                                b: v15,
                            };
                            // Rule at src/prelude_lower.isle line 778.
                            return v44;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v45 = MultiReg::Three {
                                a: v41,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src/prelude_lower.isle line 786.
                            return v45;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v46 = MultiReg::Three {
                                a: v41,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src/prelude_lower.isle line 795.
                            return v46;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v54 = MultiReg::Two {
                                a: v41,
                                b: v48,
                            };
                            // Rule at src/prelude_lower.isle line 855.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v54 = MultiReg::Two {
                                a: v41,
                                b: v48,
                            };
                            // Rule at src/prelude_lower.isle line 863.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v55 = MultiReg::Three {
                                a: v41,
                                b: v48,
                                c: v15,
                            };
                            // Rule at src/prelude_lower.isle line 872.
                            return v55;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v56 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v24,
                                d: v26,
                            };
                            // Rule at src/prelude_lower.isle line 880.
                            return v56;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v57 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v37,
                                d: v38,
                            };
                            // Rule at src/prelude_lower.isle line 889.
                            return v57;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v58,
            result: v59,
        } => {
            if let &ConsumesAndProducesFlags::ReturnsReg {
                inst: ref v47,
                result: v48,
            } = arg1 {
                match arg2 {
                    &ConsumesFlags::ConsumesFlagsSideEffect {
                        inst: ref v5,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v8 = C::emit(ctx, v5);
                        let v61 = MultiReg::Two {
                            a: v59,
                            b: v48,
                        };
                        // Rule at src/prelude_lower.isle line 901.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsSideEffect2 {
                        inst1: ref v10,
                        inst2: ref v11,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v12 = C::emit(ctx, v10);
                        let v13 = C::emit(ctx, v11);
                        let v61 = MultiReg::Two {
                            a: v59,
                            b: v48,
                        };
                        // Rule at src/prelude_lower.isle line 909.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                        inst: ref v63,
                        result: v64,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v65 = C::emit(ctx, v63);
                        let v66 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v64,
                        };
                        // Rule at src/prelude_lower.isle line 926.
                        return v66;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsReg {
                        inst: ref v14,
                        result: v15,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v16 = C::emit(ctx, v14);
                        let v62 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v15,
                        };
                        // Rule at src/prelude_lower.isle line 918.
                        return v62;
                    }
                    &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                        inst1: ref v18,
                        inst2: ref v19,
                        result: v20,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v21 = C::emit(ctx, v18);
                        let v22 = C::emit(ctx, v19);
                        let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                        let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                        let v67 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v24,
                            d: v26,
                        };
                        // Rule at src/prelude_lower.isle line 934.
                        return v67;
                    }
                    &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                        inst1: ref v28,
                        inst2: ref v29,
                        inst3: ref v30,
                        inst4: ref v31,
                        result: v32,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v33 = C::emit(ctx, v28);
                        let v34 = C::emit(ctx, v29);
                        let v35 = C::emit(ctx, v30);
                        let v36 = C::emit(ctx, v31);
                        let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                        let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                        let v68 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v37,
                            d: v38,
                        };
                        // Rule at src/prelude_lower.isle line 943.
                        return v68;
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags_chained", "src/prelude_lower.isle line 711")
}

// Generated as internal constructor for term lower_return.
pub fn constructor_lower_return<C: Context>(
    ctx: &mut C,
    arg0: ValueSlice,
) -> InstOutput {
    let v1 = &C::put_in_regs_vec(ctx, arg0);
    let v2 = C::gen_return(ctx, v1);
    let v3 = C::output_none(ctx);
    // Rule at src/prelude_lower.isle line 1153.
    return v3;
}

// Generated as internal constructor for term ty_to_operand_size.
pub fn constructor_ty_to_operand_size<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> OperandSize {
    match arg0 {
        I32 => {
            // Rule at src/isa/pulley_shared/inst.isle line 5.
            return OperandSize::Size32;
        }
        I64 => {
            // Rule at src/isa/pulley_shared/inst.isle line 6.
            return OperandSize::Size64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "ty_to_operand_size", "src/isa/pulley_shared/inst.isle line 4")
}

// Generated as internal constructor for term raw_inst_to_inst.
pub fn constructor_raw_inst_to_inst<C: Context>(
    ctx: &mut C,
    arg0: &RawInst,
) -> MInst {
    let v1 = MInst::Raw {
        raw: arg0.clone(),
    };
    // Rule at src/isa/pulley_shared/inst.isle line 158.
    return v1;
}

// Generated as internal constructor for term amode_base.
pub fn constructor_amode_base<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> ValueOffset {
    let v4 = C::def_inst(ctx, arg0);
    if let Some(v5) = v4 {
        let v6 = &C::inst_data_value(ctx, v5);
        if let &InstructionData::Binary {
            opcode: ref v7,
            args: ref v8,
        } = v6 {
            if let &Opcode::Iadd = v7 {
                let v9 = C::unpack_value_array_2(ctx, v8);
                let v12 = C::i64_from_iconst(ctx, v9.1);
                if let Some(v13) = v12 {
                    let v14 = C::i64_from_i32(ctx, v13);
                    if let Some(v15) = v14 {
                        let v2 = C::offset32(ctx, arg1);
                        let v16 = C::i32_checked_add(ctx, v15, v2);
                        if let Some(v17) = v16 {
                            let v18 = ValueOffset::Both {
                                value: v9.0,
                                offset: v17,
                            };
                            // Rule at src/isa/pulley_shared/inst.isle line 184.
                            return v18;
                        }
                    }
                }
            }
        }
    }
    let v2 = C::offset32(ctx, arg1);
    let v3 = ValueOffset::Both {
        value: arg0,
        offset: v2,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 183.
    return v3;
}

// Generated as internal constructor for term amode.
pub fn constructor_amode<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> Amode {
    let v2 = &constructor_amode_base(ctx, arg0, arg1);
    if let &ValueOffset::Both {
        value: v3,
        offset: v4,
    } = v2 {
        let v5 = constructor_put_in_xreg(ctx, v3);
        let v6 = Amode::RegOffset {
            base: v5,
            offset: v4,
        };
        // Rule at src/isa/pulley_shared/inst.isle line 199.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "amode", "src/isa/pulley_shared/inst.isle line 198")
}

// Generated as internal constructor for term addro32.
pub fn constructor_addro32<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> AddrO32 {
    let v2 = &constructor_amode_base(ctx, arg0, arg1);
    if let &ValueOffset::Both {
        value: v3,
        offset: v4,
    } = v2 {
        let v5 = constructor_put_in_xreg(ctx, v3);
        let v6 = AddrO32::Base {
            addr: v5,
            offset: v4,
        };
        // Rule at src/isa/pulley_shared/inst.isle line 212.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "addro32", "src/isa/pulley_shared/inst.isle line 211")
}

// Generated as internal constructor for term addrz.
pub fn constructor_addrz<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> AddrZ {
    let v2 = &constructor_amode_base(ctx, arg0, arg1);
    if let &ValueOffset::Both {
        value: v3,
        offset: v4,
    } = v2 {
        let v5 = constructor_put_in_xreg(ctx, v3);
        let v6 = AddrZ::Base {
            addr: v5,
            offset: v4,
        };
        // Rule at src/isa/pulley_shared/inst.isle line 225.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "addrz", "src/isa/pulley_shared/inst.isle line 224")
}

// Generated as internal constructor for term sinkable_load.
pub fn constructor_sinkable_load<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<SinkableLoad> {
    let v2 = C::is_sinkable_inst(ctx, arg0);
    if let Some(v3) = v2 {
        let v4 = &C::inst_data_value(ctx, v3);
        if let &InstructionData::Load {
            opcode: ref v5,
            arg: v6,
            flags: v7,
            offset: v8,
        } = v4 {
            if let &Opcode::Load = v5 {
                let v10 = &C::endianness(ctx, v7);
                let v11 = C::is_native_endianness(ctx, v10);
                if v11 == true {
                    let v12 = C::memflags_nontrapping(ctx, v7);
                    if v12 == true {
                        let v9 = C::offset32(ctx, v8);
                        let v13 = C::i32_try_into_u8(ctx, v9);
                        if let Some(v14) = v13 {
                            let v1 = C::value_type(ctx, arg0);
                            let v15 = SinkableLoad::Load {
                                inst: v3,
                                ty: v1,
                                addr: v6,
                                offset: v14,
                            };
                            let v16 = Some(v15);
                            // Rule at src/isa/pulley_shared/inst.isle line 271.
                            return v16;
                        }
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term sink_load.
pub fn constructor_sink_load<C: Context>(
    ctx: &mut C,
    arg0: &SinkableLoad,
) -> SunkLoad {
    if let &SinkableLoad::Load {
        inst: v1,
        ty: v2,
        addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = C::sink_inst(ctx, v1);
        let v6 = SunkLoad::Load {
            ty: v2,
            addr: v3,
            offset: v4,
        };
        // Rule at src/isa/pulley_shared/inst.isle line 286.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sink_load", "src/isa/pulley_shared/inst.isle line 285")
}

// Generated as internal constructor for term gen_addrg32.
pub fn constructor_gen_addrg32<C: Context>(
    ctx: &mut C,
    arg0: &G32,
) -> AddrG32 {
    if let &G32::All {
        heap_base: v1,
        heap_bound: v2,
        wasm_addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = constructor_put_in_xreg(ctx, v1);
        let v6 = constructor_put_in_xreg(ctx, v2);
        let v7 = constructor_put_in_xreg(ctx, v3);
        let v8 = AddrG32::RegisterBound {
            host_heap_base: v5,
            host_heap_bound: v6,
            wasm_addr: v7,
            offset: v4,
        };
        // Rule at src/isa/pulley_shared/inst.isle line 308.
        return v8;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_addrg32", "src/isa/pulley_shared/inst.isle line 307")
}

// Generated as internal constructor for term gen_addrg32bne.
pub fn constructor_gen_addrg32bne<C: Context>(
    ctx: &mut C,
    arg0: &G32Bne,
) -> AddrG32Bne {
    if let &G32Bne::All {
        heap_base: v1,
        heap_bound: ref v2,
        wasm_addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = constructor_put_in_xreg(ctx, v1);
        let v6 = &constructor_sink_load(ctx, v2);
        let v7 = constructor_put_in_xreg(ctx, v3);
        let v8 = &constructor_gen_addrg32bne_for_real(ctx, v5, v6, v7, v4);
        // Rule at src/isa/pulley_shared/inst.isle line 317.
        return v8.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_addrg32bne", "src/isa/pulley_shared/inst.isle line 316")
}

// Generated as internal constructor for term gen_addrg32bne_for_real.
pub fn constructor_gen_addrg32bne_for_real<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: &SunkLoad,
    arg2: XReg,
    arg3: u8,
) -> AddrG32Bne {
    if let &SunkLoad::Load {
        ty: v2,
        addr: v3,
        offset: v4,
    } = arg1 {
        let v7 = constructor_put_in_xreg(ctx, v3);
        let v8 = AddrG32Bne::BoundNe {
            host_heap_base: arg0,
            host_heap_bound_addr: v7,
            host_heap_bound_offset: v4,
            wasm_addr: arg2,
            offset: arg3,
        };
        // Rule at src/isa/pulley_shared/inst.isle line 323.
        return v8;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_addrg32bne_for_real", "src/isa/pulley_shared/inst.isle line 322")
}

// Generated as internal constructor for term addrg32bne.
pub fn constructor_addrg32bne<C: Context>(
    ctx: &mut C,
    arg0: &G32,
) -> Option<G32Bne> {
    if let &G32::All {
        heap_base: v1,
        heap_bound: v2,
        wasm_addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = &constructor_sinkable_load(ctx, v2);
        if let Some(v6) = v5 {
            let v7 = C::u16_try_into_u8(ctx, v4);
            if let Some(v8) = v7 {
                let v9 = G32Bne::All {
                    heap_base: v1,
                    heap_bound: v6.clone(),
                    wasm_addr: v3,
                    offset: v8,
                };
                let v10 = Some(v9);
                // Rule at src/isa/pulley_shared/inst.isle line 331.
                return v10;
            }
        }
    }
    None
}

// Generated as internal constructor for term wasm_g32.
pub fn constructor_wasm_g32<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
) -> Option<G32> {
    let v1 = C::def_inst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = &C::inst_data_value(ctx, v2);
        if let &InstructionData::Ternary {
            opcode: ref v4,
            args: ref v5,
        } = v3 {
            if let &Opcode::Select = v4 {
                let v6 = C::unpack_value_array_3(ctx, v5);
                let v10 = C::def_inst(ctx, v6.1);
                if let Some(v11) = v10 {
                    let v12 = &C::inst_data_value(ctx, v11);
                    if let &InstructionData::UnaryImm {
                        opcode: ref v13,
                        imm: v14,
                    } = v12 {
                        if let &Opcode::Iconst = v13 {
                            let v15 = C::u64_from_imm64(ctx, v14);
                            if v15 == 0x0_u64 {
                                let v17 = C::offset32(ctx, arg1);
                                if v17 == 0_i32 {
                                    let v20 = C::memflags_is_wasm(ctx, arg2);
                                    if v20 == true {
                                        let v21 = &constructor_host_offset(ctx, v6.2);
                                        if let &HostOffset::All {
                                            a: v22,
                                            b: v23,
                                        } = v21 {
                                            let v24 = &constructor_wasm_oob_select(ctx, v6.0, v22);
                                            if let Some(v25) = v24 {
                                                if let &OobSelect::All {
                                                    a: v26,
                                                    b: v27,
                                                    c: v28,
                                                    d: v29,
                                                } = v25 {
                                                    let v30 = C::g32_offset(ctx, v23, arg3, v29);
                                                    if let Some(v31) = v30 {
                                                        let v32 = G32::All {
                                                            heap_base: v26,
                                                            heap_bound: v27,
                                                            wasm_addr: v28,
                                                            offset: v31,
                                                        };
                                                        let v33 = Some(v32);
                                                        // Rule at src/isa/pulley_shared/inst.isle line 347.
                                                        return v33;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term host_offset.
pub fn constructor_host_offset<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> HostOffset {
    let v3 = C::def_inst(ctx, arg0);
    if let Some(v4) = v3 {
        let v5 = &C::inst_data_value(ctx, v4);
        if let &InstructionData::Binary {
            opcode: ref v6,
            args: ref v7,
        } = v5 {
            if let &Opcode::Iadd = v6 {
                let v8 = C::unpack_value_array_2(ctx, v7);
                let v24 = C::i64_from_iconst(ctx, v8.0);
                if let Some(v25) = v24 {
                    let v26 = C::i64_from_i32(ctx, v25);
                    if let Some(v27) = v26 {
                        let v28 = C::def_inst(ctx, v8.1);
                        if let Some(v29) = v28 {
                            let v30 = &C::inst_data_value(ctx, v29);
                            if let &InstructionData::Binary {
                                opcode: ref v31,
                                args: ref v32,
                            } = v30 {
                                if let &Opcode::Iadd = v31 {
                                    let v36 = HostOffset::All {
                                        a: v8.1,
                                        b: v27,
                                    };
                                    // Rule at src/isa/pulley_shared/inst.isle line 384.
                                    return v36;
                                }
                            }
                        }
                    }
                }
                let v11 = C::def_inst(ctx, v8.0);
                if let Some(v12) = v11 {
                    let v13 = &C::inst_data_value(ctx, v12);
                    if let &InstructionData::Binary {
                        opcode: ref v14,
                        args: ref v15,
                    } = v13 {
                        if let &Opcode::Iadd = v14 {
                            let v19 = C::i64_from_iconst(ctx, v8.1);
                            if let Some(v20) = v19 {
                                let v21 = C::i64_from_i32(ctx, v20);
                                if let Some(v22) = v21 {
                                    let v23 = HostOffset::All {
                                        a: v8.0,
                                        b: v22,
                                    };
                                    // Rule at src/isa/pulley_shared/inst.isle line 383.
                                    return v23;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let v2 = HostOffset::All {
        a: arg0,
        b: 0_i32,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 382.
    return v2;
}

// Generated as internal constructor for term wasm_oob_select.
pub fn constructor_wasm_oob_select<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Option<OobSelect> {
    let v2 = C::def_inst(ctx, arg1);
    if let Some(v3) = v2 {
        let v4 = &C::inst_data_value(ctx, v3);
        if let &InstructionData::Binary {
            opcode: ref v5,
            args: ref v6,
        } = v4 {
            if let &Opcode::Iadd = v5 {
                let v15 = &C::pointer_width(ctx);
                match v15 {
                    &PointerWidth::PointerWidth32 => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::value_type(ctx, v7.0);
                        if v18 == I32 {
                            let v19 = &constructor_wasm_oob_cond(ctx, v7.0, arg0);
                            if let Some(v20) = v19 {
                                if let &OobCond::All {
                                    a: v21,
                                    b: v22,
                                } = v20 {
                                    let v23 = OobSelect::All {
                                        a: v7.1,
                                        b: v21,
                                        c: v7.0,
                                        d: v22,
                                    };
                                    let v24 = Some(v23);
                                    // Rule at src/isa/pulley_shared/inst.isle line 398.
                                    return v24;
                                }
                            }
                        }
                        let v10 = C::value_type(ctx, v7.1);
                        if v10 == I32 {
                            let v11 = &constructor_wasm_oob_cond(ctx, v7.1, arg0);
                            if let Some(v12) = v11 {
                                if let &OobCond::All {
                                    a: v13,
                                    b: v14,
                                } = v12 {
                                    let v16 = OobSelect::All {
                                        a: v7.0,
                                        b: v13,
                                        c: v7.1,
                                        d: v14,
                                    };
                                    let v17 = Some(v16);
                                    // Rule at src/isa/pulley_shared/inst.isle line 394.
                                    return v17;
                                }
                            }
                        }
                    }
                    &PointerWidth::PointerWidth64 => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::value_type(ctx, v7.0);
                        if v18 == I64 {
                            let v19 = &constructor_wasm_oob_cond(ctx, v7.0, arg0);
                            if let Some(v20) = v19 {
                                if let &OobCond::All {
                                    a: v21,
                                    b: v22,
                                } = v20 {
                                    let v29 = constructor_wasm32_addr_for_host64(ctx, v7.0);
                                    if let Some(v30) = v29 {
                                        let v31 = OobSelect::All {
                                            a: v7.1,
                                            b: v21,
                                            c: v30,
                                            d: v22,
                                        };
                                        let v32 = Some(v31);
                                        // Rule at src/isa/pulley_shared/inst.isle line 410.
                                        return v32;
                                    }
                                }
                            }
                        }
                        let v10 = C::value_type(ctx, v7.1);
                        if v10 == I64 {
                            let v11 = &constructor_wasm_oob_cond(ctx, v7.1, arg0);
                            if let Some(v12) = v11 {
                                if let &OobCond::All {
                                    a: v13,
                                    b: v14,
                                } = v12 {
                                    let v25 = constructor_wasm32_addr_for_host64(ctx, v7.1);
                                    if let Some(v26) = v25 {
                                        let v27 = OobSelect::All {
                                            a: v7.0,
                                            b: v13,
                                            c: v26,
                                            d: v14,
                                        };
                                        let v28 = Some(v27);
                                        // Rule at src/isa/pulley_shared/inst.isle line 405.
                                        return v28;
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term wasm32_addr_for_host64.
pub fn constructor_wasm32_addr_for_host64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<Value> {
    let v1 = C::def_inst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = &C::inst_data_value(ctx, v2);
        match v3 {
            &InstructionData::Unary {
                opcode: ref v4,
                arg: v5,
            } => {
                if let &Opcode::Uextend = v4 {
                    let v6 = C::value_type(ctx, v5);
                    if v6 == I32 {
                        let v7 = Some(v5);
                        // Rule at src/isa/pulley_shared/inst.isle line 421.
                        return v7;
                    }
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v8,
                imm: v9,
            } => {
                if let &Opcode::Iconst = v8 {
                    let v10 = C::u64_from_imm64(ctx, v9);
                    let v11 = C::u64_from_u32(ctx, v10);
                    if let Some(v12) = v11 {
                        let v13 = Some(arg0);
                        // Rule at src/isa/pulley_shared/inst.isle line 422.
                        return v13;
                    }
                }
            }
            _ => {}
        }
    }
    None
}

// Generated as internal constructor for term wasm_oob_cond.
pub fn constructor_wasm_oob_cond<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Option<OobCond> {
    let v2 = C::def_inst(ctx, arg1);
    if let Some(v3) = v2 {
        let v4 = &C::inst_data_value(ctx, v3);
        if let &InstructionData::IntCompare {
            opcode: ref v5,
            args: ref v6,
            cond: ref v7,
        } = v4 {
            if let &Opcode::Icmp = v5 {
                match v7 {
                    &IntCC::UnsignedGreaterThan => {
                        let v8 = C::unpack_value_array_2(ctx, v6);
                        let v11 = C::def_inst(ctx, v8.1);
                        if let Some(v12) = v11 {
                            let v13 = &C::inst_data_value(ctx, v12);
                            if let &InstructionData::Binary {
                                opcode: ref v14,
                                args: ref v15,
                            } = v13 {
                                if let &Opcode::Isub = v14 {
                                    let v16 = C::unpack_value_array_2(ctx, v15);
                                    let v19 = C::def_inst(ctx, v16.1);
                                    if let Some(v20) = v19 {
                                        let v21 = &C::inst_data_value(ctx, v20);
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v22,
                                            imm: v23,
                                        } = v21 {
                                            if let &Opcode::Iconst = v22 {
                                                if arg0 == v8.0 {
                                                    let v24 = C::u64_from_imm64(ctx, v23);
                                                    let v25 = OobCond::All {
                                                        a: v16.0,
                                                        b: v24,
                                                    };
                                                    let v26 = Some(v25);
                                                    // Rule at src/isa/pulley_shared/inst.isle line 429.
                                                    return v26;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &IntCC::UnsignedLessThan => {
                        let v8 = C::unpack_value_array_2(ctx, v6);
                        let v27 = C::def_inst(ctx, v8.0);
                        if let Some(v28) = v27 {
                            let v29 = &C::inst_data_value(ctx, v28);
                            if let &InstructionData::Binary {
                                opcode: ref v30,
                                args: ref v31,
                            } = v29 {
                                if let &Opcode::Isub = v30 {
                                    let v32 = C::unpack_value_array_2(ctx, v31);
                                    let v35 = C::def_inst(ctx, v32.1);
                                    if let Some(v36) = v35 {
                                        let v37 = &C::inst_data_value(ctx, v36);
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v38,
                                            imm: v39,
                                        } = v37 {
                                            if let &Opcode::Iconst = v38 {
                                                if arg0 == v8.1 {
                                                    let v40 = C::u64_from_imm64(ctx, v39);
                                                    let v41 = OobCond::All {
                                                        a: v32.0,
                                                        b: v40,
                                                    };
                                                    let v42 = Some(v41);
                                                    // Rule at src/isa/pulley_shared/inst.isle line 431.
                                                    return v42;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term put_in_xreg.
pub fn constructor_put_in_xreg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::xreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 463.
    return v2;
}

// Generated as internal constructor for term output_xreg.
pub fn constructor_output_xreg<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> InstOutput {
    let v1 = C::xreg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 468.
    return v2;
}

// Generated as internal constructor for term writable_xreg_to_reg.
pub fn constructor_writable_xreg_to_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableXReg,
) -> Reg {
    let v1 = C::writable_xreg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 483.
    return v2;
}

// Generated as internal constructor for term xreg_to_value_regs.
pub fn constructor_xreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> ValueRegs {
    let v1 = C::xreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 493.
    return v2;
}

// Generated as internal constructor for term writable_xreg_to_value_regs.
pub fn constructor_writable_xreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableXReg,
) -> ValueRegs {
    let v1 = constructor_writable_xreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 498.
    return v2;
}

// Generated as internal constructor for term temp_writable_xreg.
pub fn constructor_temp_writable_xreg<C: Context>(
    ctx: &mut C,
) -> WritableXReg {
    let v1 = C::temp_writable_reg(ctx, I64);
    let v2 = C::writable_xreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 503.
    return v2;
}

// Generated as internal constructor for term put_in_freg.
pub fn constructor_put_in_freg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> FReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::freg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 523.
    return v2;
}

// Generated as internal constructor for term output_freg.
pub fn constructor_output_freg<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> InstOutput {
    let v1 = C::freg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 528.
    return v2;
}

// Generated as internal constructor for term writable_freg_to_reg.
pub fn constructor_writable_freg_to_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableFReg,
) -> Reg {
    let v1 = C::writable_freg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 543.
    return v2;
}

// Generated as internal constructor for term freg_to_value_regs.
pub fn constructor_freg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> ValueRegs {
    let v1 = C::freg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 553.
    return v2;
}

// Generated as internal constructor for term writable_freg_to_value_regs.
pub fn constructor_writable_freg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableFReg,
) -> ValueRegs {
    let v1 = constructor_writable_freg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 558.
    return v2;
}

// Generated as internal constructor for term temp_writable_freg.
pub fn constructor_temp_writable_freg<C: Context>(
    ctx: &mut C,
) -> WritableFReg {
    let v1 = C::temp_writable_reg(ctx, F64);
    let v2 = C::writable_freg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 563.
    return v2;
}

// Generated as internal constructor for term put_in_vreg.
pub fn constructor_put_in_vreg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> VReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::vreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 583.
    return v2;
}

// Generated as internal constructor for term output_vreg.
pub fn constructor_output_vreg<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> InstOutput {
    let v1 = C::vreg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 588.
    return v2;
}

// Generated as internal constructor for term writable_vreg_to_reg.
pub fn constructor_writable_vreg_to_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableVReg,
) -> Reg {
    let v1 = C::writable_vreg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 603.
    return v2;
}

// Generated as internal constructor for term vreg_to_value_regs.
pub fn constructor_vreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> ValueRegs {
    let v1 = C::vreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 613.
    return v2;
}

// Generated as internal constructor for term writable_vreg_to_value_regs.
pub fn constructor_writable_vreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableVReg,
) -> ValueRegs {
    let v1 = constructor_writable_vreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 618.
    return v2;
}

// Generated as internal constructor for term temp_writable_vreg.
pub fn constructor_temp_writable_vreg<C: Context>(
    ctx: &mut C,
) -> WritableVReg {
    let v1 = C::temp_writable_reg(ctx, I8X16);
    let v2 = C::writable_vreg_new(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 623.
    return v2;
}

// Generated as internal constructor for term imm.
pub fn constructor_imm<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> Reg {
    match arg0 {
        0_i64 => {
            let v1 = constructor_pulley_xzero(ctx);
            let v2 = C::xreg_to_reg(ctx, v1);
            // Rule at src/isa/pulley_shared/inst.isle line 631.
            return v2;
        }
        1_i64 => {
            let v3 = constructor_pulley_xone(ctx);
            let v4 = C::xreg_to_reg(ctx, v3);
            // Rule at src/isa/pulley_shared/inst.isle line 632.
            return v4;
        }
        _ => {}
    }
    let v5 = C::i64_from_i8(ctx, arg0);
    if let Some(v6) = v5 {
        let v7 = constructor_pulley_xconst8(ctx, v6);
        let v8 = C::xreg_to_reg(ctx, v7);
        // Rule at src/isa/pulley_shared/inst.isle line 636.
        return v8;
    }
    let v9 = C::i64_from_i16(ctx, arg0);
    if let Some(v10) = v9 {
        let v11 = constructor_pulley_xconst16(ctx, v10);
        let v12 = C::xreg_to_reg(ctx, v11);
        // Rule at src/isa/pulley_shared/inst.isle line 637.
        return v12;
    }
    let v13 = C::i64_from_i32(ctx, arg0);
    if let Some(v14) = v13 {
        let v15 = constructor_pulley_xconst32(ctx, v14);
        let v16 = C::xreg_to_reg(ctx, v15);
        // Rule at src/isa/pulley_shared/inst.isle line 638.
        return v16;
    }
    let v17 = constructor_pulley_xconst64(ctx, arg0);
    let v18 = C::xreg_to_reg(ctx, v17);
    // Rule at src/isa/pulley_shared/inst.isle line 639.
    return v18;
}

// Generated as internal constructor for term pulley_trap_if.
pub fn constructor_pulley_trap_if<C: Context>(
    ctx: &mut C,
    arg0: &Cond,
    arg1: &TrapCode,
) -> SideEffectNoResult {
    let v2 = MInst::TrapIf {
        cond: arg0.clone(),
        code: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 644.
    return v3;
}

// Generated as internal constructor for term pulley_get_special.
pub fn constructor_pulley_get_special<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::GetSpecial {
        dst: v1,
        reg: arg0,
    };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src/isa/pulley_shared/inst.isle line 651.
    return v4;
}

// Generated as internal constructor for term pulley_jump.
pub fn constructor_pulley_jump<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
) -> SideEffectNoResult {
    let v1 = MInst::Jump {
        label: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 657.
    return v2;
}

// Generated as internal constructor for term pulley_br_if.
pub fn constructor_pulley_br_if<C: Context>(
    ctx: &mut C,
    arg0: &Cond,
    arg1: MachLabel,
    arg2: MachLabel,
) -> SideEffectNoResult {
    let v3 = MInst::BrIf {
        cond: arg0.clone(),
        taken: arg1,
        not_taken: arg2,
    };
    let v4 = SideEffectNoResult::Inst {
        inst: v3,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 661.
    return v4;
}

// Generated as internal constructor for term pulley_xload.
pub fn constructor_pulley_xload<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Type,
    arg2: MemFlags,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = MInst::XLoad {
        dst: v3,
        mem: arg0.clone(),
        ty: arg1,
        flags: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at src/isa/pulley_shared/inst.isle line 665.
    return v6;
}

// Generated as internal constructor for term pulley_xstore.
pub fn constructor_pulley_xstore<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: XReg,
    arg2: Type,
    arg3: MemFlags,
) -> SideEffectNoResult {
    let v4 = MInst::XStore {
        mem: arg0.clone(),
        src: arg1,
        ty: arg2,
        flags: arg3,
    };
    let v5 = SideEffectNoResult::Inst {
        inst: v4,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 671.
    return v5;
}

// Generated as internal constructor for term pulley_fload.
pub fn constructor_pulley_fload<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Type,
    arg2: MemFlags,
) -> FReg {
    let v3 = constructor_temp_writable_freg(ctx);
    let v4 = MInst::FLoad {
        dst: v3,
        mem: arg0.clone(),
        ty: arg1,
        flags: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_freg_to_freg(ctx, v3);
    // Rule at src/isa/pulley_shared/inst.isle line 675.
    return v6;
}

// Generated as internal constructor for term pulley_fstore.
pub fn constructor_pulley_fstore<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: FReg,
    arg2: Type,
    arg3: MemFlags,
) -> SideEffectNoResult {
    let v4 = MInst::FStore {
        mem: arg0.clone(),
        src: arg1,
        ty: arg2,
        flags: arg3,
    };
    let v5 = SideEffectNoResult::Inst {
        inst: v4,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 681.
    return v5;
}

// Generated as internal constructor for term pulley_vload.
pub fn constructor_pulley_vload<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Type,
    arg2: MemFlags,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = MInst::VLoad {
        dst: v3,
        mem: arg0.clone(),
        ty: arg1,
        flags: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at src/isa/pulley_shared/inst.isle line 685.
    return v6;
}

// Generated as internal constructor for term pulley_vstore.
pub fn constructor_pulley_vstore<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: VReg,
    arg2: Type,
    arg3: MemFlags,
) -> SideEffectNoResult {
    let v4 = MInst::VStore {
        mem: arg0.clone(),
        src: arg1,
        ty: arg2,
        flags: arg3,
    };
    let v5 = SideEffectNoResult::Inst {
        inst: v4,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 691.
    return v5;
}

// Generated as internal constructor for term gen_br_table.
pub fn constructor_gen_br_table<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: MachLabel,
    arg2: &BoxVecMachLabel,
) -> Unit {
    let v3 = MInst::BrTable {
        idx: arg0,
        default: arg1,
        targets: arg2.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    // Rule at src/isa/pulley_shared/inst.isle line 695.
    return v4;
}

// Generated as internal constructor for term load_ext_name_near.
pub fn constructor_load_ext_name_near<C: Context>(
    ctx: &mut C,
    arg0: BoxExternalName,
    arg1: i64,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::LoadExtNameNear {
        dst: v2,
        name: arg0,
        offset: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 700.
    return v5;
}

// Generated as internal constructor for term load_ext_name_far.
pub fn constructor_load_ext_name_far<C: Context>(
    ctx: &mut C,
    arg0: BoxExternalName,
    arg1: i64,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::LoadExtNameFar {
        dst: v2,
        name: arg0,
        offset: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 707.
    return v5;
}

// Generated as internal constructor for term load_ext_name.
pub fn constructor_load_ext_name<C: Context>(
    ctx: &mut C,
    arg0: BoxExternalName,
    arg1: i64,
    arg2: &RelocDistance,
) -> XReg {
    match arg2 {
        &RelocDistance::Near => {
            let v3 = constructor_load_ext_name_near(ctx, arg0, arg1);
            // Rule at src/isa/pulley_shared/inst.isle line 714.
            return v3;
        }
        &RelocDistance::Far => {
            let v4 = constructor_load_ext_name_far(ctx, arg0, arg1);
            // Rule at src/isa/pulley_shared/inst.isle line 716.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "load_ext_name", "src/isa/pulley_shared/inst.isle line 713")
}

// Generated as internal constructor for term call_impl.
pub fn constructor_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxCallInfo,
) -> SideEffectNoResult {
    let v1 = MInst::Call {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 738.
    return v2;
}

// Generated as internal constructor for term indirect_call_impl.
pub fn constructor_indirect_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxCallIndInfo,
) -> SideEffectNoResult {
    let v1 = MInst::IndirectCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 743.
    return v2;
}

// Generated as internal constructor for term indirect_call_host_impl.
pub fn constructor_indirect_call_host_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxCallIndirectHostInfo,
) -> SideEffectNoResult {
    let v1 = MInst::IndirectCallHost {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 748.
    return v2;
}

// Generated as internal constructor for term return_call_impl.
pub fn constructor_return_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxReturnCallInfo,
) -> SideEffectNoResult {
    let v1 = MInst::ReturnCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 753.
    return v2;
}

// Generated as internal constructor for term return_indirect_call_impl.
pub fn constructor_return_indirect_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxReturnCallIndInfo,
) -> SideEffectNoResult {
    let v1 = MInst::ReturnIndirectCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 758.
    return v2;
}

// Generated as internal constructor for term zext32.
pub fn constructor_zext32<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_zext8(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 765.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_zext16(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 766.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src/isa/pulley_shared/inst.isle line 767.
            return v2;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src/isa/pulley_shared/inst.isle line 768.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "zext32", "src/isa/pulley_shared/inst.isle line 764")
}

// Generated as internal constructor for term sext32.
pub fn constructor_sext32<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_sext8(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 772.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_sext16(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 773.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src/isa/pulley_shared/inst.isle line 774.
            return v2;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src/isa/pulley_shared/inst.isle line 775.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sext32", "src/isa/pulley_shared/inst.isle line 771")
}

// Generated as internal constructor for term zext64.
pub fn constructor_zext64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_zext8(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 779.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_zext16(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 780.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v5 = constructor_pulley_zext32(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 781.
            return v5;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src/isa/pulley_shared/inst.isle line 782.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "zext64", "src/isa/pulley_shared/inst.isle line 778")
}

// Generated as internal constructor for term sext64.
pub fn constructor_sext64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_sext8(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 786.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_sext16(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 787.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v5 = constructor_pulley_sext32(ctx, v2);
            // Rule at src/isa/pulley_shared/inst.isle line 788.
            return v5;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src/isa/pulley_shared/inst.isle line 789.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sext64", "src/isa/pulley_shared/inst.isle line 785")
}

// Generated as internal constructor for term pulley_label_address.
pub fn constructor_pulley_label_address<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
) -> Reg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = C::writable_xreg_to_writable_reg(ctx, v1);
    let v3 = C::writable_xreg_new(ctx, v2);
    let v4 = MInst::LabelAddress {
        dst: v3,
        label: arg0,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src/isa/pulley_shared/inst.isle line 793.
    return v6;
}

// Generated as internal constructor for term pulley_sequence_point.
pub fn constructor_pulley_sequence_point<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = SideEffectNoResult::Inst {
        inst: MInst::SequencePoint,
    };
    // Rule at src/isa/pulley_shared/inst.isle line 800.
    return v1;
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> Option<InstOutput> {
    let v1 = &C::inst_data_value(ctx, arg0);
    match v1 {
        &InstructionData::Binary {
            opcode: ref v124,
            args: ref v125,
        } => {
            match v124 {
                &Opcode::Swizzle => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I8X16 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v1596 = constructor_pulley_vswizzlei8x16(ctx, v192, v193);
                            let v1597 = constructor_output_vreg(ctx, v1596);
                            let v1598 = Some(v1597);
                            // Rule at src/isa/pulley_shared/lower.isle line 1815.
                            return v1598;
                        }
                    }
                }
                &Opcode::Smin => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v675 = constructor_pulley_xmin64_s(ctx, v129, v130);
                                let v676 = constructor_output_xreg(ctx, v675);
                                let v677 = Some(v676);
                                // Rule at src/isa/pulley_shared/lower.isle line 668.
                                return v677;
                            }
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v678 = constructor_pulley_vmin8x16_s(ctx, v192, v193);
                                let v679 = constructor_output_vreg(ctx, v678);
                                let v680 = Some(v679);
                                // Rule at src/isa/pulley_shared/lower.isle line 669.
                                return v680;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v681 = constructor_pulley_vmin16x8_s(ctx, v192, v193);
                                let v682 = constructor_output_vreg(ctx, v681);
                                let v683 = Some(v682);
                                // Rule at src/isa/pulley_shared/lower.isle line 670.
                                return v683;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v684 = constructor_pulley_vmin32x4_s(ctx, v192, v193);
                                let v685 = constructor_output_vreg(ctx, v684);
                                let v686 = Some(v685);
                                // Rule at src/isa/pulley_shared/lower.isle line 671.
                                return v686;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v418 = constructor_sext32(ctx, v126.0);
                            let v419 = constructor_sext32(ctx, v126.1);
                            let v672 = constructor_pulley_xmin32_s(ctx, v418, v419);
                            let v673 = constructor_output_xreg(ctx, v672);
                            let v674 = Some(v673);
                            // Rule at src/isa/pulley_shared/lower.isle line 666.
                            return v674;
                        }
                    }
                }
                &Opcode::Umin => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v660 = constructor_pulley_xmin64_u(ctx, v129, v130);
                                let v661 = constructor_output_xreg(ctx, v660);
                                let v662 = Some(v661);
                                // Rule at src/isa/pulley_shared/lower.isle line 659.
                                return v662;
                            }
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v663 = constructor_pulley_vmin8x16_u(ctx, v192, v193);
                                let v664 = constructor_output_vreg(ctx, v663);
                                let v665 = Some(v664);
                                // Rule at src/isa/pulley_shared/lower.isle line 660.
                                return v665;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v666 = constructor_pulley_vmin16x8_u(ctx, v192, v193);
                                let v667 = constructor_output_vreg(ctx, v666);
                                let v668 = Some(v667);
                                // Rule at src/isa/pulley_shared/lower.isle line 661.
                                return v668;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v669 = constructor_pulley_vmin32x4_u(ctx, v192, v193);
                                let v670 = constructor_output_vreg(ctx, v669);
                                let v671 = Some(v670);
                                // Rule at src/isa/pulley_shared/lower.isle line 662.
                                return v671;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v390 = constructor_zext32(ctx, v126.0);
                            let v391 = constructor_zext32(ctx, v126.1);
                            let v657 = constructor_pulley_xmin32_u(ctx, v390, v391);
                            let v658 = constructor_output_xreg(ctx, v657);
                            let v659 = Some(v658);
                            // Rule at src/isa/pulley_shared/lower.isle line 657.
                            return v659;
                        }
                    }
                }
                &Opcode::Smax => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v705 = constructor_pulley_xmax64_s(ctx, v129, v130);
                                let v706 = constructor_output_xreg(ctx, v705);
                                let v707 = Some(v706);
                                // Rule at src/isa/pulley_shared/lower.isle line 686.
                                return v707;
                            }
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v708 = constructor_pulley_vmax8x16_s(ctx, v192, v193);
                                let v709 = constructor_output_vreg(ctx, v708);
                                let v710 = Some(v709);
                                // Rule at src/isa/pulley_shared/lower.isle line 687.
                                return v710;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v711 = constructor_pulley_vmax16x8_s(ctx, v192, v193);
                                let v712 = constructor_output_vreg(ctx, v711);
                                let v713 = Some(v712);
                                // Rule at src/isa/pulley_shared/lower.isle line 688.
                                return v713;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v714 = constructor_pulley_vmax32x4_s(ctx, v192, v193);
                                let v715 = constructor_output_vreg(ctx, v714);
                                let v716 = Some(v715);
                                // Rule at src/isa/pulley_shared/lower.isle line 689.
                                return v716;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v418 = constructor_sext32(ctx, v126.0);
                            let v419 = constructor_sext32(ctx, v126.1);
                            let v702 = constructor_pulley_xmax32_s(ctx, v418, v419);
                            let v703 = constructor_output_xreg(ctx, v702);
                            let v704 = Some(v703);
                            // Rule at src/isa/pulley_shared/lower.isle line 684.
                            return v704;
                        }
                    }
                }
                &Opcode::Umax => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v690 = constructor_pulley_xmax64_u(ctx, v129, v130);
                                let v691 = constructor_output_xreg(ctx, v690);
                                let v692 = Some(v691);
                                // Rule at src/isa/pulley_shared/lower.isle line 677.
                                return v692;
                            }
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v693 = constructor_pulley_vmax8x16_u(ctx, v192, v193);
                                let v694 = constructor_output_vreg(ctx, v693);
                                let v695 = Some(v694);
                                // Rule at src/isa/pulley_shared/lower.isle line 678.
                                return v695;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v696 = constructor_pulley_vmax16x8_u(ctx, v192, v193);
                                let v697 = constructor_output_vreg(ctx, v696);
                                let v698 = Some(v697);
                                // Rule at src/isa/pulley_shared/lower.isle line 679.
                                return v698;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v699 = constructor_pulley_vmax32x4_u(ctx, v192, v193);
                                let v700 = constructor_output_vreg(ctx, v699);
                                let v701 = Some(v700);
                                // Rule at src/isa/pulley_shared/lower.isle line 680.
                                return v701;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v390 = constructor_zext32(ctx, v126.0);
                            let v391 = constructor_zext32(ctx, v126.1);
                            let v687 = constructor_pulley_xmax32_u(ctx, v390, v391);
                            let v688 = constructor_output_xreg(ctx, v687);
                            let v689 = Some(v688);
                            // Rule at src/isa/pulley_shared/lower.isle line 675.
                            return v689;
                        }
                    }
                }
                &Opcode::AvgRound => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v465 = constructor_pulley_vavground8x16(ctx, v192, v193);
                                let v466 = constructor_output_vreg(ctx, v465);
                                let v467 = Some(v466);
                                // Rule at src/isa/pulley_shared/lower.isle line 488.
                                return v467;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v468 = constructor_pulley_vavground16x8(ctx, v192, v193);
                                let v469 = constructor_output_vreg(ctx, v468);
                                let v470 = Some(v469);
                                // Rule at src/isa/pulley_shared/lower.isle line 489.
                                return v470;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::UaddSat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v209 = constructor_pulley_vaddu8x16_sat(ctx, v192, v193);
                                let v210 = constructor_output_vreg(ctx, v209);
                                let v211 = Some(v210);
                                // Rule at src/isa/pulley_shared/lower.isle line 304.
                                return v211;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v215 = constructor_pulley_vaddu16x8_sat(ctx, v192, v193);
                                let v216 = constructor_output_vreg(ctx, v215);
                                let v217 = Some(v216);
                                // Rule at src/isa/pulley_shared/lower.isle line 306.
                                return v217;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::SaddSat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v206 = constructor_pulley_vaddi8x16_sat(ctx, v192, v193);
                                let v207 = constructor_output_vreg(ctx, v206);
                                let v208 = Some(v207);
                                // Rule at src/isa/pulley_shared/lower.isle line 303.
                                return v208;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v212 = constructor_pulley_vaddi16x8_sat(ctx, v192, v193);
                                let v213 = constructor_output_vreg(ctx, v212);
                                let v214 = Some(v213);
                                // Rule at src/isa/pulley_shared/lower.isle line 305.
                                return v214;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::UsubSat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v303 = constructor_pulley_vsubu8x16_sat(ctx, v192, v193);
                                let v304 = constructor_output_vreg(ctx, v303);
                                let v305 = Some(v304);
                                // Rule at src/isa/pulley_shared/lower.isle line 367.
                                return v305;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v309 = constructor_pulley_vsubu16x8_sat(ctx, v192, v193);
                                let v310 = constructor_output_vreg(ctx, v309);
                                let v311 = Some(v310);
                                // Rule at src/isa/pulley_shared/lower.isle line 369.
                                return v311;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::SsubSat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v300 = constructor_pulley_vsubi8x16_sat(ctx, v192, v193);
                                let v301 = constructor_output_vreg(ctx, v300);
                                let v302 = Some(v301);
                                // Rule at src/isa/pulley_shared/lower.isle line 366.
                                return v302;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v306 = constructor_pulley_vsubi16x8_sat(ctx, v192, v193);
                                let v307 = constructor_output_vreg(ctx, v306);
                                let v308 = Some(v307);
                                // Rule at src/isa/pulley_shared/lower.isle line 368.
                                return v308;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Iadd => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v126 = C::unpack_value_array_2(ctx, v125);
                        let v169 = constructor_u8_from_negated_iconst(ctx, v126.1);
                        if let Some(v170) = v169 {
                            let v101 = C::value_type(ctx, v100);
                            if v101 == I64 {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v174 = constructor_pulley_xsub64_u8(ctx, v129, v170);
                                let v175 = constructor_output_xreg(ctx, v174);
                                let v176 = Some(v175);
                                // Rule at src/isa/pulley_shared/lower.isle line 267.
                                return v176;
                            }
                            let v120 = C::ty_int(ctx, v101);
                            if let Some(v121) = v120 {
                                let v137 = C::fits_in_32(ctx, v121);
                                if let Some(v138) = v137 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v171 = constructor_pulley_xsub32_u8(ctx, v129, v170);
                                    let v172 = constructor_output_xreg(ctx, v171);
                                    let v173 = Some(v172);
                                    // Rule at src/isa/pulley_shared/lower.isle line 264.
                                    return v173;
                                }
                            }
                        }
                        let v161 = constructor_u32_from_negated_iconst(ctx, v126.1);
                        if let Some(v162) = v161 {
                            let v101 = C::value_type(ctx, v100);
                            if v101 == I64 {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v166 = constructor_pulley_xsub64_u32(ctx, v129, v162);
                                let v167 = constructor_output_xreg(ctx, v166);
                                let v168 = Some(v167);
                                // Rule at src/isa/pulley_shared/lower.isle line 261.
                                return v168;
                            }
                            let v120 = C::ty_int(ctx, v101);
                            if let Some(v121) = v120 {
                                let v137 = C::fits_in_32(ctx, v121);
                                if let Some(v138) = v137 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v163 = constructor_pulley_xsub32_u32(ctx, v129, v162);
                                    let v164 = constructor_output_xreg(ctx, v163);
                                    let v165 = Some(v164);
                                    // Rule at src/isa/pulley_shared/lower.isle line 258.
                                    return v165;
                                }
                            }
                        }
                        let v139 = C::def_inst(ctx, v126.1);
                        if let Some(v140) = v139 {
                            let v141 = &C::inst_data_value(ctx, v140);
                            match v141 {
                                &InstructionData::Binary {
                                    opcode: ref v232,
                                    args: ref v233,
                                } => {
                                    if let &Opcode::Imul = v232 {
                                        let v101 = C::value_type(ctx, v100);
                                        match v101 {
                                            I32 => {
                                                let v234 = C::unpack_value_array_2(ctx, v233);
                                                let v237 = constructor_put_in_xreg(ctx, v234.0);
                                                let v238 = constructor_put_in_xreg(ctx, v234.1);
                                                let v239 = constructor_put_in_xreg(ctx, v126.0);
                                                let v240 = constructor_pulley_xmadd32(ctx, v237, v238, v239);
                                                let v241 = constructor_output_xreg(ctx, v240);
                                                let v242 = Some(v241);
                                                // Rule at src/isa/pulley_shared/lower.isle line 311.
                                                return v242;
                                            }
                                            I64 => {
                                                let v234 = C::unpack_value_array_2(ctx, v233);
                                                let v237 = constructor_put_in_xreg(ctx, v234.0);
                                                let v238 = constructor_put_in_xreg(ctx, v234.1);
                                                let v239 = constructor_put_in_xreg(ctx, v126.0);
                                                let v246 = constructor_pulley_xmadd64(ctx, v237, v238, v239);
                                                let v247 = constructor_output_xreg(ctx, v246);
                                                let v248 = Some(v247);
                                                // Rule at src/isa/pulley_shared/lower.isle line 313.
                                                return v248;
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v142,
                                    imm: v143,
                                } => {
                                    if let &Opcode::Iconst = v142 {
                                        let v101 = C::value_type(ctx, v100);
                                        if v101 == I64 {
                                            let v144 = C::u64_from_imm64(ctx, v143);
                                            let v150 = C::u64_from_u8(ctx, v144);
                                            if let Some(v151) = v150 {
                                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                                let v158 = constructor_pulley_xadd64_u8(ctx, v129, v151);
                                                let v159 = constructor_output_xreg(ctx, v158);
                                                let v160 = Some(v159);
                                                // Rule at src/isa/pulley_shared/lower.isle line 253.
                                                return v160;
                                            }
                                            let v145 = C::u64_from_u32(ctx, v144);
                                            if let Some(v146) = v145 {
                                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                                let v155 = constructor_pulley_xadd64_u32(ctx, v129, v146);
                                                let v156 = constructor_output_xreg(ctx, v155);
                                                let v157 = Some(v156);
                                                // Rule at src/isa/pulley_shared/lower.isle line 251.
                                                return v157;
                                            }
                                        }
                                        let v120 = C::ty_int(ctx, v101);
                                        if let Some(v121) = v120 {
                                            let v137 = C::fits_in_32(ctx, v121);
                                            if let Some(v138) = v137 {
                                                let v144 = C::u64_from_imm64(ctx, v143);
                                                let v150 = C::u64_from_u8(ctx, v144);
                                                if let Some(v151) = v150 {
                                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                                    let v152 = constructor_pulley_xadd32_u8(ctx, v129, v151);
                                                    let v153 = constructor_output_xreg(ctx, v152);
                                                    let v154 = Some(v153);
                                                    // Rule at src/isa/pulley_shared/lower.isle line 249.
                                                    return v154;
                                                }
                                                let v145 = C::u64_from_u32(ctx, v144);
                                                if let Some(v146) = v145 {
                                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                                    let v147 = constructor_pulley_xadd32_u32(ctx, v129, v146);
                                                    let v148 = constructor_output_xreg(ctx, v147);
                                                    let v149 = Some(v148);
                                                    // Rule at src/isa/pulley_shared/lower.isle line 247.
                                                    return v149;
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I32 => {
                                let v218 = C::def_inst(ctx, v126.0);
                                if let Some(v219) = v218 {
                                    let v220 = &C::inst_data_value(ctx, v219);
                                    if let &InstructionData::Binary {
                                        opcode: ref v221,
                                        args: ref v222,
                                    } = v220 {
                                        if let &Opcode::Imul = v221 {
                                            let v223 = C::unpack_value_array_2(ctx, v222);
                                            let v226 = constructor_put_in_xreg(ctx, v223.0);
                                            let v227 = constructor_put_in_xreg(ctx, v223.1);
                                            let v228 = constructor_put_in_xreg(ctx, v126.1);
                                            let v229 = constructor_pulley_xmadd32(ctx, v226, v227, v228);
                                            let v230 = constructor_output_xreg(ctx, v229);
                                            let v231 = Some(v230);
                                            // Rule at src/isa/pulley_shared/lower.isle line 310.
                                            return v231;
                                        }
                                    }
                                }
                            }
                            I64 => {
                                let v218 = C::def_inst(ctx, v126.0);
                                if let Some(v219) = v218 {
                                    let v220 = &C::inst_data_value(ctx, v219);
                                    if let &InstructionData::Binary {
                                        opcode: ref v221,
                                        args: ref v222,
                                    } = v220 {
                                        if let &Opcode::Imul = v221 {
                                            let v223 = C::unpack_value_array_2(ctx, v222);
                                            let v226 = constructor_put_in_xreg(ctx, v223.0);
                                            let v227 = constructor_put_in_xreg(ctx, v223.1);
                                            let v228 = constructor_put_in_xreg(ctx, v126.1);
                                            let v243 = constructor_pulley_xmadd64(ctx, v226, v227, v228);
                                            let v244 = constructor_output_xreg(ctx, v243);
                                            let v245 = Some(v244);
                                            // Rule at src/isa/pulley_shared/lower.isle line 312.
                                            return v245;
                                        }
                                    }
                                }
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v134 = constructor_pulley_xadd64(ctx, v129, v130);
                                let v135 = constructor_output_xreg(ctx, v134);
                                let v136 = Some(v135);
                                // Rule at src/isa/pulley_shared/lower.isle line 244.
                                return v136;
                            }
                            I128 => {
                                let v177 = C::put_in_regs(ctx, v126.0);
                                let v178 = C::put_in_regs(ctx, v126.1);
                                let v180 = C::value_regs_get(ctx, v177, 0x0_usize);
                                let v181 = C::xreg_new(ctx, v180);
                                let v183 = C::value_regs_get(ctx, v177, 0x1_usize);
                                let v184 = C::xreg_new(ctx, v183);
                                let v185 = C::value_regs_get(ctx, v178, 0x0_usize);
                                let v186 = C::xreg_new(ctx, v185);
                                let v187 = C::value_regs_get(ctx, v178, 0x1_usize);
                                let v188 = C::xreg_new(ctx, v187);
                                let v189 = constructor_pulley_xadd128(ctx, v181, v184, v186, v188);
                                let v190 = C::output(ctx, v189);
                                let v191 = Some(v190);
                                // Rule at src/isa/pulley_shared/lower.isle line 288.
                                return v191;
                            }
                            I8X16 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v194 = constructor_pulley_vaddi8x16(ctx, v192, v193);
                                let v195 = constructor_output_vreg(ctx, v194);
                                let v196 = Some(v195);
                                // Rule at src/isa/pulley_shared/lower.isle line 298.
                                return v196;
                            }
                            I16X8 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v197 = constructor_pulley_vaddi16x8(ctx, v192, v193);
                                let v198 = constructor_output_vreg(ctx, v197);
                                let v199 = Some(v198);
                                // Rule at src/isa/pulley_shared/lower.isle line 299.
                                return v199;
                            }
                            I32X4 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v200 = constructor_pulley_vaddi32x4(ctx, v192, v193);
                                let v201 = constructor_output_vreg(ctx, v200);
                                let v202 = Some(v201);
                                // Rule at src/isa/pulley_shared/lower.isle line 300.
                                return v202;
                            }
                            I64X2 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v203 = constructor_pulley_vaddi64x2(ctx, v192, v193);
                                let v204 = constructor_output_vreg(ctx, v203);
                                let v205 = Some(v204);
                                // Rule at src/isa/pulley_shared/lower.isle line 301.
                                return v205;
                            }
                            _ => {}
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v122 = C::fits_in_64(ctx, v121);
                            if let Some(v123) = v122 {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v131 = constructor_pulley_xadd32(ctx, v129, v130);
                                let v132 = constructor_output_xreg(ctx, v131);
                                let v133 = Some(v132);
                                // Rule at src/isa/pulley_shared/lower.isle line 243.
                                return v133;
                            }
                        }
                    }
                }
                &Opcode::Isub => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v126 = C::unpack_value_array_2(ctx, v125);
                        let v169 = constructor_u8_from_negated_iconst(ctx, v126.1);
                        if let Some(v170) = v169 {
                            let v101 = C::value_type(ctx, v100);
                            if v101 == I64 {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v282 = constructor_pulley_xadd64_u8(ctx, v129, v170);
                                let v283 = constructor_output_xreg(ctx, v282);
                                let v284 = Some(v283);
                                // Rule at src/isa/pulley_shared/lower.isle line 346.
                                return v284;
                            }
                            let v120 = C::ty_int(ctx, v101);
                            if let Some(v121) = v120 {
                                let v137 = C::fits_in_32(ctx, v121);
                                if let Some(v138) = v137 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v279 = constructor_pulley_xadd32_u8(ctx, v129, v170);
                                    let v280 = constructor_output_xreg(ctx, v279);
                                    let v281 = Some(v280);
                                    // Rule at src/isa/pulley_shared/lower.isle line 343.
                                    return v281;
                                }
                            }
                        }
                        let v161 = constructor_u32_from_negated_iconst(ctx, v126.1);
                        if let Some(v162) = v161 {
                            let v101 = C::value_type(ctx, v100);
                            if v101 == I64 {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v276 = constructor_pulley_xadd64_u32(ctx, v129, v162);
                                let v277 = constructor_output_xreg(ctx, v276);
                                let v278 = Some(v277);
                                // Rule at src/isa/pulley_shared/lower.isle line 340.
                                return v278;
                            }
                            let v120 = C::ty_int(ctx, v101);
                            if let Some(v121) = v120 {
                                let v137 = C::fits_in_32(ctx, v121);
                                if let Some(v138) = v137 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v273 = constructor_pulley_xadd32_u32(ctx, v129, v162);
                                    let v274 = constructor_output_xreg(ctx, v273);
                                    let v275 = Some(v274);
                                    // Rule at src/isa/pulley_shared/lower.isle line 337.
                                    return v275;
                                }
                            }
                        }
                        let v139 = C::def_inst(ctx, v126.1);
                        if let Some(v140) = v139 {
                            let v141 = &C::inst_data_value(ctx, v140);
                            if let &InstructionData::UnaryImm {
                                opcode: ref v142,
                                imm: v143,
                            } = v141 {
                                if let &Opcode::Iconst = v142 {
                                    let v101 = C::value_type(ctx, v100);
                                    if v101 == I64 {
                                        let v144 = C::u64_from_imm64(ctx, v143);
                                        let v150 = C::u64_from_u8(ctx, v144);
                                        if let Some(v151) = v150 {
                                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                                            let v270 = constructor_pulley_xsub64_u8(ctx, v129, v151);
                                            let v271 = constructor_output_xreg(ctx, v270);
                                            let v272 = Some(v271);
                                            // Rule at src/isa/pulley_shared/lower.isle line 332.
                                            return v272;
                                        }
                                        let v145 = C::u64_from_u32(ctx, v144);
                                        if let Some(v146) = v145 {
                                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                                            let v267 = constructor_pulley_xsub64_u32(ctx, v129, v146);
                                            let v268 = constructor_output_xreg(ctx, v267);
                                            let v269 = Some(v268);
                                            // Rule at src/isa/pulley_shared/lower.isle line 330.
                                            return v269;
                                        }
                                    }
                                    let v120 = C::ty_int(ctx, v101);
                                    if let Some(v121) = v120 {
                                        let v137 = C::fits_in_32(ctx, v121);
                                        if let Some(v138) = v137 {
                                            let v144 = C::u64_from_imm64(ctx, v143);
                                            let v150 = C::u64_from_u8(ctx, v144);
                                            if let Some(v151) = v150 {
                                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                                let v264 = constructor_pulley_xsub32_u8(ctx, v129, v151);
                                                let v265 = constructor_output_xreg(ctx, v264);
                                                let v266 = Some(v265);
                                                // Rule at src/isa/pulley_shared/lower.isle line 328.
                                                return v266;
                                            }
                                            let v145 = C::u64_from_u32(ctx, v144);
                                            if let Some(v146) = v145 {
                                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                                let v261 = constructor_pulley_xsub32_u32(ctx, v129, v146);
                                                let v262 = constructor_output_xreg(ctx, v261);
                                                let v263 = Some(v262);
                                                // Rule at src/isa/pulley_shared/lower.isle line 326.
                                                return v263;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v258 = constructor_pulley_xsub64(ctx, v129, v130);
                                let v259 = constructor_output_xreg(ctx, v258);
                                let v260 = Some(v259);
                                // Rule at src/isa/pulley_shared/lower.isle line 323.
                                return v260;
                            }
                            I128 => {
                                let v177 = C::put_in_regs(ctx, v126.0);
                                let v178 = C::put_in_regs(ctx, v126.1);
                                let v180 = C::value_regs_get(ctx, v177, 0x0_usize);
                                let v181 = C::xreg_new(ctx, v180);
                                let v183 = C::value_regs_get(ctx, v177, 0x1_usize);
                                let v184 = C::xreg_new(ctx, v183);
                                let v185 = C::value_regs_get(ctx, v178, 0x0_usize);
                                let v186 = C::xreg_new(ctx, v185);
                                let v187 = C::value_regs_get(ctx, v178, 0x1_usize);
                                let v188 = C::xreg_new(ctx, v187);
                                let v285 = constructor_pulley_xsub128(ctx, v181, v184, v186, v188);
                                let v286 = C::output(ctx, v285);
                                let v287 = Some(v286);
                                // Rule at src/isa/pulley_shared/lower.isle line 351.
                                return v287;
                            }
                            I8X16 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v288 = constructor_pulley_vsubi8x16(ctx, v192, v193);
                                let v289 = constructor_output_vreg(ctx, v288);
                                let v290 = Some(v289);
                                // Rule at src/isa/pulley_shared/lower.isle line 361.
                                return v290;
                            }
                            I16X8 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v291 = constructor_pulley_vsubi16x8(ctx, v192, v193);
                                let v292 = constructor_output_vreg(ctx, v291);
                                let v293 = Some(v292);
                                // Rule at src/isa/pulley_shared/lower.isle line 362.
                                return v293;
                            }
                            I32X4 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v294 = constructor_pulley_vsubi32x4(ctx, v192, v193);
                                let v295 = constructor_output_vreg(ctx, v294);
                                let v296 = Some(v295);
                                // Rule at src/isa/pulley_shared/lower.isle line 363.
                                return v296;
                            }
                            I64X2 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v297 = constructor_pulley_vsubi64x2(ctx, v192, v193);
                                let v298 = constructor_output_vreg(ctx, v297);
                                let v299 = Some(v298);
                                // Rule at src/isa/pulley_shared/lower.isle line 364.
                                return v299;
                            }
                            _ => {}
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v255 = constructor_pulley_xsub32(ctx, v129, v130);
                                let v256 = constructor_output_xreg(ctx, v255);
                                let v257 = Some(v256);
                                // Rule at src/isa/pulley_shared/lower.isle line 322.
                                return v257;
                            }
                        }
                    }
                }
                &Opcode::Imul => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v318 = C::i64_from_iconst(ctx, v126.1);
                                if let Some(v319) = v318 {
                                    let v328 = C::i64_from_i8(ctx, v319);
                                    if let Some(v329) = v328 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v333 = constructor_pulley_xmul64_s8(ctx, v129, v329);
                                        let v334 = constructor_output_xreg(ctx, v333);
                                        let v335 = Some(v334);
                                        // Rule at src/isa/pulley_shared/lower.isle line 384.
                                        return v335;
                                    }
                                }
                            }
                            I128 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v139 = C::def_inst(ctx, v126.1);
                                if let Some(v140) = v139 {
                                    let v141 = &C::inst_data_value(ctx, v140);
                                    if let &InstructionData::Unary {
                                        opcode: ref v338,
                                        arg: v339,
                                    } = v141 {
                                        match v338 {
                                            &Opcode::Uextend => {
                                                let v218 = C::def_inst(ctx, v126.0);
                                                if let Some(v219) = v218 {
                                                    let v220 = &C::inst_data_value(ctx, v219);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v336,
                                                        arg: v337,
                                                    } = v220 {
                                                        if let &Opcode::Uextend = v336 {
                                                            let v340 = constructor_zext64(ctx, v337);
                                                            let v341 = constructor_zext64(ctx, v339);
                                                            let v342 = constructor_pulley_xwidemul64_u(ctx, v340, v341);
                                                            let v343 = C::output(ctx, v342);
                                                            let v344 = Some(v343);
                                                            // Rule at src/isa/pulley_shared/lower.isle line 388.
                                                            return v344;
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::Sextend => {
                                                let v218 = C::def_inst(ctx, v126.0);
                                                if let Some(v219) = v218 {
                                                    let v220 = &C::inst_data_value(ctx, v219);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v336,
                                                        arg: v337,
                                                    } = v220 {
                                                        if let &Opcode::Sextend = v336 {
                                                            let v345 = constructor_sext64(ctx, v337);
                                                            let v346 = constructor_sext64(ctx, v339);
                                                            let v347 = constructor_pulley_xwidemul64_s(ctx, v345, v346);
                                                            let v348 = C::output(ctx, v347);
                                                            let v349 = Some(v348);
                                                            // Rule at src/isa/pulley_shared/lower.isle line 390.
                                                            return v349;
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                        let v126 = C::unpack_value_array_2(ctx, v125);
                        let v318 = C::i64_from_iconst(ctx, v126.1);
                        if let Some(v319) = v318 {
                            let v120 = C::ty_int(ctx, v101);
                            if let Some(v121) = v120 {
                                let v137 = C::fits_in_32(ctx, v121);
                                if let Some(v138) = v137 {
                                    let v328 = C::i64_from_i8(ctx, v319);
                                    if let Some(v329) = v328 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v330 = constructor_pulley_xmul32_s8(ctx, v129, v329);
                                        let v331 = constructor_output_xreg(ctx, v330);
                                        let v332 = Some(v331);
                                        // Rule at src/isa/pulley_shared/lower.isle line 382.
                                        return v332;
                                    }
                                }
                            }
                            let v320 = C::i64_from_i32(ctx, v319);
                            if let Some(v321) = v320 {
                                if v101 == I64 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v325 = constructor_pulley_xmul64_s32(ctx, v129, v321);
                                    let v326 = constructor_output_xreg(ctx, v325);
                                    let v327 = Some(v326);
                                    // Rule at src/isa/pulley_shared/lower.isle line 380.
                                    return v327;
                                }
                                if let Some(v121) = v120 {
                                    let v137 = C::fits_in_32(ctx, v121);
                                    if let Some(v138) = v137 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v322 = constructor_pulley_xmul32_s32(ctx, v129, v321);
                                        let v323 = constructor_output_xreg(ctx, v322);
                                        let v324 = Some(v323);
                                        // Rule at src/isa/pulley_shared/lower.isle line 378.
                                        return v324;
                                    }
                                }
                            }
                        }
                        match v101 {
                            I8 => {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v312 = constructor_pulley_xmul32(ctx, v129, v130);
                                let v313 = constructor_output_xreg(ctx, v312);
                                let v314 = Some(v313);
                                // Rule at src/isa/pulley_shared/lower.isle line 373.
                                return v314;
                            }
                            I16 => {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v312 = constructor_pulley_xmul32(ctx, v129, v130);
                                let v313 = constructor_output_xreg(ctx, v312);
                                let v314 = Some(v313);
                                // Rule at src/isa/pulley_shared/lower.isle line 374.
                                return v314;
                            }
                            I32 => {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v312 = constructor_pulley_xmul32(ctx, v129, v130);
                                let v313 = constructor_output_xreg(ctx, v312);
                                let v314 = Some(v313);
                                // Rule at src/isa/pulley_shared/lower.isle line 375.
                                return v314;
                            }
                            I64 => {
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v315 = constructor_pulley_xmul64(ctx, v129, v130);
                                let v316 = constructor_output_xreg(ctx, v315);
                                let v317 = Some(v316);
                                // Rule at src/isa/pulley_shared/lower.isle line 376.
                                return v317;
                            }
                            I128 => {
                                let v177 = C::put_in_regs(ctx, v126.0);
                                let v350 = C::value_regs_get(ctx, v177, 0x0_usize);
                                let v351 = C::xreg_new(ctx, v350);
                                let v352 = C::value_regs_get(ctx, v177, 0x1_usize);
                                let v353 = C::xreg_new(ctx, v352);
                                let v354 = C::put_in_regs(ctx, v126.1);
                                let v355 = C::value_regs_get(ctx, v354, 0x0_usize);
                                let v356 = C::xreg_new(ctx, v355);
                                let v357 = C::value_regs_get(ctx, v354, 0x1_usize);
                                let v358 = C::xreg_new(ctx, v357);
                                let v359 = constructor_pulley_xwidemul64_u(ctx, v351, v356);
                                let v360 = C::value_regs_get(ctx, v359, 0x0_usize);
                                let v361 = C::xreg_new(ctx, v360);
                                let v362 = C::value_regs_get(ctx, v359, 0x1_usize);
                                let v363 = C::xreg_new(ctx, v362);
                                let v364 = constructor_pulley_xmul64(ctx, v351, v358);
                                let v365 = constructor_pulley_xmul64(ctx, v353, v356);
                                let v366 = constructor_pulley_xadd64(ctx, v363, v364);
                                let v367 = constructor_pulley_xadd64(ctx, v366, v365);
                                let v368 = C::xreg_to_reg(ctx, v361);
                                let v369 = C::xreg_to_reg(ctx, v367);
                                let v370 = C::value_regs(ctx, v368, v369);
                                let v371 = C::output(ctx, v370);
                                let v372 = Some(v371);
                                // Rule at src/isa/pulley_shared/lower.isle line 394.
                                return v372;
                            }
                            I8X16 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v373 = constructor_pulley_vmuli8x16(ctx, v192, v193);
                                let v374 = constructor_output_vreg(ctx, v373);
                                let v375 = Some(v374);
                                // Rule at src/isa/pulley_shared/lower.isle line 419.
                                return v375;
                            }
                            I16X8 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v376 = constructor_pulley_vmuli16x8(ctx, v192, v193);
                                let v377 = constructor_output_vreg(ctx, v376);
                                let v378 = Some(v377);
                                // Rule at src/isa/pulley_shared/lower.isle line 420.
                                return v378;
                            }
                            I32X4 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v379 = constructor_pulley_vmuli32x4(ctx, v192, v193);
                                let v380 = constructor_output_vreg(ctx, v379);
                                let v381 = Some(v380);
                                // Rule at src/isa/pulley_shared/lower.isle line 421.
                                return v381;
                            }
                            I64X2 => {
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v382 = constructor_pulley_vmuli64x2(ctx, v192, v193);
                                let v383 = constructor_output_vreg(ctx, v382);
                                let v384 = Some(v383);
                                // Rule at src/isa/pulley_shared/lower.isle line 422.
                                return v384;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Umulhi => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8 => {
                                let v386 = C::u64_try_into_u8(ctx, 0x8_u64);
                                if let Some(v387) = v386 {
                                    let v388 = C::u6_from_u8(ctx, v387);
                                    if let Some(v389) = v388 {
                                        let v126 = C::unpack_value_array_2(ctx, v125);
                                        let v390 = constructor_zext32(ctx, v126.0);
                                        let v391 = constructor_zext32(ctx, v126.1);
                                        let v392 = constructor_pulley_xmul32(ctx, v390, v391);
                                        let v393 = constructor_pulley_xshr32_u_u6(ctx, v392, v389);
                                        let v394 = constructor_output_xreg(ctx, v393);
                                        let v395 = Some(v394);
                                        // Rule at src/isa/pulley_shared/lower.isle line 426.
                                        return v395;
                                    }
                                }
                            }
                            I16 => {
                                let v397 = C::u64_try_into_u8(ctx, 0x10_u64);
                                if let Some(v398) = v397 {
                                    let v399 = C::u6_from_u8(ctx, v398);
                                    if let Some(v400) = v399 {
                                        let v126 = C::unpack_value_array_2(ctx, v125);
                                        let v390 = constructor_zext32(ctx, v126.0);
                                        let v391 = constructor_zext32(ctx, v126.1);
                                        let v392 = constructor_pulley_xmul32(ctx, v390, v391);
                                        let v401 = constructor_pulley_xshr32_u_u6(ctx, v392, v400);
                                        let v402 = constructor_output_xreg(ctx, v401);
                                        let v403 = Some(v402);
                                        // Rule at src/isa/pulley_shared/lower.isle line 430.
                                        return v403;
                                    }
                                }
                            }
                            I32 => {
                                let v405 = C::u64_try_into_u8(ctx, 0x20_u64);
                                if let Some(v406) = v405 {
                                    let v407 = C::u6_from_u8(ctx, v406);
                                    if let Some(v408) = v407 {
                                        let v126 = C::unpack_value_array_2(ctx, v125);
                                        let v409 = constructor_zext64(ctx, v126.0);
                                        let v410 = constructor_zext64(ctx, v126.1);
                                        let v411 = constructor_pulley_xmul64(ctx, v409, v410);
                                        let v412 = constructor_pulley_xshr64_u_u6(ctx, v411, v408);
                                        let v413 = constructor_output_xreg(ctx, v412);
                                        let v414 = Some(v413);
                                        // Rule at src/isa/pulley_shared/lower.isle line 434.
                                        return v414;
                                    }
                                }
                            }
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v415 = constructor_pulley_xmulhi64_u(ctx, v129, v130);
                                let v416 = constructor_output_xreg(ctx, v415);
                                let v417 = Some(v416);
                                // Rule at src/isa/pulley_shared/lower.isle line 438.
                                return v417;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Smulhi => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8 => {
                                let v386 = C::u64_try_into_u8(ctx, 0x8_u64);
                                if let Some(v387) = v386 {
                                    let v388 = C::u6_from_u8(ctx, v387);
                                    if let Some(v389) = v388 {
                                        let v126 = C::unpack_value_array_2(ctx, v125);
                                        let v418 = constructor_sext32(ctx, v126.0);
                                        let v419 = constructor_sext32(ctx, v126.1);
                                        let v420 = constructor_pulley_xmul32(ctx, v418, v419);
                                        let v421 = constructor_pulley_xshr32_s_u6(ctx, v420, v389);
                                        let v422 = constructor_output_xreg(ctx, v421);
                                        let v423 = Some(v422);
                                        // Rule at src/isa/pulley_shared/lower.isle line 443.
                                        return v423;
                                    }
                                }
                            }
                            I16 => {
                                let v397 = C::u64_try_into_u8(ctx, 0x10_u64);
                                if let Some(v398) = v397 {
                                    let v399 = C::u6_from_u8(ctx, v398);
                                    if let Some(v400) = v399 {
                                        let v126 = C::unpack_value_array_2(ctx, v125);
                                        let v418 = constructor_sext32(ctx, v126.0);
                                        let v419 = constructor_sext32(ctx, v126.1);
                                        let v420 = constructor_pulley_xmul32(ctx, v418, v419);
                                        let v424 = constructor_pulley_xshr32_s_u6(ctx, v420, v400);
                                        let v425 = constructor_output_xreg(ctx, v424);
                                        let v426 = Some(v425);
                                        // Rule at src/isa/pulley_shared/lower.isle line 447.
                                        return v426;
                                    }
                                }
                            }
                            I32 => {
                                let v405 = C::u64_try_into_u8(ctx, 0x20_u64);
                                if let Some(v406) = v405 {
                                    let v407 = C::u6_from_u8(ctx, v406);
                                    if let Some(v408) = v407 {
                                        let v126 = C::unpack_value_array_2(ctx, v125);
                                        let v427 = constructor_sext64(ctx, v126.0);
                                        let v428 = constructor_sext64(ctx, v126.1);
                                        let v429 = constructor_pulley_xmul64(ctx, v427, v428);
                                        let v430 = constructor_pulley_xshr64_s_u6(ctx, v429, v408);
                                        let v431 = constructor_output_xreg(ctx, v430);
                                        let v432 = Some(v431);
                                        // Rule at src/isa/pulley_shared/lower.isle line 451.
                                        return v432;
                                    }
                                }
                            }
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v433 = constructor_pulley_xmulhi64_s(ctx, v129, v130);
                                let v434 = constructor_output_xreg(ctx, v433);
                                let v435 = Some(v434);
                                // Rule at src/isa/pulley_shared/lower.isle line 455.
                                return v435;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::SqmulRoundSat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I16X8 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v436 = constructor_pulley_vqmulrsi16x8(ctx, v192, v193);
                            let v437 = constructor_output_vreg(ctx, v436);
                            let v438 = Some(v437);
                            // Rule at src/isa/pulley_shared/lower.isle line 460.
                            return v438;
                        }
                    }
                }
                &Opcode::Udiv => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v456 = constructor_pulley_xdiv64_u(ctx, v129, v130);
                            let v457 = constructor_output_xreg(ctx, v456);
                            let v458 = Some(v457);
                            // Rule at src/isa/pulley_shared/lower.isle line 478.
                            return v458;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v390 = constructor_zext32(ctx, v126.0);
                                let v391 = constructor_zext32(ctx, v126.1);
                                let v453 = constructor_pulley_xdiv32_u(ctx, v390, v391);
                                let v454 = constructor_output_xreg(ctx, v453);
                                let v455 = Some(v454);
                                // Rule at src/isa/pulley_shared/lower.isle line 476.
                                return v455;
                            }
                        }
                    }
                }
                &Opcode::Sdiv => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v444 = constructor_pulley_xdiv64_s(ctx, v129, v130);
                            let v445 = constructor_output_xreg(ctx, v444);
                            let v446 = Some(v445);
                            // Rule at src/isa/pulley_shared/lower.isle line 466.
                            return v446;
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v418 = constructor_sext32(ctx, v126.0);
                            let v419 = constructor_sext32(ctx, v126.1);
                            let v441 = constructor_pulley_xdiv32_s(ctx, v418, v419);
                            let v442 = constructor_output_xreg(ctx, v441);
                            let v443 = Some(v442);
                            // Rule at src/isa/pulley_shared/lower.isle line 464.
                            return v443;
                        }
                    }
                }
                &Opcode::Urem => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v462 = constructor_pulley_xrem64_u(ctx, v129, v130);
                            let v463 = constructor_output_xreg(ctx, v462);
                            let v464 = Some(v463);
                            // Rule at src/isa/pulley_shared/lower.isle line 484.
                            return v464;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v390 = constructor_zext32(ctx, v126.0);
                                let v391 = constructor_zext32(ctx, v126.1);
                                let v459 = constructor_pulley_xrem32_u(ctx, v390, v391);
                                let v460 = constructor_output_xreg(ctx, v459);
                                let v461 = Some(v460);
                                // Rule at src/isa/pulley_shared/lower.isle line 482.
                                return v461;
                            }
                        }
                    }
                }
                &Opcode::Srem => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v450 = constructor_pulley_xrem64_s(ctx, v129, v130);
                            let v451 = constructor_output_xreg(ctx, v450);
                            let v452 = Some(v451);
                            // Rule at src/isa/pulley_shared/lower.isle line 472.
                            return v452;
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v418 = constructor_sext32(ctx, v126.0);
                            let v419 = constructor_sext32(ctx, v126.1);
                            let v447 = constructor_pulley_xrem32_s(ctx, v418, v419);
                            let v448 = constructor_output_xreg(ctx, v447);
                            let v449 = Some(v448);
                            // Rule at src/isa/pulley_shared/lower.isle line 470.
                            return v449;
                        }
                    }
                }
                &Opcode::Band => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v126 = C::unpack_value_array_2(ctx, v125);
                        let v318 = C::i64_from_iconst(ctx, v126.1);
                        if let Some(v319) = v318 {
                            let v328 = C::i64_from_i8(ctx, v319);
                            if let Some(v329) = v328 {
                                let v101 = C::value_type(ctx, v100);
                                if v101 == I64 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v582 = constructor_pulley_xband64_s8(ctx, v129, v329);
                                    let v583 = constructor_output_xreg(ctx, v582);
                                    let v584 = Some(v583);
                                    // Rule at src/isa/pulley_shared/lower.isle line 599.
                                    return v584;
                                }
                                let v120 = C::ty_int(ctx, v101);
                                if let Some(v121) = v120 {
                                    let v137 = C::fits_in_32(ctx, v121);
                                    if let Some(v138) = v137 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v579 = constructor_pulley_xband32_s8(ctx, v129, v329);
                                        let v580 = constructor_output_xreg(ctx, v579);
                                        let v581 = Some(v580);
                                        // Rule at src/isa/pulley_shared/lower.isle line 597.
                                        return v581;
                                    }
                                }
                            }
                            let v320 = C::i64_from_i32(ctx, v319);
                            if let Some(v321) = v320 {
                                let v101 = C::value_type(ctx, v100);
                                if v101 == I64 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v576 = constructor_pulley_xband64_s32(ctx, v129, v321);
                                    let v577 = constructor_output_xreg(ctx, v576);
                                    let v578 = Some(v577);
                                    // Rule at src/isa/pulley_shared/lower.isle line 595.
                                    return v578;
                                }
                                let v120 = C::ty_int(ctx, v101);
                                if let Some(v121) = v120 {
                                    let v137 = C::fits_in_32(ctx, v121);
                                    if let Some(v138) = v137 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v573 = constructor_pulley_xband32_s32(ctx, v129, v321);
                                        let v574 = constructor_output_xreg(ctx, v573);
                                        let v575 = Some(v574);
                                        // Rule at src/isa/pulley_shared/lower.isle line 593.
                                        return v575;
                                    }
                                }
                            }
                        }
                        let v101 = C::value_type(ctx, v100);
                        let v585 = C::ty_vec128(ctx, v101);
                        if let Some(v586) = v585 {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v587 = constructor_pulley_vband128(ctx, v192, v193);
                            let v588 = constructor_output_vreg(ctx, v587);
                            let v589 = Some(v588);
                            // Rule at src/isa/pulley_shared/lower.isle line 602.
                            return v589;
                        }
                        if v101 == I64 {
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v570 = constructor_pulley_xband64(ctx, v129, v130);
                            let v571 = constructor_output_xreg(ctx, v570);
                            let v572 = Some(v571);
                            // Rule at src/isa/pulley_shared/lower.isle line 591.
                            return v572;
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v567 = constructor_pulley_xband32(ctx, v129, v130);
                            let v568 = constructor_output_xreg(ctx, v567);
                            let v569 = Some(v568);
                            // Rule at src/isa/pulley_shared/lower.isle line 590.
                            return v569;
                        }
                    }
                }
                &Opcode::Bor => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v126 = C::unpack_value_array_2(ctx, v125);
                        let v318 = C::i64_from_iconst(ctx, v126.1);
                        if let Some(v319) = v318 {
                            let v328 = C::i64_from_i8(ctx, v319);
                            if let Some(v329) = v328 {
                                let v101 = C::value_type(ctx, v100);
                                if v101 == I64 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v605 = constructor_pulley_xbor64_s8(ctx, v129, v329);
                                    let v606 = constructor_output_xreg(ctx, v605);
                                    let v607 = Some(v606);
                                    // Rule at src/isa/pulley_shared/lower.isle line 616.
                                    return v607;
                                }
                                let v120 = C::ty_int(ctx, v101);
                                if let Some(v121) = v120 {
                                    let v137 = C::fits_in_32(ctx, v121);
                                    if let Some(v138) = v137 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v602 = constructor_pulley_xbor32_s8(ctx, v129, v329);
                                        let v603 = constructor_output_xreg(ctx, v602);
                                        let v604 = Some(v603);
                                        // Rule at src/isa/pulley_shared/lower.isle line 614.
                                        return v604;
                                    }
                                }
                            }
                            let v320 = C::i64_from_i32(ctx, v319);
                            if let Some(v321) = v320 {
                                let v101 = C::value_type(ctx, v100);
                                if v101 == I64 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v599 = constructor_pulley_xbor64_s32(ctx, v129, v321);
                                    let v600 = constructor_output_xreg(ctx, v599);
                                    let v601 = Some(v600);
                                    // Rule at src/isa/pulley_shared/lower.isle line 612.
                                    return v601;
                                }
                                let v120 = C::ty_int(ctx, v101);
                                if let Some(v121) = v120 {
                                    let v137 = C::fits_in_32(ctx, v121);
                                    if let Some(v138) = v137 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v596 = constructor_pulley_xbor32_s32(ctx, v129, v321);
                                        let v597 = constructor_output_xreg(ctx, v596);
                                        let v598 = Some(v597);
                                        // Rule at src/isa/pulley_shared/lower.isle line 610.
                                        return v598;
                                    }
                                }
                            }
                        }
                        let v101 = C::value_type(ctx, v100);
                        let v585 = C::ty_vec128(ctx, v101);
                        if let Some(v586) = v585 {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v608 = constructor_pulley_vbor128(ctx, v192, v193);
                            let v609 = constructor_output_vreg(ctx, v608);
                            let v610 = Some(v609);
                            // Rule at src/isa/pulley_shared/lower.isle line 619.
                            return v610;
                        }
                        if v101 == I64 {
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v593 = constructor_pulley_xbor64(ctx, v129, v130);
                            let v594 = constructor_output_xreg(ctx, v593);
                            let v595 = Some(v594);
                            // Rule at src/isa/pulley_shared/lower.isle line 608.
                            return v595;
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v590 = constructor_pulley_xbor32(ctx, v129, v130);
                            let v591 = constructor_output_xreg(ctx, v590);
                            let v592 = Some(v591);
                            // Rule at src/isa/pulley_shared/lower.isle line 607.
                            return v592;
                        }
                    }
                }
                &Opcode::Bxor => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v126 = C::unpack_value_array_2(ctx, v125);
                        let v318 = C::i64_from_iconst(ctx, v126.1);
                        if let Some(v319) = v318 {
                            let v328 = C::i64_from_i8(ctx, v319);
                            if let Some(v329) = v328 {
                                let v101 = C::value_type(ctx, v100);
                                if v101 == I64 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v626 = constructor_pulley_xbxor64_s8(ctx, v129, v329);
                                    let v627 = constructor_output_xreg(ctx, v626);
                                    let v628 = Some(v627);
                                    // Rule at src/isa/pulley_shared/lower.isle line 633.
                                    return v628;
                                }
                                let v120 = C::ty_int(ctx, v101);
                                if let Some(v121) = v120 {
                                    let v137 = C::fits_in_32(ctx, v121);
                                    if let Some(v138) = v137 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v623 = constructor_pulley_xbxor32_s8(ctx, v129, v329);
                                        let v624 = constructor_output_xreg(ctx, v623);
                                        let v625 = Some(v624);
                                        // Rule at src/isa/pulley_shared/lower.isle line 631.
                                        return v625;
                                    }
                                }
                            }
                            let v320 = C::i64_from_i32(ctx, v319);
                            if let Some(v321) = v320 {
                                let v101 = C::value_type(ctx, v100);
                                if v101 == I64 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v620 = constructor_pulley_xbxor64_s32(ctx, v129, v321);
                                    let v621 = constructor_output_xreg(ctx, v620);
                                    let v622 = Some(v621);
                                    // Rule at src/isa/pulley_shared/lower.isle line 629.
                                    return v622;
                                }
                                let v120 = C::ty_int(ctx, v101);
                                if let Some(v121) = v120 {
                                    let v137 = C::fits_in_32(ctx, v121);
                                    if let Some(v138) = v137 {
                                        let v129 = constructor_put_in_xreg(ctx, v126.0);
                                        let v617 = constructor_pulley_xbxor32_s32(ctx, v129, v321);
                                        let v618 = constructor_output_xreg(ctx, v617);
                                        let v619 = Some(v618);
                                        // Rule at src/isa/pulley_shared/lower.isle line 627.
                                        return v619;
                                    }
                                }
                            }
                        }
                        let v101 = C::value_type(ctx, v100);
                        let v585 = C::ty_vec128(ctx, v101);
                        if let Some(v586) = v585 {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v629 = constructor_pulley_vbxor128(ctx, v192, v193);
                            let v630 = constructor_output_vreg(ctx, v629);
                            let v631 = Some(v630);
                            // Rule at src/isa/pulley_shared/lower.isle line 636.
                            return v631;
                        }
                        if v101 == I64 {
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v614 = constructor_pulley_xbxor64(ctx, v129, v130);
                            let v615 = constructor_output_xreg(ctx, v614);
                            let v616 = Some(v615);
                            // Rule at src/isa/pulley_shared/lower.isle line 625.
                            return v616;
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v129 = constructor_put_in_xreg(ctx, v126.0);
                            let v130 = constructor_put_in_xreg(ctx, v126.1);
                            let v611 = constructor_pulley_xbxor32(ctx, v129, v130);
                            let v612 = constructor_output_xreg(ctx, v611);
                            let v613 = Some(v612);
                            // Rule at src/isa/pulley_shared/lower.isle line 624.
                            return v613;
                        }
                    }
                }
                &Opcode::Rotl => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v771 = constructor_pulley_xrotl32(ctx, v129, v130);
                                let v772 = constructor_output_xreg(ctx, v771);
                                let v773 = Some(v772);
                                // Rule at src/isa/pulley_shared/lower.isle line 726.
                                return v773;
                            }
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v774 = constructor_pulley_xrotl64(ctx, v129, v130);
                                let v775 = constructor_output_xreg(ctx, v774);
                                let v776 = Some(v775);
                                // Rule at src/isa/pulley_shared/lower.isle line 727.
                                return v776;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Rotr => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v777 = constructor_pulley_xrotr32(ctx, v129, v130);
                                let v778 = constructor_output_xreg(ctx, v777);
                                let v779 = Some(v778);
                                // Rule at src/isa/pulley_shared/lower.isle line 731.
                                return v779;
                            }
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v780 = constructor_pulley_xrotr64(ctx, v129, v130);
                                let v781 = constructor_output_xreg(ctx, v780);
                                let v782 = Some(v781);
                                // Rule at src/isa/pulley_shared/lower.isle line 732.
                                return v782;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ishl => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v472 = constructor_pulley_xband32_s8(ctx, v130, 7_i8);
                                let v473 = constructor_pulley_xshl32(ctx, v129, v472);
                                let v474 = constructor_output_xreg(ctx, v473);
                                let v475 = Some(v474);
                                // Rule at src/isa/pulley_shared/lower.isle line 493.
                                return v475;
                            }
                            I16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v477 = constructor_pulley_xband32_s8(ctx, v130, 15_i8);
                                let v478 = constructor_pulley_xshl32(ctx, v129, v477);
                                let v479 = constructor_output_xreg(ctx, v478);
                                let v480 = Some(v479);
                                // Rule at src/isa/pulley_shared/lower.isle line 496.
                                return v480;
                            }
                            I32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v487 = constructor_u6_shift_from_iconst(ctx, v126.1);
                                if let Some(v488) = v487 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v489 = constructor_pulley_xshl32_u6(ctx, v129, v488);
                                    let v490 = constructor_output_xreg(ctx, v489);
                                    let v491 = Some(v490);
                                    // Rule at src/isa/pulley_shared/lower.isle line 506.
                                    return v491;
                                }
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v481 = constructor_pulley_xshl32(ctx, v129, v130);
                                let v482 = constructor_output_xreg(ctx, v481);
                                let v483 = Some(v482);
                                // Rule at src/isa/pulley_shared/lower.isle line 499.
                                return v483;
                            }
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v487 = constructor_u6_shift_from_iconst(ctx, v126.1);
                                if let Some(v488) = v487 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v492 = constructor_pulley_xshl64_u6(ctx, v129, v488);
                                    let v493 = constructor_output_xreg(ctx, v492);
                                    let v494 = Some(v493);
                                    // Rule at src/isa/pulley_shared/lower.isle line 509.
                                    return v494;
                                }
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v484 = constructor_pulley_xshl64(ctx, v129, v130);
                                let v485 = constructor_output_xreg(ctx, v484);
                                let v486 = Some(v485);
                                // Rule at src/isa/pulley_shared/lower.isle line 502.
                                return v486;
                            }
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v495 = constructor_pulley_vshli8x16(ctx, v192, v130);
                                let v496 = constructor_output_vreg(ctx, v495);
                                let v497 = Some(v496);
                                // Rule at src/isa/pulley_shared/lower.isle line 515.
                                return v497;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v498 = constructor_pulley_vshli16x8(ctx, v192, v130);
                                let v499 = constructor_output_vreg(ctx, v498);
                                let v500 = Some(v499);
                                // Rule at src/isa/pulley_shared/lower.isle line 516.
                                return v500;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v501 = constructor_pulley_vshli32x4(ctx, v192, v130);
                                let v502 = constructor_output_vreg(ctx, v501);
                                let v503 = Some(v502);
                                // Rule at src/isa/pulley_shared/lower.isle line 517.
                                return v503;
                            }
                            I64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v504 = constructor_pulley_vshli64x2(ctx, v192, v130);
                                let v505 = constructor_output_vreg(ctx, v504);
                                let v506 = Some(v505);
                                // Rule at src/isa/pulley_shared/lower.isle line 518.
                                return v506;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ushr => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v390 = constructor_zext32(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v472 = constructor_pulley_xband32_s8(ctx, v130, 7_i8);
                                let v507 = constructor_pulley_xshr32_u(ctx, v390, v472);
                                let v508 = constructor_output_xreg(ctx, v507);
                                let v509 = Some(v508);
                                // Rule at src/isa/pulley_shared/lower.isle line 532.
                                return v509;
                            }
                            I16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v390 = constructor_zext32(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v477 = constructor_pulley_xband32_s8(ctx, v130, 15_i8);
                                let v510 = constructor_pulley_xshr32_u(ctx, v390, v477);
                                let v511 = constructor_output_xreg(ctx, v510);
                                let v512 = Some(v511);
                                // Rule at src/isa/pulley_shared/lower.isle line 535.
                                return v512;
                            }
                            I32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v487 = constructor_u6_shift_from_iconst(ctx, v126.1);
                                if let Some(v488) = v487 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v519 = constructor_pulley_xshr32_u_u6(ctx, v129, v488);
                                    let v520 = constructor_output_xreg(ctx, v519);
                                    let v521 = Some(v520);
                                    // Rule at src/isa/pulley_shared/lower.isle line 545.
                                    return v521;
                                }
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v513 = constructor_pulley_xshr32_u(ctx, v129, v130);
                                let v514 = constructor_output_xreg(ctx, v513);
                                let v515 = Some(v514);
                                // Rule at src/isa/pulley_shared/lower.isle line 538.
                                return v515;
                            }
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v487 = constructor_u6_shift_from_iconst(ctx, v126.1);
                                if let Some(v488) = v487 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v522 = constructor_pulley_xshr64_u_u6(ctx, v129, v488);
                                    let v523 = constructor_output_xreg(ctx, v522);
                                    let v524 = Some(v523);
                                    // Rule at src/isa/pulley_shared/lower.isle line 548.
                                    return v524;
                                }
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v516 = constructor_pulley_xshr64_u(ctx, v129, v130);
                                let v517 = constructor_output_xreg(ctx, v516);
                                let v518 = Some(v517);
                                // Rule at src/isa/pulley_shared/lower.isle line 541.
                                return v518;
                            }
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v525 = constructor_pulley_vshri8x16_u(ctx, v192, v130);
                                let v526 = constructor_output_vreg(ctx, v525);
                                let v527 = Some(v526);
                                // Rule at src/isa/pulley_shared/lower.isle line 554.
                                return v527;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v528 = constructor_pulley_vshri16x8_u(ctx, v192, v130);
                                let v529 = constructor_output_vreg(ctx, v528);
                                let v530 = Some(v529);
                                // Rule at src/isa/pulley_shared/lower.isle line 555.
                                return v530;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v531 = constructor_pulley_vshri32x4_u(ctx, v192, v130);
                                let v532 = constructor_output_vreg(ctx, v531);
                                let v533 = Some(v532);
                                // Rule at src/isa/pulley_shared/lower.isle line 556.
                                return v533;
                            }
                            I64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v534 = constructor_pulley_vshri64x2_u(ctx, v192, v130);
                                let v535 = constructor_output_vreg(ctx, v534);
                                let v536 = Some(v535);
                                // Rule at src/isa/pulley_shared/lower.isle line 557.
                                return v536;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Sshr => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v418 = constructor_sext32(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v472 = constructor_pulley_xband32_s8(ctx, v130, 7_i8);
                                let v537 = constructor_pulley_xshr32_u(ctx, v418, v472);
                                let v538 = constructor_output_xreg(ctx, v537);
                                let v539 = Some(v538);
                                // Rule at src/isa/pulley_shared/lower.isle line 561.
                                return v539;
                            }
                            I16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v418 = constructor_sext32(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v477 = constructor_pulley_xband32_s8(ctx, v130, 15_i8);
                                let v540 = constructor_pulley_xshr32_u(ctx, v418, v477);
                                let v541 = constructor_output_xreg(ctx, v540);
                                let v542 = Some(v541);
                                // Rule at src/isa/pulley_shared/lower.isle line 564.
                                return v542;
                            }
                            I32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v487 = constructor_u6_shift_from_iconst(ctx, v126.1);
                                if let Some(v488) = v487 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v549 = constructor_pulley_xshr32_s_u6(ctx, v129, v488);
                                    let v550 = constructor_output_xreg(ctx, v549);
                                    let v551 = Some(v550);
                                    // Rule at src/isa/pulley_shared/lower.isle line 574.
                                    return v551;
                                }
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v543 = constructor_pulley_xshr32_s(ctx, v129, v130);
                                let v544 = constructor_output_xreg(ctx, v543);
                                let v545 = Some(v544);
                                // Rule at src/isa/pulley_shared/lower.isle line 567.
                                return v545;
                            }
                            I64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v487 = constructor_u6_shift_from_iconst(ctx, v126.1);
                                if let Some(v488) = v487 {
                                    let v129 = constructor_put_in_xreg(ctx, v126.0);
                                    let v552 = constructor_pulley_xshr64_s_u6(ctx, v129, v488);
                                    let v553 = constructor_output_xreg(ctx, v552);
                                    let v554 = Some(v553);
                                    // Rule at src/isa/pulley_shared/lower.isle line 577.
                                    return v554;
                                }
                                let v129 = constructor_put_in_xreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v546 = constructor_pulley_xshr64_s(ctx, v129, v130);
                                let v547 = constructor_output_xreg(ctx, v546);
                                let v548 = Some(v547);
                                // Rule at src/isa/pulley_shared/lower.isle line 570.
                                return v548;
                            }
                            I8X16 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v555 = constructor_pulley_vshri8x16_s(ctx, v192, v130);
                                let v556 = constructor_output_vreg(ctx, v555);
                                let v557 = Some(v556);
                                // Rule at src/isa/pulley_shared/lower.isle line 583.
                                return v557;
                            }
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v558 = constructor_pulley_vshri16x8_s(ctx, v192, v130);
                                let v559 = constructor_output_vreg(ctx, v558);
                                let v560 = Some(v559);
                                // Rule at src/isa/pulley_shared/lower.isle line 584.
                                return v560;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v561 = constructor_pulley_vshri32x4_s(ctx, v192, v130);
                                let v562 = constructor_output_vreg(ctx, v561);
                                let v563 = Some(v562);
                                // Rule at src/isa/pulley_shared/lower.isle line 585.
                                return v563;
                            }
                            I64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v130 = constructor_put_in_xreg(ctx, v126.1);
                                let v564 = constructor_pulley_vshri64x2_s(ctx, v192, v130);
                                let v565 = constructor_output_vreg(ctx, v564);
                                let v566 = Some(v565);
                                // Rule at src/isa/pulley_shared/lower.isle line 586.
                                return v566;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fadd => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1184 = constructor_pulley_fadd32(ctx, v1176, v1177);
                                let v1185 = constructor_output_freg(ctx, v1184);
                                let v1186 = Some(v1185);
                                // Rule at src/isa/pulley_shared/lower.isle line 1544.
                                return v1186;
                            }
                            F64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1187 = constructor_pulley_fadd64(ctx, v1176, v1177);
                                let v1188 = constructor_output_freg(ctx, v1187);
                                let v1189 = Some(v1188);
                                // Rule at src/isa/pulley_shared/lower.isle line 1545.
                                return v1189;
                            }
                            F32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1190 = constructor_pulley_vaddf32x4(ctx, v192, v193);
                                let v1191 = constructor_output_vreg(ctx, v1190);
                                let v1192 = Some(v1191);
                                // Rule at src/isa/pulley_shared/lower.isle line 1546.
                                return v1192;
                            }
                            F64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1193 = constructor_pulley_vaddf64x2(ctx, v192, v193);
                                let v1194 = constructor_output_vreg(ctx, v1193);
                                let v1195 = Some(v1194);
                                // Rule at src/isa/pulley_shared/lower.isle line 1547.
                                return v1195;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fsub => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1196 = constructor_pulley_fsub32(ctx, v1176, v1177);
                                let v1197 = constructor_output_freg(ctx, v1196);
                                let v1198 = Some(v1197);
                                // Rule at src/isa/pulley_shared/lower.isle line 1551.
                                return v1198;
                            }
                            F64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1199 = constructor_pulley_fsub64(ctx, v1176, v1177);
                                let v1200 = constructor_output_freg(ctx, v1199);
                                let v1201 = Some(v1200);
                                // Rule at src/isa/pulley_shared/lower.isle line 1552.
                                return v1201;
                            }
                            F32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1202 = constructor_pulley_vsubf32x4(ctx, v192, v193);
                                let v1203 = constructor_output_vreg(ctx, v1202);
                                let v1204 = Some(v1203);
                                // Rule at src/isa/pulley_shared/lower.isle line 1553.
                                return v1204;
                            }
                            F64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1205 = constructor_pulley_vsubf64x2(ctx, v192, v193);
                                let v1206 = constructor_output_vreg(ctx, v1205);
                                let v1207 = Some(v1206);
                                // Rule at src/isa/pulley_shared/lower.isle line 1554.
                                return v1207;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fmul => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1208 = constructor_pulley_fmul32(ctx, v1176, v1177);
                                let v1209 = constructor_output_freg(ctx, v1208);
                                let v1210 = Some(v1209);
                                // Rule at src/isa/pulley_shared/lower.isle line 1558.
                                return v1210;
                            }
                            F64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1211 = constructor_pulley_fmul64(ctx, v1176, v1177);
                                let v1212 = constructor_output_freg(ctx, v1211);
                                let v1213 = Some(v1212);
                                // Rule at src/isa/pulley_shared/lower.isle line 1559.
                                return v1213;
                            }
                            F32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1214 = constructor_pulley_vmulf32x4(ctx, v192, v193);
                                let v1215 = constructor_output_vreg(ctx, v1214);
                                let v1216 = Some(v1215);
                                // Rule at src/isa/pulley_shared/lower.isle line 1560.
                                return v1216;
                            }
                            F64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1217 = constructor_pulley_vmulf64x2(ctx, v192, v193);
                                let v1218 = constructor_output_vreg(ctx, v1217);
                                let v1219 = Some(v1218);
                                // Rule at src/isa/pulley_shared/lower.isle line 1561.
                                return v1219;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fdiv => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1220 = constructor_pulley_fdiv32(ctx, v1176, v1177);
                                let v1221 = constructor_output_freg(ctx, v1220);
                                let v1222 = Some(v1221);
                                // Rule at src/isa/pulley_shared/lower.isle line 1565.
                                return v1222;
                            }
                            F64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1223 = constructor_pulley_fdiv64(ctx, v1176, v1177);
                                let v1224 = constructor_output_freg(ctx, v1223);
                                let v1225 = Some(v1224);
                                // Rule at src/isa/pulley_shared/lower.isle line 1566.
                                return v1225;
                            }
                            F32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1226 = constructor_pulley_vdivf32x4(ctx, v192, v193);
                                let v1227 = constructor_output_vreg(ctx, v1226);
                                let v1228 = Some(v1227);
                                // Rule at src/isa/pulley_shared/lower.isle line 1567.
                                return v1228;
                            }
                            F64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1229 = constructor_pulley_vdivf64x2(ctx, v192, v193);
                                let v1230 = constructor_output_vreg(ctx, v1229);
                                let v1231 = Some(v1230);
                                // Rule at src/isa/pulley_shared/lower.isle line 1568.
                                return v1231;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fcopysign => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1178 = constructor_pulley_fcopysign32(ctx, v1176, v1177);
                                let v1179 = constructor_output_freg(ctx, v1178);
                                let v1180 = Some(v1179);
                                // Rule at src/isa/pulley_shared/lower.isle line 1536.
                                return v1180;
                            }
                            F64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1181 = constructor_pulley_fcopysign64(ctx, v1176, v1177);
                                let v1182 = constructor_output_freg(ctx, v1181);
                                let v1183 = Some(v1182);
                                // Rule at src/isa/pulley_shared/lower.isle line 1539.
                                return v1183;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fmin => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1244 = constructor_pulley_fminimum32(ctx, v1176, v1177);
                                let v1245 = constructor_output_freg(ctx, v1244);
                                let v1246 = Some(v1245);
                                // Rule at src/isa/pulley_shared/lower.isle line 1579.
                                return v1246;
                            }
                            F64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1247 = constructor_pulley_fminimum64(ctx, v1176, v1177);
                                let v1248 = constructor_output_freg(ctx, v1247);
                                let v1249 = Some(v1248);
                                // Rule at src/isa/pulley_shared/lower.isle line 1580.
                                return v1249;
                            }
                            F32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1250 = constructor_pulley_vminimumf32x4(ctx, v192, v193);
                                let v1251 = constructor_output_vreg(ctx, v1250);
                                let v1252 = Some(v1251);
                                // Rule at src/isa/pulley_shared/lower.isle line 1581.
                                return v1252;
                            }
                            F64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1253 = constructor_pulley_vminimumf64x2(ctx, v192, v193);
                                let v1254 = constructor_output_vreg(ctx, v1253);
                                let v1255 = Some(v1254);
                                // Rule at src/isa/pulley_shared/lower.isle line 1582.
                                return v1255;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fmax => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1232 = constructor_pulley_fmaximum32(ctx, v1176, v1177);
                                let v1233 = constructor_output_freg(ctx, v1232);
                                let v1234 = Some(v1233);
                                // Rule at src/isa/pulley_shared/lower.isle line 1572.
                                return v1234;
                            }
                            F64 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v1176 = constructor_put_in_freg(ctx, v126.0);
                                let v1177 = constructor_put_in_freg(ctx, v126.1);
                                let v1235 = constructor_pulley_fmaximum64(ctx, v1176, v1177);
                                let v1236 = constructor_output_freg(ctx, v1235);
                                let v1237 = Some(v1236);
                                // Rule at src/isa/pulley_shared/lower.isle line 1573.
                                return v1237;
                            }
                            F32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1238 = constructor_pulley_vmaximumf32x4(ctx, v192, v193);
                                let v1239 = constructor_output_vreg(ctx, v1238);
                                let v1240 = Some(v1239);
                                // Rule at src/isa/pulley_shared/lower.isle line 1574.
                                return v1240;
                            }
                            F64X2 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v1241 = constructor_pulley_vmaximumf64x2(ctx, v192, v193);
                                let v1242 = constructor_output_vreg(ctx, v1241);
                                let v1243 = Some(v1242);
                                // Rule at src/isa/pulley_shared/lower.isle line 1575.
                                return v1243;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Snarrow => {
                    let v126 = C::unpack_value_array_2(ctx, v125);
                    let v1482 = C::value_type(ctx, v126.0);
                    match v1482 {
                        I16X8 => {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v1483 = constructor_pulley_vnarrow16x8_s(ctx, v192, v193);
                            let v1484 = constructor_output_vreg(ctx, v1483);
                            let v1485 = Some(v1484);
                            // Rule at src/isa/pulley_shared/lower.isle line 1738.
                            return v1485;
                        }
                        I32X4 => {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v1486 = constructor_pulley_vnarrow32x4_s(ctx, v192, v193);
                            let v1487 = constructor_output_vreg(ctx, v1486);
                            let v1488 = Some(v1487);
                            // Rule at src/isa/pulley_shared/lower.isle line 1739.
                            return v1488;
                        }
                        I64X2 => {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v1489 = constructor_pulley_vnarrow64x2_s(ctx, v192, v193);
                            let v1490 = constructor_output_vreg(ctx, v1489);
                            let v1491 = Some(v1490);
                            // Rule at src/isa/pulley_shared/lower.isle line 1740.
                            return v1491;
                        }
                        _ => {}
                    }
                }
                &Opcode::Unarrow => {
                    let v126 = C::unpack_value_array_2(ctx, v125);
                    let v1482 = C::value_type(ctx, v126.0);
                    match v1482 {
                        I16X8 => {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v1492 = constructor_pulley_vnarrow16x8_u(ctx, v192, v193);
                            let v1493 = constructor_output_vreg(ctx, v1492);
                            let v1494 = Some(v1493);
                            // Rule at src/isa/pulley_shared/lower.isle line 1744.
                            return v1494;
                        }
                        I32X4 => {
                            let v192 = constructor_put_in_vreg(ctx, v126.0);
                            let v193 = constructor_put_in_vreg(ctx, v126.1);
                            let v1495 = constructor_pulley_vnarrow32x4_u(ctx, v192, v193);
                            let v1496 = constructor_output_vreg(ctx, v1495);
                            let v1497 = Some(v1496);
                            // Rule at src/isa/pulley_shared/lower.isle line 1745.
                            return v1497;
                        }
                        _ => {}
                    }
                }
                &Opcode::Uunarrow => {
                    let v126 = C::unpack_value_array_2(ctx, v125);
                    let v1482 = C::value_type(ctx, v126.0);
                    if v1482 == I64X2 {
                        let v192 = constructor_put_in_vreg(ctx, v126.0);
                        let v193 = constructor_put_in_vreg(ctx, v126.1);
                        let v1498 = constructor_pulley_vunarrow64x2_u(ctx, v192, v193);
                        let v1499 = constructor_output_vreg(ctx, v1498);
                        let v1500 = Some(v1499);
                        // Rule at src/isa/pulley_shared/lower.isle line 1749.
                        return v1500;
                    }
                }
                &Opcode::IaddPairwise => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I16X8 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v249 = constructor_pulley_vaddpairwisei16x8_s(ctx, v192, v193);
                                let v250 = constructor_output_vreg(ctx, v249);
                                let v251 = Some(v250);
                                // Rule at src/isa/pulley_shared/lower.isle line 317.
                                return v251;
                            }
                            I32X4 => {
                                let v126 = C::unpack_value_array_2(ctx, v125);
                                let v192 = constructor_put_in_vreg(ctx, v126.0);
                                let v193 = constructor_put_in_vreg(ctx, v126.1);
                                let v252 = constructor_pulley_vaddpairwisei32x4_s(ctx, v192, v193);
                                let v253 = constructor_output_vreg(ctx, v252);
                                let v254 = Some(v253);
                                // Rule at src/isa/pulley_shared/lower.isle line 318.
                                return v254;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Iconcat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I128 {
                            let v126 = C::unpack_value_array_2(ctx, v125);
                            let v997 = C::put_in_reg(ctx, v126.0);
                            let v998 = C::put_in_reg(ctx, v126.1);
                            let v999 = C::value_regs(ctx, v997, v998);
                            let v1000 = C::output(ctx, v999);
                            let v1001 = Some(v1000);
                            // Rule at src/isa/pulley_shared/lower.isle line 1325.
                            return v1001;
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::BinaryImm8 {
            opcode: ref v1507,
            arg: v1508,
            imm: v1509,
        } => {
            if let &Opcode::Extractlane = v1507 {
                let v1510 = C::value_type(ctx, v1508);
                match v1510 {
                    I8X16 => {
                        let v1512 = constructor_put_in_vreg(ctx, v1508);
                        let v1511 = C::u8_from_uimm8(ctx, v1509);
                        let v1513 = constructor_pulley_xextractv8x16(ctx, v1512, v1511);
                        let v1514 = constructor_output_xreg(ctx, v1513);
                        let v1515 = Some(v1514);
                        // Rule at src/isa/pulley_shared/lower.isle line 1761.
                        return v1515;
                    }
                    I16X8 => {
                        let v1512 = constructor_put_in_vreg(ctx, v1508);
                        let v1511 = C::u8_from_uimm8(ctx, v1509);
                        let v1516 = constructor_pulley_xextractv16x8(ctx, v1512, v1511);
                        let v1517 = constructor_output_xreg(ctx, v1516);
                        let v1518 = Some(v1517);
                        // Rule at src/isa/pulley_shared/lower.isle line 1763.
                        return v1518;
                    }
                    I32X4 => {
                        let v1512 = constructor_put_in_vreg(ctx, v1508);
                        let v1511 = C::u8_from_uimm8(ctx, v1509);
                        let v1519 = constructor_pulley_xextractv32x4(ctx, v1512, v1511);
                        let v1520 = constructor_output_xreg(ctx, v1519);
                        let v1521 = Some(v1520);
                        // Rule at src/isa/pulley_shared/lower.isle line 1765.
                        return v1521;
                    }
                    I64X2 => {
                        let v1512 = constructor_put_in_vreg(ctx, v1508);
                        let v1511 = C::u8_from_uimm8(ctx, v1509);
                        let v1522 = constructor_pulley_xextractv64x2(ctx, v1512, v1511);
                        let v1523 = constructor_output_xreg(ctx, v1522);
                        let v1524 = Some(v1523);
                        // Rule at src/isa/pulley_shared/lower.isle line 1767.
                        return v1524;
                    }
                    F32X4 => {
                        let v1512 = constructor_put_in_vreg(ctx, v1508);
                        let v1511 = C::u8_from_uimm8(ctx, v1509);
                        let v1525 = constructor_pulley_fextractv32x4(ctx, v1512, v1511);
                        let v1526 = constructor_output_freg(ctx, v1525);
                        let v1527 = Some(v1526);
                        // Rule at src/isa/pulley_shared/lower.isle line 1769.
                        return v1527;
                    }
                    F64X2 => {
                        let v1512 = constructor_put_in_vreg(ctx, v1508);
                        let v1511 = C::u8_from_uimm8(ctx, v1509);
                        let v1528 = constructor_pulley_fextractv64x2(ctx, v1512, v1511);
                        let v1529 = constructor_output_freg(ctx, v1528);
                        let v1530 = Some(v1529);
                        // Rule at src/isa/pulley_shared/lower.isle line 1771.
                        return v1530;
                    }
                    _ => {}
                }
            }
        }
        &InstructionData::Call {
            opcode: ref v34,
            args: v35,
            func_ref: v36,
        } => {
            match v34 {
                &Opcode::Call => {
                    let v38 = C::func_ref_data(ctx, v36);
                    if let &RelocDistance::Near = &v38.2 {
                        let v42 = &C::gen_call_output(ctx, v38.0);
                        let v43 = C::abi_sig(ctx, v38.0);
                        let v37 = C::value_list_slice(ctx, v35);
                        let v44 = &C::put_in_regs_vec(ctx, v37);
                        let v45 = C::gen_call_args(ctx, v43, v44);
                        let v46 = C::gen_call_rets(ctx, v43, v42);
                        let v47 = C::try_call_none(ctx);
                        let v48 = C::gen_call_info(ctx, v43, v38.1, v45, v46, v47);
                        let v49 = &constructor_call_impl(ctx, v48);
                        let v50 = constructor_emit_side_effect(ctx, v49);
                        let v51 = C::output_vec(ctx, v42);
                        let v52 = Some(v51);
                        // Rule at src/isa/pulley_shared/lower.isle line 143.
                        return v52;
                    }
                    let v42 = &C::gen_call_output(ctx, v38.0);
                    let v43 = C::abi_sig(ctx, v38.0);
                    let v37 = C::value_list_slice(ctx, v35);
                    let v44 = &C::put_in_regs_vec(ctx, v37);
                    let v45 = C::gen_call_args(ctx, v43, v44);
                    let v46 = C::gen_call_rets(ctx, v43, v42);
                    let v47 = C::try_call_none(ctx);
                    let v53 = C::gen_call_host_info(ctx, v43, v38.1, v45, v46, v47);
                    let v54 = &constructor_indirect_call_host_impl(ctx, v53);
                    let v55 = constructor_emit_side_effect(ctx, v54);
                    let v51 = C::output_vec(ctx, v42);
                    let v52 = Some(v51);
                    // Rule at src/isa/pulley_shared/lower.isle line 153.
                    return v52;
                }
                &Opcode::ReturnCall => {
                    let v38 = C::func_ref_data(ctx, v36);
                    if let &RelocDistance::Near = &v38.2 {
                        let v76 = C::abi_sig(ctx, v38.0);
                        let v37 = C::value_list_slice(ctx, v35);
                        let v77 = &C::put_in_regs_vec(ctx, v37);
                        let v78 = C::gen_return_call_args(ctx, v76, v77);
                        let v79 = C::gen_return_call_info(ctx, v76, v38.1, v78);
                        let v80 = &constructor_return_call_impl(ctx, v79);
                        let v81 = constructor_side_effect(ctx, v80);
                        let v82 = Some(v81);
                        // Rule at src/isa/pulley_shared/lower.isle line 207.
                        return v82;
                    }
                    let v76 = C::abi_sig(ctx, v38.0);
                    let v37 = C::value_list_slice(ctx, v35);
                    let v77 = &C::put_in_regs_vec(ctx, v37);
                    let v78 = C::gen_return_call_args(ctx, v76, v77);
                    let v83 = C::box_external_name(ctx, v38.1);
                    let v85 = constructor_load_ext_name(ctx, v83, 0_i64, &v38.2);
                    let v86 = C::xreg_to_reg(ctx, v85);
                    let v87 = C::gen_return_call_ind_info(ctx, v76, v86, v78);
                    let v88 = &constructor_return_indirect_call_impl(ctx, v87);
                    let v89 = constructor_side_effect(ctx, v88);
                    let v90 = Some(v89);
                    // Rule at src/isa/pulley_shared/lower.isle line 214.
                    return v90;
                }
                _ => {}
            }
        }
        &InstructionData::CallIndirect {
            opcode: ref v56,
            args: v57,
            sig_ref: v58,
        } => {
            match v56 {
                &Opcode::CallIndirect => {
                    let v59 = C::value_list_slice(ctx, v57);
                    let v60 = C::value_slice_unwrap(ctx, v59);
                    if let Some(v61) = v60 {
                        let v64 = &C::gen_call_output(ctx, v58);
                        let v65 = C::abi_sig(ctx, v58);
                        let v66 = C::put_in_reg(ctx, v61.0);
                        let v67 = &C::put_in_regs_vec(ctx, v61.1);
                        let v68 = C::gen_call_args(ctx, v65, v67);
                        let v69 = C::gen_call_rets(ctx, v65, v64);
                        let v70 = C::try_call_none(ctx);
                        let v71 = C::gen_call_ind_info(ctx, v65, v66, v68, v69, v70);
                        let v72 = &constructor_indirect_call_impl(ctx, v71);
                        let v73 = constructor_emit_side_effect(ctx, v72);
                        let v74 = C::output_vec(ctx, v64);
                        let v75 = Some(v74);
                        // Rule at src/isa/pulley_shared/lower.isle line 163.
                        return v75;
                    }
                }
                &Opcode::ReturnCallIndirect => {
                    let v59 = C::value_list_slice(ctx, v57);
                    let v60 = C::value_slice_unwrap(ctx, v59);
                    if let Some(v61) = v60 {
                        let v91 = C::abi_sig(ctx, v58);
                        let v92 = C::put_in_reg(ctx, v61.0);
                        let v93 = &C::put_in_regs_vec(ctx, v61.1);
                        let v94 = C::gen_return_call_args(ctx, v91, v93);
                        let v95 = C::gen_return_call_ind_info(ctx, v91, v92, v94);
                        let v96 = &constructor_return_indirect_call_impl(ctx, v95);
                        let v97 = constructor_side_effect(ctx, v96);
                        let v98 = Some(v97);
                        // Rule at src/isa/pulley_shared/lower.isle line 222.
                        return v98;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::CondTrap {
            opcode: ref v7,
            arg: v8,
            code: ref v9,
        } => {
            match v7 {
                &Opcode::Trapz => {
                    let v10 = &constructor_lower_cond(ctx, v8);
                    let v11 = &C::cond_invert(ctx, v10);
                    let v12 = &constructor_pulley_trap_if(ctx, v11, v9);
                    let v13 = constructor_side_effect(ctx, v12);
                    let v14 = Some(v13);
                    // Rule at src/isa/pulley_shared/lower.isle line 115.
                    return v14;
                }
                &Opcode::Trapnz => {
                    let v10 = &constructor_lower_cond(ctx, v8);
                    let v15 = &constructor_pulley_trap_if(ctx, v10, v9);
                    let v16 = constructor_side_effect(ctx, v15);
                    let v17 = Some(v16);
                    // Rule at src/isa/pulley_shared/lower.isle line 118.
                    return v17;
                }
                _ => {}
            }
        }
        &InstructionData::ExceptionHandlerAddress {
            opcode: ref v1626,
            block: ref v1627,
            imm: v1628,
        } => {
            if let &Opcode::GetExceptionHandlerAddress = v1626 {
                let v1629 = C::u64_from_imm64(ctx, v1628);
                let v1630 = C::block_exn_successor_label(ctx, v1627, v1629);
                let v1631 = constructor_pulley_label_address(ctx, v1630);
                let v1632 = constructor_output_reg(ctx, v1631);
                let v1633 = Some(v1632);
                // Rule at src/isa/pulley_shared/lower.isle line 1835.
                return v1633;
            }
        }
        &InstructionData::FloatCompare {
            opcode: ref v801,
            args: ref v802,
            cond: ref v803,
        } => {
            if let &Opcode::Fcmp = v801 {
                let v804 = C::unpack_value_array_2(ctx, v802);
                let v807 = C::value_type(ctx, v804.1);
                let v813 = C::ty_vec128(ctx, v807);
                if let Some(v814) = v813 {
                    let v815 = constructor_lower_vfcmp(ctx, v814, v803, v804.0, v804.1);
                    let v816 = constructor_output_vreg(ctx, v815);
                    let v817 = Some(v816);
                    // Rule at src/isa/pulley_shared/lower.isle line 889.
                    return v817;
                }
                let v808 = C::ty_scalar_float(ctx, v807);
                if let Some(v809) = v808 {
                    let v810 = constructor_lower_fcmp(ctx, v809, v803, v804.0, v804.1);
                    let v811 = constructor_output_xreg(ctx, v810);
                    let v812 = Some(v811);
                    // Rule at src/isa/pulley_shared/lower.isle line 886.
                    return v812;
                }
            }
        }
        &InstructionData::FuncAddr {
            opcode: ref v1616,
            func_ref: v1617,
        } => {
            if let &Opcode::FuncAddr = v1616 {
                let v1618 = C::func_ref_data(ctx, v1617);
                let v1622 = C::box_external_name(ctx, v1618.1);
                let v1623 = constructor_load_ext_name(ctx, v1622, 0_i64, &v1618.2);
                let v1624 = constructor_output_xreg(ctx, v1623);
                let v1625 = Some(v1624);
                // Rule at src/isa/pulley_shared/lower.isle line 1829.
                return v1625;
            }
        }
        &InstructionData::IntAddTrap {
            opcode: ref v1014,
            args: ref v1015,
            code: ref v1016,
        } => {
            if let &Opcode::UaddOverflowTrap = v1014 {
                let v99 = C::first_result(ctx, arg0);
                if let Some(v100) = v99 {
                    let v101 = C::value_type(ctx, v100);
                    match v101 {
                        I32 => {
                            let v1017 = C::unpack_value_array_2(ctx, v1015);
                            let v1020 = constructor_put_in_xreg(ctx, v1017.0);
                            let v1021 = constructor_put_in_xreg(ctx, v1017.1);
                            let v1022 = constructor_pulley_xadd32_uoverflow_trap(ctx, v1020, v1021, v1016);
                            let v1023 = constructor_output_xreg(ctx, v1022);
                            let v1024 = Some(v1023);
                            // Rule at src/isa/pulley_shared/lower.isle line 1337.
                            return v1024;
                        }
                        I64 => {
                            let v1017 = C::unpack_value_array_2(ctx, v1015);
                            let v1020 = constructor_put_in_xreg(ctx, v1017.0);
                            let v1021 = constructor_put_in_xreg(ctx, v1017.1);
                            let v1025 = constructor_pulley_xadd64_uoverflow_trap(ctx, v1020, v1021, v1016);
                            let v1026 = constructor_output_xreg(ctx, v1025);
                            let v1027 = Some(v1026);
                            // Rule at src/isa/pulley_shared/lower.isle line 1340.
                            return v1027;
                        }
                        _ => {}
                    }
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref v783,
            args: ref v784,
            cond: ref v785,
        } => {
            if let &Opcode::Icmp = v783 {
                let v786 = C::unpack_value_array_2(ctx, v784);
                let v795 = C::value_type(ctx, v786.0);
                let v796 = C::ty_vec128(ctx, v795);
                if let Some(v797) = v796 {
                    let v798 = constructor_lower_vcmp(ctx, v797, v785, v786.0, v786.1);
                    let v799 = constructor_output_vreg(ctx, v798);
                    let v800 = Some(v799);
                    // Rule at src/isa/pulley_shared/lower.isle line 845.
                    return v800;
                }
                let v789 = C::value_type(ctx, v786.1);
                let v790 = C::ty_int(ctx, v789);
                if let Some(v791) = v790 {
                    let v792 = constructor_lower_icmp(ctx, v791, v785, v786.0, v786.1);
                    let v793 = constructor_output_xreg(ctx, v792);
                    let v794 = Some(v793);
                    // Rule at src/isa/pulley_shared/lower.isle line 736.
                    return v794;
                }
            }
        }
        &InstructionData::Load {
            opcode: ref v818,
            arg: v819,
            flags: v820,
            offset: v821,
        } => {
            match v818 {
                &Opcode::Load => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I128 {
                            let v831 = C::offset32_to_i32(ctx, v821);
                            let v833 = C::i32_checked_add(ctx, v831, 8_i32);
                            if let Some(v834) = v833 {
                                let v835 = &constructor_amode(ctx, v819, v821);
                                let v837 = constructor_pulley_xload(ctx, v835, I64, v820);
                                let v838 = C::i32_to_offset32(ctx, v834);
                                let v839 = &constructor_amode(ctx, v819, v838);
                                let v840 = constructor_pulley_xload(ctx, v839, I64, v820);
                                let v841 = C::xreg_to_reg(ctx, v837);
                                let v842 = C::xreg_to_reg(ctx, v840);
                                let v843 = C::value_regs(ctx, v841, v842);
                                let v844 = C::output(ctx, v843);
                                let v845 = Some(v844);
                                // Rule at src/isa/pulley_shared/lower.isle line 957.
                                return v845;
                            }
                        }
                        let v585 = C::ty_vec128(ctx, v101);
                        if let Some(v586) = v585 {
                            let v887 = constructor_gen_vload(ctx, v819, v821, v820, v586, &VExtKind::None);
                            let v888 = constructor_output_vreg(ctx, v887);
                            let v889 = Some(v888);
                            // Rule at src/isa/pulley_shared/lower.isle line 999.
                            return v889;
                        }
                        let v826 = C::ty_scalar_float(ctx, v101);
                        if let Some(v827) = v826 {
                            let v828 = constructor_gen_fload(ctx, v819, v821, v820, v827);
                            let v829 = constructor_output_freg(ctx, v828);
                            let v830 = Some(v829);
                            // Rule at src/isa/pulley_shared/lower.isle line 954.
                            return v830;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v122 = C::fits_in_64(ctx, v121);
                            if let Some(v123) = v122 {
                                let v823 = constructor_gen_xload(ctx, v819, v821, v820, v123, &ExtKind::None);
                                let v824 = constructor_output_xreg(ctx, v823);
                                let v825 = Some(v824);
                                // Rule at src/isa/pulley_shared/lower.isle line 951.
                                return v825;
                            }
                        }
                    }
                }
                &Opcode::Uload8 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v860 = constructor_gen_xload(ctx, v819, v821, v820, I8, &ExtKind::Zero64);
                            let v861 = constructor_output_xreg(ctx, v860);
                            let v862 = Some(v861);
                            // Rule at src/isa/pulley_shared/lower.isle line 972.
                            return v862;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v848 = constructor_gen_xload(ctx, v819, v821, v820, I8, &ExtKind::Zero32);
                                let v849 = constructor_output_xreg(ctx, v848);
                                let v850 = Some(v849);
                                // Rule at src/isa/pulley_shared/lower.isle line 963.
                                return v850;
                            }
                        }
                    }
                }
                &Opcode::Sload8 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v877 = constructor_gen_xload(ctx, v819, v821, v820, I8, &ExtKind::Sign64);
                            let v878 = constructor_output_xreg(ctx, v877);
                            let v879 = Some(v878);
                            // Rule at src/isa/pulley_shared/lower.isle line 990.
                            return v879;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v870 = constructor_gen_xload(ctx, v819, v821, v820, I8, &ExtKind::Sign32);
                                let v871 = constructor_output_xreg(ctx, v870);
                                let v872 = Some(v871);
                                // Rule at src/isa/pulley_shared/lower.isle line 981.
                                return v872;
                            }
                        }
                    }
                }
                &Opcode::Uload16 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v863 = constructor_gen_xload(ctx, v819, v821, v820, I16, &ExtKind::Zero64);
                            let v864 = constructor_output_xreg(ctx, v863);
                            let v865 = Some(v864);
                            // Rule at src/isa/pulley_shared/lower.isle line 975.
                            return v865;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v852 = constructor_gen_xload(ctx, v819, v821, v820, I16, &ExtKind::Zero32);
                                let v853 = constructor_output_xreg(ctx, v852);
                                let v854 = Some(v853);
                                // Rule at src/isa/pulley_shared/lower.isle line 966.
                                return v854;
                            }
                        }
                    }
                }
                &Opcode::Sload16 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v880 = constructor_gen_xload(ctx, v819, v821, v820, I16, &ExtKind::Sign64);
                            let v881 = constructor_output_xreg(ctx, v880);
                            let v882 = Some(v881);
                            // Rule at src/isa/pulley_shared/lower.isle line 993.
                            return v882;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v873 = constructor_gen_xload(ctx, v819, v821, v820, I16, &ExtKind::Sign32);
                                let v874 = constructor_output_xreg(ctx, v873);
                                let v875 = Some(v874);
                                // Rule at src/isa/pulley_shared/lower.isle line 984.
                                return v875;
                            }
                        }
                    }
                }
                &Opcode::Uload32 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v866 = constructor_gen_xload(ctx, v819, v821, v820, I32, &ExtKind::Zero64);
                            let v867 = constructor_output_xreg(ctx, v866);
                            let v868 = Some(v867);
                            // Rule at src/isa/pulley_shared/lower.isle line 978.
                            return v868;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v856 = constructor_gen_xload(ctx, v819, v821, v820, I32, &ExtKind::None);
                                let v857 = constructor_output_xreg(ctx, v856);
                                let v858 = Some(v857);
                                // Rule at src/isa/pulley_shared/lower.isle line 969.
                                return v858;
                            }
                        }
                    }
                }
                &Opcode::Sload32 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v883 = constructor_gen_xload(ctx, v819, v821, v820, I32, &ExtKind::Sign64);
                            let v884 = constructor_output_xreg(ctx, v883);
                            let v885 = Some(v884);
                            // Rule at src/isa/pulley_shared/lower.isle line 996.
                            return v885;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v856 = constructor_gen_xload(ctx, v819, v821, v820, I32, &ExtKind::None);
                                let v857 = constructor_output_xreg(ctx, v856);
                                let v858 = Some(v857);
                                // Rule at src/isa/pulley_shared/lower.isle line 987.
                                return v858;
                            }
                        }
                    }
                }
                &Opcode::Uload8x8 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v895 = constructor_gen_vload(ctx, v819, v821, v820, v101, &VExtKind::U8x8);
                        let v896 = constructor_output_vreg(ctx, v895);
                        let v897 = Some(v896);
                        // Rule at src/isa/pulley_shared/lower.isle line 1005.
                        return v897;
                    }
                }
                &Opcode::Sload8x8 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v891 = constructor_gen_vload(ctx, v819, v821, v820, v101, &VExtKind::S8x8);
                        let v892 = constructor_output_vreg(ctx, v891);
                        let v893 = Some(v892);
                        // Rule at src/isa/pulley_shared/lower.isle line 1002.
                        return v893;
                    }
                }
                &Opcode::Uload16x4 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v903 = constructor_gen_vload(ctx, v819, v821, v820, v101, &VExtKind::U16x4);
                        let v904 = constructor_output_vreg(ctx, v903);
                        let v905 = Some(v904);
                        // Rule at src/isa/pulley_shared/lower.isle line 1011.
                        return v905;
                    }
                }
                &Opcode::Sload16x4 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v899 = constructor_gen_vload(ctx, v819, v821, v820, v101, &VExtKind::S16x4);
                        let v900 = constructor_output_vreg(ctx, v899);
                        let v901 = Some(v900);
                        // Rule at src/isa/pulley_shared/lower.isle line 1008.
                        return v901;
                    }
                }
                &Opcode::Uload32x2 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v911 = constructor_gen_vload(ctx, v819, v821, v820, v101, &VExtKind::U32x2);
                        let v912 = constructor_output_vreg(ctx, v911);
                        let v913 = Some(v912);
                        // Rule at src/isa/pulley_shared/lower.isle line 1017.
                        return v913;
                    }
                }
                &Opcode::Sload32x2 => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v907 = constructor_gen_vload(ctx, v819, v821, v820, v101, &VExtKind::S32x2);
                        let v908 = constructor_output_vreg(ctx, v907);
                        let v909 = Some(v908);
                        // Rule at src/isa/pulley_shared/lower.isle line 1014.
                        return v909;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::LoadNoOffset {
            opcode: ref v1051,
            arg: v1052,
            flags: v1053,
        } => {
            if let &Opcode::Bitcast = v1051 {
                let v99 = C::first_result(ctx, arg0);
                if let Some(v100) = v99 {
                    let v101 = C::value_type(ctx, v100);
                    let v1054 = C::value_type(ctx, v1052);
                    if v101 == v1054 {
                        let v1071 = constructor_output_value(ctx, v1052);
                        let v1072 = Some(v1071);
                        // Rule at src/isa/pulley_shared/lower.isle line 1420.
                        return v1072;
                    }
                    let v585 = C::ty_vec128(ctx, v101);
                    if let Some(v586) = v585 {
                        let v1069 = C::ty_vec128(ctx, v1054);
                        if let Some(v1070) = v1069 {
                            let v1071 = constructor_output_value(ctx, v1052);
                            let v1072 = Some(v1071);
                            // Rule at src/isa/pulley_shared/lower.isle line 1417.
                            return v1072;
                        }
                    }
                    match v101 {
                        I32 => {
                            if v1054 == F32 {
                                let v1062 = constructor_put_in_freg(ctx, v1052);
                                let v1063 = constructor_pulley_bitcast_int_from_float_32(ctx, v1062);
                                let v1064 = constructor_output_xreg(ctx, v1063);
                                let v1065 = Some(v1064);
                                // Rule at src/isa/pulley_shared/lower.isle line 1411.
                                return v1065;
                            }
                        }
                        I64 => {
                            if v1054 == F64 {
                                let v1062 = constructor_put_in_freg(ctx, v1052);
                                let v1066 = constructor_pulley_bitcast_int_from_float_64(ctx, v1062);
                                let v1067 = constructor_output_xreg(ctx, v1066);
                                let v1068 = Some(v1067);
                                // Rule at src/isa/pulley_shared/lower.isle line 1414.
                                return v1068;
                            }
                        }
                        F32 => {
                            if v1054 == I32 {
                                let v1055 = constructor_put_in_xreg(ctx, v1052);
                                let v1056 = constructor_pulley_bitcast_float_from_int_32(ctx, v1055);
                                let v1057 = constructor_output_freg(ctx, v1056);
                                let v1058 = Some(v1057);
                                // Rule at src/isa/pulley_shared/lower.isle line 1405.
                                return v1058;
                            }
                        }
                        F64 => {
                            if v1054 == I64 {
                                let v1055 = constructor_put_in_xreg(ctx, v1052);
                                let v1059 = constructor_pulley_bitcast_float_from_int_64(ctx, v1055);
                                let v1060 = constructor_output_freg(ctx, v1059);
                                let v1061 = Some(v1060);
                                // Rule at src/isa/pulley_shared/lower.isle line 1408.
                                return v1061;
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
        &InstructionData::MultiAry {
            opcode: ref v29,
            args: v30,
        } => {
            if let &Opcode::Return = v29 {
                let v31 = C::value_list_slice(ctx, v30);
                let v32 = constructor_lower_return(ctx, v31);
                let v33 = Some(v32);
                // Rule at src/isa/pulley_shared/lower.isle line 137.
                return v33;
            }
        }
        &InstructionData::NullAry {
            opcode: ref v18,
        } => {
            match v18 {
                &Opcode::GetFramePointer => {
                    let v23 = constructor_pulley_xmov_fp(ctx);
                    let v24 = constructor_output_xreg(ctx, v23);
                    let v25 = Some(v24);
                    // Rule at src/isa/pulley_shared/lower.isle line 128.
                    return v25;
                }
                &Opcode::GetStackPointer => {
                    let v19 = C::sp_reg(ctx);
                    let v20 = constructor_pulley_get_special(ctx, v19);
                    let v21 = constructor_output_xreg(ctx, v20);
                    let v22 = Some(v21);
                    // Rule at src/isa/pulley_shared/lower.isle line 123.
                    return v22;
                }
                &Opcode::GetReturnAddress => {
                    let v26 = constructor_pulley_xmov_lr(ctx);
                    let v27 = constructor_output_xreg(ctx, v26);
                    let v28 = Some(v27);
                    // Rule at src/isa/pulley_shared/lower.isle line 132.
                    return v28;
                }
                &Opcode::SequencePoint => {
                    let v1634 = &constructor_pulley_sequence_point(ctx);
                    let v1635 = constructor_side_effect(ctx, v1634);
                    let v1636 = Some(v1635);
                    // Rule at src/isa/pulley_shared/lower.isle line 1841.
                    return v1636;
                }
                _ => {}
            }
        }
        &InstructionData::Shuffle {
            opcode: ref v1583,
            args: ref v1584,
            imm: v1585,
        } => {
            if let &Opcode::Shuffle = v1583 {
                let v99 = C::first_result(ctx, arg0);
                if let Some(v100) = v99 {
                    let v101 = C::value_type(ctx, v100);
                    if v101 == I8X16 {
                        let v1589 = C::u128_from_immediate(ctx, v1585);
                        if let Some(v1590) = v1589 {
                            let v1586 = C::unpack_value_array_2(ctx, v1584);
                            let v1591 = constructor_put_in_vreg(ctx, v1586.0);
                            let v1592 = constructor_put_in_vreg(ctx, v1586.1);
                            let v1593 = constructor_pulley_vshuffle(ctx, v1591, v1592, v1590);
                            let v1594 = constructor_output_vreg(ctx, v1593);
                            let v1595 = Some(v1594);
                            // Rule at src/isa/pulley_shared/lower.isle line 1810.
                            return v1595;
                        }
                    }
                }
            }
        }
        &InstructionData::StackLoad {
            opcode: ref v960,
            stack_slot: v961,
            offset: v962,
        } => {
            if let &Opcode::StackAddr = v960 {
                let v963 = constructor_lower_stack_addr(ctx, v961, v962);
                let v964 = constructor_output_xreg(ctx, v963);
                let v965 = Some(v964);
                // Rule at src/isa/pulley_shared/lower.isle line 1284.
                return v965;
            }
        }
        &InstructionData::Store {
            opcode: ref v914,
            args: ref v915,
            flags: v916,
            offset: v917,
        } => {
            match v914 {
                &Opcode::Store => {
                    let v918 = C::unpack_value_array_2(ctx, v915);
                    let v921 = C::value_type(ctx, v918.0);
                    if v921 == I128 {
                        let v948 = C::put_in_regs(ctx, v918.0);
                        let v949 = C::value_regs_get(ctx, v948, 0x0_usize);
                        let v950 = C::xreg_new(ctx, v949);
                        let v951 = C::value_regs_get(ctx, v948, 0x1_usize);
                        let v952 = C::xreg_new(ctx, v951);
                        let v953 = constructor_put_in_xreg(ctx, v918.1);
                        let v956 = Amode::RegOffset {
                            base: v953,
                            offset: 0_i32,
                        };
                        let v954 = Amode::RegOffset {
                            base: v953,
                            offset: 8_i32,
                        };
                        let v957 = &constructor_emit_store_i128(ctx, v916, v950, v952, &v956, &v954);
                        let v958 = constructor_side_effect(ctx, v957);
                        let v959 = Some(v958);
                        // Rule at src/isa/pulley_shared/lower.isle line 1217.
                        return v959;
                    }
                    let v943 = C::ty_vec128(ctx, v921);
                    if let Some(v944) = v943 {
                        let v945 = &constructor_gen_store(ctx, v918.0, v918.1, v917, v916, v944);
                        let v946 = constructor_side_effect(ctx, v945);
                        let v947 = Some(v946);
                        // Rule at src/isa/pulley_shared/lower.isle line 1212.
                        return v947;
                    }
                    let v929 = C::ty_scalar_float(ctx, v921);
                    if let Some(v930) = v929 {
                        let v931 = &constructor_gen_store(ctx, v918.0, v918.1, v917, v916, v930);
                        let v932 = constructor_side_effect(ctx, v931);
                        let v933 = Some(v932);
                        // Rule at src/isa/pulley_shared/lower.isle line 1200.
                        return v933;
                    }
                    let v922 = C::ty_int(ctx, v921);
                    if let Some(v923) = v922 {
                        let v924 = C::fits_in_64(ctx, v923);
                        if let Some(v925) = v924 {
                            let v926 = &constructor_gen_store(ctx, v918.0, v918.1, v917, v916, v925);
                            let v927 = constructor_side_effect(ctx, v926);
                            let v928 = Some(v927);
                            // Rule at src/isa/pulley_shared/lower.isle line 1197.
                            return v928;
                        }
                    }
                }
                &Opcode::Istore8 => {
                    let v918 = C::unpack_value_array_2(ctx, v915);
                    let v934 = &constructor_gen_store(ctx, v918.0, v918.1, v917, v916, I8);
                    let v935 = constructor_side_effect(ctx, v934);
                    let v936 = Some(v935);
                    // Rule at src/isa/pulley_shared/lower.isle line 1203.
                    return v936;
                }
                &Opcode::Istore16 => {
                    let v918 = C::unpack_value_array_2(ctx, v915);
                    let v937 = &constructor_gen_store(ctx, v918.0, v918.1, v917, v916, I16);
                    let v938 = constructor_side_effect(ctx, v937);
                    let v939 = Some(v938);
                    // Rule at src/isa/pulley_shared/lower.isle line 1206.
                    return v939;
                }
                &Opcode::Istore32 => {
                    let v918 = C::unpack_value_array_2(ctx, v915);
                    let v940 = &constructor_gen_store(ctx, v918.0, v918.1, v917, v916, I32);
                    let v941 = constructor_side_effect(ctx, v940);
                    let v942 = Some(v941);
                    // Rule at src/isa/pulley_shared/lower.isle line 1209.
                    return v942;
                }
                _ => {}
            }
        }
        &InstructionData::Ternary {
            opcode: ref v645,
            args: ref v646,
        } => {
            match v645 {
                &Opcode::Select => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v585 = C::ty_vec128(ctx, v101);
                        if let Some(v586) = v585 {
                            let v647 = C::unpack_value_array_3(ctx, v646);
                            let v1028 = &constructor_lower_cond(ctx, v647.0);
                            let v1029 = constructor_emit_cond(ctx, v1028);
                            let v1046 = constructor_put_in_vreg(ctx, v647.1);
                            let v1047 = constructor_put_in_vreg(ctx, v647.2);
                            let v1048 = constructor_pulley_vselect(ctx, v1029, v1046, v1047);
                            let v1049 = constructor_output_vreg(ctx, v1048);
                            let v1050 = Some(v1049);
                            // Rule at src/isa/pulley_shared/lower.isle line 1357.
                            return v1050;
                        }
                        match v101 {
                            I64 => {
                                let v647 = C::unpack_value_array_3(ctx, v646);
                                let v1028 = &constructor_lower_cond(ctx, v647.0);
                                let v1029 = constructor_emit_cond(ctx, v1028);
                                let v1030 = constructor_put_in_xreg(ctx, v647.1);
                                let v1031 = constructor_put_in_xreg(ctx, v647.2);
                                let v1035 = constructor_pulley_xselect64(ctx, v1029, v1030, v1031);
                                let v1036 = constructor_output_xreg(ctx, v1035);
                                let v1037 = Some(v1036);
                                // Rule at src/isa/pulley_shared/lower.isle line 1348.
                                return v1037;
                            }
                            F32 => {
                                let v647 = C::unpack_value_array_3(ctx, v646);
                                let v1028 = &constructor_lower_cond(ctx, v647.0);
                                let v1029 = constructor_emit_cond(ctx, v1028);
                                let v1038 = constructor_put_in_freg(ctx, v647.1);
                                let v1039 = constructor_put_in_freg(ctx, v647.2);
                                let v1040 = constructor_pulley_fselect32(ctx, v1029, v1038, v1039);
                                let v1041 = constructor_output_freg(ctx, v1040);
                                let v1042 = Some(v1041);
                                // Rule at src/isa/pulley_shared/lower.isle line 1351.
                                return v1042;
                            }
                            F64 => {
                                let v647 = C::unpack_value_array_3(ctx, v646);
                                let v1028 = &constructor_lower_cond(ctx, v647.0);
                                let v1029 = constructor_emit_cond(ctx, v1028);
                                let v1038 = constructor_put_in_freg(ctx, v647.1);
                                let v1039 = constructor_put_in_freg(ctx, v647.2);
                                let v1043 = constructor_pulley_fselect64(ctx, v1029, v1038, v1039);
                                let v1044 = constructor_output_freg(ctx, v1043);
                                let v1045 = Some(v1044);
                                // Rule at src/isa/pulley_shared/lower.isle line 1354.
                                return v1045;
                            }
                            _ => {}
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v647 = C::unpack_value_array_3(ctx, v646);
                                let v1028 = &constructor_lower_cond(ctx, v647.0);
                                let v1029 = constructor_emit_cond(ctx, v1028);
                                let v1030 = constructor_put_in_xreg(ctx, v647.1);
                                let v1031 = constructor_put_in_xreg(ctx, v647.2);
                                let v1032 = constructor_pulley_xselect32(ctx, v1029, v1030, v1031);
                                let v1033 = constructor_output_xreg(ctx, v1032);
                                let v1034 = Some(v1033);
                                // Rule at src/isa/pulley_shared/lower.isle line 1345.
                                return v1034;
                            }
                        }
                    }
                }
                &Opcode::Bitselect => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v585 = C::ty_vec128(ctx, v101);
                        if let Some(v586) = v585 {
                            let v647 = C::unpack_value_array_3(ctx, v646);
                            let v651 = constructor_put_in_vreg(ctx, v647.0);
                            let v652 = constructor_put_in_vreg(ctx, v647.1);
                            let v653 = constructor_put_in_vreg(ctx, v647.2);
                            let v654 = constructor_pulley_vbitselect128(ctx, v651, v652, v653);
                            let v655 = constructor_output_vreg(ctx, v654);
                            let v656 = Some(v655);
                            // Rule at src/isa/pulley_shared/lower.isle line 652.
                            return v656;
                        }
                    }
                }
                &Opcode::Fma => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32X4 => {
                                let v647 = C::unpack_value_array_3(ctx, v646);
                                let v651 = constructor_put_in_vreg(ctx, v647.0);
                                let v652 = constructor_put_in_vreg(ctx, v647.1);
                                let v653 = constructor_put_in_vreg(ctx, v647.2);
                                let v1599 = constructor_pulley_vfma32x4(ctx, v651, v652, v653);
                                let v1600 = constructor_output_vreg(ctx, v1599);
                                let v1601 = Some(v1600);
                                // Rule at src/isa/pulley_shared/lower.isle line 1819.
                                return v1601;
                            }
                            F64X2 => {
                                let v647 = C::unpack_value_array_3(ctx, v646);
                                let v651 = constructor_put_in_vreg(ctx, v647.0);
                                let v652 = constructor_put_in_vreg(ctx, v647.1);
                                let v653 = constructor_put_in_vreg(ctx, v647.2);
                                let v1602 = constructor_pulley_vfma64x2(ctx, v651, v652, v653);
                                let v1603 = constructor_output_vreg(ctx, v1602);
                                let v1604 = Some(v1603);
                                // Rule at src/isa/pulley_shared/lower.isle line 1820.
                                return v1604;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::TernaryImm8 {
            opcode: ref v1531,
            args: ref v1532,
            imm: v1533,
        } => {
            if let &Opcode::Insertlane = v1531 {
                let v1534 = C::unpack_value_array_2(ctx, v1532);
                let v1537 = C::value_type(ctx, v1534.0);
                match v1537 {
                    I8X16 => {
                        let v1539 = constructor_put_in_vreg(ctx, v1534.0);
                        let v1540 = constructor_put_in_xreg(ctx, v1534.1);
                        let v1538 = C::u8_from_uimm8(ctx, v1533);
                        let v1541 = constructor_pulley_vinsertx8(ctx, v1539, v1540, v1538);
                        let v1542 = constructor_output_vreg(ctx, v1541);
                        let v1543 = Some(v1542);
                        // Rule at src/isa/pulley_shared/lower.isle line 1776.
                        return v1543;
                    }
                    I16X8 => {
                        let v1539 = constructor_put_in_vreg(ctx, v1534.0);
                        let v1540 = constructor_put_in_xreg(ctx, v1534.1);
                        let v1538 = C::u8_from_uimm8(ctx, v1533);
                        let v1544 = constructor_pulley_vinsertx16(ctx, v1539, v1540, v1538);
                        let v1545 = constructor_output_vreg(ctx, v1544);
                        let v1546 = Some(v1545);
                        // Rule at src/isa/pulley_shared/lower.isle line 1778.
                        return v1546;
                    }
                    I32X4 => {
                        let v1539 = constructor_put_in_vreg(ctx, v1534.0);
                        let v1540 = constructor_put_in_xreg(ctx, v1534.1);
                        let v1538 = C::u8_from_uimm8(ctx, v1533);
                        let v1547 = constructor_pulley_vinsertx32(ctx, v1539, v1540, v1538);
                        let v1548 = constructor_output_vreg(ctx, v1547);
                        let v1549 = Some(v1548);
                        // Rule at src/isa/pulley_shared/lower.isle line 1780.
                        return v1549;
                    }
                    I64X2 => {
                        let v1539 = constructor_put_in_vreg(ctx, v1534.0);
                        let v1540 = constructor_put_in_xreg(ctx, v1534.1);
                        let v1538 = C::u8_from_uimm8(ctx, v1533);
                        let v1550 = constructor_pulley_vinsertx64(ctx, v1539, v1540, v1538);
                        let v1551 = constructor_output_vreg(ctx, v1550);
                        let v1552 = Some(v1551);
                        // Rule at src/isa/pulley_shared/lower.isle line 1782.
                        return v1552;
                    }
                    F32X4 => {
                        let v1539 = constructor_put_in_vreg(ctx, v1534.0);
                        let v1553 = constructor_put_in_freg(ctx, v1534.1);
                        let v1538 = C::u8_from_uimm8(ctx, v1533);
                        let v1554 = constructor_pulley_vinsertf32(ctx, v1539, v1553, v1538);
                        let v1555 = constructor_output_vreg(ctx, v1554);
                        let v1556 = Some(v1555);
                        // Rule at src/isa/pulley_shared/lower.isle line 1784.
                        return v1556;
                    }
                    F64X2 => {
                        let v1539 = constructor_put_in_vreg(ctx, v1534.0);
                        let v1553 = constructor_put_in_freg(ctx, v1534.1);
                        let v1538 = C::u8_from_uimm8(ctx, v1533);
                        let v1557 = constructor_pulley_vinsertf64(ctx, v1539, v1553, v1538);
                        let v1558 = constructor_output_vreg(ctx, v1557);
                        let v1559 = Some(v1558);
                        // Rule at src/isa/pulley_shared/lower.isle line 1786.
                        return v1559;
                    }
                    _ => {}
                }
            }
        }
        &InstructionData::Trap {
            opcode: ref v2,
            code: ref v3,
        } => {
            if let &Opcode::Trap = v2 {
                let v4 = &constructor_pulley_trap(ctx, v3);
                let v5 = constructor_side_effect(ctx, v4);
                let v6 = Some(v5);
                // Rule at src/isa/pulley_shared/lower.isle line 110.
                return v6;
            }
        }
        &InstructionData::Unary {
            opcode: ref v632,
            arg: v633,
        } => {
            match v632 {
                &Opcode::Splat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8X16 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1392 = constructor_pulley_vsplatx8(ctx, v634);
                                let v1393 = constructor_output_vreg(ctx, v1392);
                                let v1394 = Some(v1393);
                                // Rule at src/isa/pulley_shared/lower.isle line 1676.
                                return v1394;
                            }
                            I16X8 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1395 = constructor_pulley_vsplatx16(ctx, v634);
                                let v1396 = constructor_output_vreg(ctx, v1395);
                                let v1397 = Some(v1396);
                                // Rule at src/isa/pulley_shared/lower.isle line 1677.
                                return v1397;
                            }
                            I32X4 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1398 = constructor_pulley_vsplatx32(ctx, v634);
                                let v1399 = constructor_output_vreg(ctx, v1398);
                                let v1400 = Some(v1399);
                                // Rule at src/isa/pulley_shared/lower.isle line 1678.
                                return v1400;
                            }
                            I64X2 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1401 = constructor_pulley_vsplatx64(ctx, v634);
                                let v1402 = constructor_output_vreg(ctx, v1401);
                                let v1403 = Some(v1402);
                                // Rule at src/isa/pulley_shared/lower.isle line 1679.
                                return v1403;
                            }
                            F32X4 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1404 = constructor_pulley_vsplatf32(ctx, v1073);
                                let v1405 = constructor_output_vreg(ctx, v1404);
                                let v1406 = Some(v1405);
                                // Rule at src/isa/pulley_shared/lower.isle line 1680.
                                return v1406;
                            }
                            F64X2 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1407 = constructor_pulley_vsplatf64(ctx, v1073);
                                let v1408 = constructor_output_vreg(ctx, v1407);
                                let v1409 = Some(v1408);
                                // Rule at src/isa/pulley_shared/lower.isle line 1681.
                                return v1409;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::VanyTrue => {
                    let v717 = C::value_type(ctx, v633);
                    match v717 {
                        I8X16 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1434 = constructor_pulley_vanytrue8x16(ctx, v641);
                            let v1435 = constructor_output_xreg(ctx, v1434);
                            let v1436 = Some(v1435);
                            // Rule at src/isa/pulley_shared/lower.isle line 1705.
                            return v1436;
                        }
                        I16X8 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1437 = constructor_pulley_vanytrue16x8(ctx, v641);
                            let v1438 = constructor_output_xreg(ctx, v1437);
                            let v1439 = Some(v1438);
                            // Rule at src/isa/pulley_shared/lower.isle line 1706.
                            return v1439;
                        }
                        I32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1440 = constructor_pulley_vanytrue32x4(ctx, v641);
                            let v1441 = constructor_output_xreg(ctx, v1440);
                            let v1442 = Some(v1441);
                            // Rule at src/isa/pulley_shared/lower.isle line 1707.
                            return v1442;
                        }
                        I64X2 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1443 = constructor_pulley_vanytrue64x2(ctx, v641);
                            let v1444 = constructor_output_xreg(ctx, v1443);
                            let v1445 = Some(v1444);
                            // Rule at src/isa/pulley_shared/lower.isle line 1708.
                            return v1445;
                        }
                        F32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1440 = constructor_pulley_vanytrue32x4(ctx, v641);
                            let v1441 = constructor_output_xreg(ctx, v1440);
                            let v1442 = Some(v1441);
                            // Rule at src/isa/pulley_shared/lower.isle line 1709.
                            return v1442;
                        }
                        F64X2 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1443 = constructor_pulley_vanytrue64x2(ctx, v641);
                            let v1444 = constructor_output_xreg(ctx, v1443);
                            let v1445 = Some(v1444);
                            // Rule at src/isa/pulley_shared/lower.isle line 1710.
                            return v1445;
                        }
                        _ => {}
                    }
                }
                &Opcode::VallTrue => {
                    let v717 = C::value_type(ctx, v633);
                    match v717 {
                        I8X16 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1422 = constructor_pulley_valltrue8x16(ctx, v641);
                            let v1423 = constructor_output_xreg(ctx, v1422);
                            let v1424 = Some(v1423);
                            // Rule at src/isa/pulley_shared/lower.isle line 1696.
                            return v1424;
                        }
                        I16X8 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1425 = constructor_pulley_valltrue16x8(ctx, v641);
                            let v1426 = constructor_output_xreg(ctx, v1425);
                            let v1427 = Some(v1426);
                            // Rule at src/isa/pulley_shared/lower.isle line 1697.
                            return v1427;
                        }
                        I32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1428 = constructor_pulley_valltrue32x4(ctx, v641);
                            let v1429 = constructor_output_xreg(ctx, v1428);
                            let v1430 = Some(v1429);
                            // Rule at src/isa/pulley_shared/lower.isle line 1698.
                            return v1430;
                        }
                        I64X2 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1431 = constructor_pulley_valltrue64x2(ctx, v641);
                            let v1432 = constructor_output_xreg(ctx, v1431);
                            let v1433 = Some(v1432);
                            // Rule at src/isa/pulley_shared/lower.isle line 1699.
                            return v1433;
                        }
                        F32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1428 = constructor_pulley_valltrue32x4(ctx, v641);
                            let v1429 = constructor_output_xreg(ctx, v1428);
                            let v1430 = Some(v1429);
                            // Rule at src/isa/pulley_shared/lower.isle line 1700.
                            return v1430;
                        }
                        F64X2 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1431 = constructor_pulley_valltrue64x2(ctx, v641);
                            let v1432 = constructor_output_xreg(ctx, v1431);
                            let v1433 = Some(v1432);
                            // Rule at src/isa/pulley_shared/lower.isle line 1701.
                            return v1433;
                        }
                        _ => {}
                    }
                }
                &Opcode::VhighBits => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v717 = C::value_type(ctx, v633);
                            match v717 {
                                I8X16 => {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1410 = constructor_pulley_vbitmask8x16(ctx, v641);
                                    let v1411 = constructor_output_xreg(ctx, v1410);
                                    let v1412 = Some(v1411);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1685.
                                    return v1412;
                                }
                                I16X8 => {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1413 = constructor_pulley_vbitmask16x8(ctx, v641);
                                    let v1414 = constructor_output_xreg(ctx, v1413);
                                    let v1415 = Some(v1414);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1687.
                                    return v1415;
                                }
                                I32X4 => {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1416 = constructor_pulley_vbitmask32x4(ctx, v641);
                                    let v1417 = constructor_output_xreg(ctx, v1416);
                                    let v1418 = Some(v1417);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1689.
                                    return v1418;
                                }
                                I64X2 => {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1419 = constructor_pulley_vbitmask64x2(ctx, v641);
                                    let v1420 = constructor_output_xreg(ctx, v1419);
                                    let v1421 = Some(v1420);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1691.
                                    return v1421;
                                }
                                _ => {}
                            }
                        }
                    }
                }
                &Opcode::Ineg => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1331 = constructor_pulley_xneg64(ctx, v634);
                                let v1332 = constructor_output_xreg(ctx, v1331);
                                let v1333 = Some(v1332);
                                // Rule at src/isa/pulley_shared/lower.isle line 1637.
                                return v1333;
                            }
                            I8X16 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1334 = constructor_pulley_vneg8x16(ctx, v641);
                                let v1335 = constructor_output_vreg(ctx, v1334);
                                let v1336 = Some(v1335);
                                // Rule at src/isa/pulley_shared/lower.isle line 1641.
                                return v1336;
                            }
                            I16X8 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1337 = constructor_pulley_vneg16x8(ctx, v641);
                                let v1338 = constructor_output_vreg(ctx, v1337);
                                let v1339 = Some(v1338);
                                // Rule at src/isa/pulley_shared/lower.isle line 1642.
                                return v1339;
                            }
                            I32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1340 = constructor_pulley_vneg32x4(ctx, v641);
                                let v1341 = constructor_output_vreg(ctx, v1340);
                                let v1342 = Some(v1341);
                                // Rule at src/isa/pulley_shared/lower.isle line 1643.
                                return v1342;
                            }
                            I64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1343 = constructor_pulley_vneg64x2(ctx, v641);
                                let v1344 = constructor_output_vreg(ctx, v1343);
                                let v1345 = Some(v1344);
                                // Rule at src/isa/pulley_shared/lower.isle line 1644.
                                return v1345;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v976 = constructor_sext32(ctx, v633);
                            let v1328 = constructor_pulley_xneg32(ctx, v976);
                            let v1329 = constructor_output_xreg(ctx, v1328);
                            let v1330 = Some(v1329);
                            // Rule at src/isa/pulley_shared/lower.isle line 1636.
                            return v1330;
                        }
                    }
                }
                &Opcode::Iabs => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1377 = constructor_pulley_xabs64(ctx, v634);
                                let v1378 = constructor_output_xreg(ctx, v1377);
                                let v1379 = Some(v1378);
                                // Rule at src/isa/pulley_shared/lower.isle line 1668.
                                return v1379;
                            }
                            I8X16 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1380 = constructor_pulley_vabs8x16(ctx, v641);
                                let v1381 = constructor_output_vreg(ctx, v1380);
                                let v1382 = Some(v1381);
                                // Rule at src/isa/pulley_shared/lower.isle line 1669.
                                return v1382;
                            }
                            I16X8 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1383 = constructor_pulley_vabs16x8(ctx, v641);
                                let v1384 = constructor_output_vreg(ctx, v1383);
                                let v1385 = Some(v1384);
                                // Rule at src/isa/pulley_shared/lower.isle line 1670.
                                return v1385;
                            }
                            I32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1386 = constructor_pulley_vabs32x4(ctx, v641);
                                let v1387 = constructor_output_vreg(ctx, v1386);
                                let v1388 = Some(v1387);
                                // Rule at src/isa/pulley_shared/lower.isle line 1671.
                                return v1388;
                            }
                            I64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1389 = constructor_pulley_vabs64x2(ctx, v641);
                                let v1390 = constructor_output_vreg(ctx, v1389);
                                let v1391 = Some(v1390);
                                // Rule at src/isa/pulley_shared/lower.isle line 1672.
                                return v1391;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v976 = constructor_sext32(ctx, v633);
                            let v1374 = constructor_pulley_xabs32(ctx, v976);
                            let v1375 = constructor_output_xreg(ctx, v1374);
                            let v1376 = Some(v1375);
                            // Rule at src/isa/pulley_shared/lower.isle line 1667.
                            return v1376;
                        }
                    }
                }
                &Opcode::Bnot => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v585 = C::ty_vec128(ctx, v101);
                        if let Some(v586) = v585 {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v642 = constructor_pulley_vbnot128(ctx, v641);
                            let v643 = constructor_output_vreg(ctx, v642);
                            let v644 = Some(v643);
                            // Rule at src/isa/pulley_shared/lower.isle line 647.
                            return v644;
                        }
                        if v101 == I64 {
                            let v634 = constructor_put_in_xreg(ctx, v633);
                            let v638 = constructor_pulley_xbnot64(ctx, v634);
                            let v639 = constructor_output_xreg(ctx, v638);
                            let v640 = Some(v639);
                            // Rule at src/isa/pulley_shared/lower.isle line 644.
                            return v640;
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v634 = constructor_put_in_xreg(ctx, v633);
                            let v635 = constructor_pulley_xbnot32(ctx, v634);
                            let v636 = constructor_output_xreg(ctx, v635);
                            let v637 = Some(v636);
                            // Rule at src/isa/pulley_shared/lower.isle line 641.
                            return v637;
                        }
                    }
                }
                &Opcode::Clz => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8 => {
                                let v720 = constructor_zext32(ctx, v633);
                                let v747 = constructor_pulley_xclz32(ctx, v720);
                                let v749 = constructor_pulley_xsub32_u8(ctx, v747, 0x18_u8);
                                let v750 = constructor_output_xreg(ctx, v749);
                                let v751 = Some(v750);
                                // Rule at src/isa/pulley_shared/lower.isle line 711.
                                return v751;
                            }
                            I16 => {
                                let v720 = constructor_zext32(ctx, v633);
                                let v747 = constructor_pulley_xclz32(ctx, v720);
                                let v753 = constructor_pulley_xsub32_u8(ctx, v747, 0x10_u8);
                                let v754 = constructor_output_xreg(ctx, v753);
                                let v755 = Some(v754);
                                // Rule at src/isa/pulley_shared/lower.isle line 713.
                                return v755;
                            }
                            I32 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v756 = constructor_pulley_xclz32(ctx, v634);
                                let v757 = constructor_output_xreg(ctx, v756);
                                let v758 = Some(v757);
                                // Rule at src/isa/pulley_shared/lower.isle line 715.
                                return v758;
                            }
                            I64 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v759 = constructor_pulley_xclz64(ctx, v634);
                                let v760 = constructor_output_xreg(ctx, v759);
                                let v761 = Some(v760);
                                // Rule at src/isa/pulley_shared/lower.isle line 716.
                                return v761;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ctz => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I8 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v732 = constructor_pulley_xbor32_s32(ctx, v634, 256_i32);
                                let v733 = constructor_pulley_xctz32(ctx, v732);
                                let v734 = constructor_output_xreg(ctx, v733);
                                let v735 = Some(v734);
                                // Rule at src/isa/pulley_shared/lower.isle line 702.
                                return v735;
                            }
                            I16 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v737 = constructor_pulley_xbor32_s32(ctx, v634, 65536_i32);
                                let v738 = constructor_pulley_xctz32(ctx, v737);
                                let v739 = constructor_output_xreg(ctx, v738);
                                let v740 = Some(v739);
                                // Rule at src/isa/pulley_shared/lower.isle line 704.
                                return v740;
                            }
                            I32 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v741 = constructor_pulley_xctz32(ctx, v634);
                                let v742 = constructor_output_xreg(ctx, v741);
                                let v743 = Some(v742);
                                // Rule at src/isa/pulley_shared/lower.isle line 706.
                                return v743;
                            }
                            I64 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v744 = constructor_pulley_xctz64(ctx, v634);
                                let v745 = constructor_output_xreg(ctx, v744);
                                let v746 = Some(v745);
                                // Rule at src/isa/pulley_shared/lower.isle line 707.
                                return v746;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Bswap => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I16 => {
                                let v397 = C::u64_try_into_u8(ctx, 0x10_u64);
                                if let Some(v398) = v397 {
                                    let v399 = C::u6_from_u8(ctx, v398);
                                    if let Some(v400) = v399 {
                                        let v634 = constructor_put_in_xreg(ctx, v633);
                                        let v1365 = constructor_pulley_bswap32(ctx, v634);
                                        let v1366 = constructor_pulley_xshr32_u_u6(ctx, v1365, v400);
                                        let v1367 = constructor_output_xreg(ctx, v1366);
                                        let v1368 = Some(v1367);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1659.
                                        return v1368;
                                    }
                                }
                            }
                            I32 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1365 = constructor_pulley_bswap32(ctx, v634);
                                let v1369 = constructor_output_xreg(ctx, v1365);
                                let v1370 = Some(v1369);
                                // Rule at src/isa/pulley_shared/lower.isle line 1662.
                                return v1370;
                            }
                            I64 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v1371 = constructor_pulley_bswap64(ctx, v634);
                                let v1372 = constructor_output_xreg(ctx, v1371);
                                let v1373 = Some(v1372);
                                // Rule at src/isa/pulley_shared/lower.isle line 1663.
                                return v1373;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Popcnt => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v634 = constructor_put_in_xreg(ctx, v633);
                                let v765 = constructor_pulley_xpopcnt64(ctx, v634);
                                let v766 = constructor_output_xreg(ctx, v765);
                                let v767 = Some(v766);
                                // Rule at src/isa/pulley_shared/lower.isle line 721.
                                return v767;
                            }
                            I8X16 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v768 = constructor_pulley_vpopcnt8x16(ctx, v641);
                                let v769 = constructor_output_vreg(ctx, v768);
                                let v770 = Some(v769);
                                // Rule at src/isa/pulley_shared/lower.isle line 722.
                                return v770;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v720 = constructor_zext32(ctx, v633);
                            let v762 = constructor_pulley_xpopcnt32(ctx, v720);
                            let v763 = constructor_output_xreg(ctx, v762);
                            let v764 = Some(v763);
                            // Rule at src/isa/pulley_shared/lower.isle line 720.
                            return v764;
                        }
                    }
                }
                &Opcode::Sqrt => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1304 = constructor_pulley_fsqrt32(ctx, v1073);
                                let v1305 = constructor_output_freg(ctx, v1304);
                                let v1306 = Some(v1305);
                                // Rule at src/isa/pulley_shared/lower.isle line 1620.
                                return v1306;
                            }
                            F64 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1307 = constructor_pulley_fsqrt64(ctx, v1073);
                                let v1308 = constructor_output_freg(ctx, v1307);
                                let v1309 = Some(v1308);
                                // Rule at src/isa/pulley_shared/lower.isle line 1621.
                                return v1309;
                            }
                            F32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1310 = constructor_pulley_vsqrt32x4(ctx, v641);
                                let v1311 = constructor_output_vreg(ctx, v1310);
                                let v1312 = Some(v1311);
                                // Rule at src/isa/pulley_shared/lower.isle line 1622.
                                return v1312;
                            }
                            F64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1313 = constructor_pulley_vsqrt64x2(ctx, v641);
                                let v1314 = constructor_output_vreg(ctx, v1313);
                                let v1315 = Some(v1314);
                                // Rule at src/isa/pulley_shared/lower.isle line 1624.
                                return v1315;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fneg => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1316 = constructor_pulley_fneg32(ctx, v1073);
                                let v1317 = constructor_output_freg(ctx, v1316);
                                let v1318 = Some(v1317);
                                // Rule at src/isa/pulley_shared/lower.isle line 1629.
                                return v1318;
                            }
                            F64 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1319 = constructor_pulley_fneg64(ctx, v1073);
                                let v1320 = constructor_output_freg(ctx, v1319);
                                let v1321 = Some(v1320);
                                // Rule at src/isa/pulley_shared/lower.isle line 1630.
                                return v1321;
                            }
                            F32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1322 = constructor_pulley_vnegf32x4(ctx, v641);
                                let v1323 = constructor_output_vreg(ctx, v1322);
                                let v1324 = Some(v1323);
                                // Rule at src/isa/pulley_shared/lower.isle line 1631.
                                return v1324;
                            }
                            F64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1325 = constructor_pulley_vnegf64x2(ctx, v641);
                                let v1326 = constructor_output_vreg(ctx, v1325);
                                let v1327 = Some(v1326);
                                // Rule at src/isa/pulley_shared/lower.isle line 1632.
                                return v1327;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fabs => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1346 = constructor_pulley_fabs32(ctx, v1073);
                                let v1347 = constructor_output_freg(ctx, v1346);
                                let v1348 = Some(v1347);
                                // Rule at src/isa/pulley_shared/lower.isle line 1648.
                                return v1348;
                            }
                            F64 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1349 = constructor_pulley_fabs64(ctx, v1073);
                                let v1350 = constructor_output_freg(ctx, v1349);
                                let v1351 = Some(v1350);
                                // Rule at src/isa/pulley_shared/lower.isle line 1649.
                                return v1351;
                            }
                            F32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1352 = constructor_pulley_vabsf32x4(ctx, v641);
                                let v1353 = constructor_output_vreg(ctx, v1352);
                                let v1354 = Some(v1353);
                                // Rule at src/isa/pulley_shared/lower.isle line 1650.
                                return v1354;
                            }
                            F64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1355 = constructor_pulley_vabsf64x2(ctx, v641);
                                let v1356 = constructor_output_vreg(ctx, v1355);
                                let v1357 = Some(v1356);
                                // Rule at src/isa/pulley_shared/lower.isle line 1651.
                                return v1357;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ceil => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1280 = constructor_pulley_fceil32(ctx, v1073);
                                let v1281 = constructor_output_freg(ctx, v1280);
                                let v1282 = Some(v1281);
                                // Rule at src/isa/pulley_shared/lower.isle line 1602.
                                return v1282;
                            }
                            F64 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1283 = constructor_pulley_fceil64(ctx, v1073);
                                let v1284 = constructor_output_freg(ctx, v1283);
                                let v1285 = Some(v1284);
                                // Rule at src/isa/pulley_shared/lower.isle line 1603.
                                return v1285;
                            }
                            F32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1289 = constructor_pulley_vceil32x4(ctx, v641);
                                let v1290 = constructor_output_vreg(ctx, v1289);
                                let v1291 = Some(v1290);
                                // Rule at src/isa/pulley_shared/lower.isle line 1606.
                                return v1291;
                            }
                            F64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1286 = constructor_pulley_vceil64x2(ctx, v641);
                                let v1287 = constructor_output_vreg(ctx, v1286);
                                let v1288 = Some(v1287);
                                // Rule at src/isa/pulley_shared/lower.isle line 1604.
                                return v1288;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Floor => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1268 = constructor_pulley_ffloor32(ctx, v1073);
                                let v1269 = constructor_output_freg(ctx, v1268);
                                let v1270 = Some(v1269);
                                // Rule at src/isa/pulley_shared/lower.isle line 1593.
                                return v1270;
                            }
                            F64 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1271 = constructor_pulley_ffloor64(ctx, v1073);
                                let v1272 = constructor_output_freg(ctx, v1271);
                                let v1273 = Some(v1272);
                                // Rule at src/isa/pulley_shared/lower.isle line 1594.
                                return v1273;
                            }
                            F32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1274 = constructor_pulley_vfloor32x4(ctx, v641);
                                let v1275 = constructor_output_vreg(ctx, v1274);
                                let v1276 = Some(v1275);
                                // Rule at src/isa/pulley_shared/lower.isle line 1595.
                                return v1276;
                            }
                            F64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1277 = constructor_pulley_vfloor64x2(ctx, v641);
                                let v1278 = constructor_output_vreg(ctx, v1277);
                                let v1279 = Some(v1278);
                                // Rule at src/isa/pulley_shared/lower.isle line 1597.
                                return v1279;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Trunc => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1256 = constructor_pulley_ftrunc32(ctx, v1073);
                                let v1257 = constructor_output_freg(ctx, v1256);
                                let v1258 = Some(v1257);
                                // Rule at src/isa/pulley_shared/lower.isle line 1586.
                                return v1258;
                            }
                            F64 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1259 = constructor_pulley_ftrunc64(ctx, v1073);
                                let v1260 = constructor_output_freg(ctx, v1259);
                                let v1261 = Some(v1260);
                                // Rule at src/isa/pulley_shared/lower.isle line 1587.
                                return v1261;
                            }
                            F32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1262 = constructor_pulley_vtrunc32x4(ctx, v641);
                                let v1263 = constructor_output_vreg(ctx, v1262);
                                let v1264 = Some(v1263);
                                // Rule at src/isa/pulley_shared/lower.isle line 1588.
                                return v1264;
                            }
                            F64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1265 = constructor_pulley_vtrunc64x2(ctx, v641);
                                let v1266 = constructor_output_vreg(ctx, v1265);
                                let v1267 = Some(v1266);
                                // Rule at src/isa/pulley_shared/lower.isle line 1589.
                                return v1267;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Nearest => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1292 = constructor_pulley_fnearest32(ctx, v1073);
                                let v1293 = constructor_output_freg(ctx, v1292);
                                let v1294 = Some(v1293);
                                // Rule at src/isa/pulley_shared/lower.isle line 1611.
                                return v1294;
                            }
                            F64 => {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1295 = constructor_pulley_fnearest64(ctx, v1073);
                                let v1296 = constructor_output_freg(ctx, v1295);
                                let v1297 = Some(v1296);
                                // Rule at src/isa/pulley_shared/lower.isle line 1612.
                                return v1297;
                            }
                            F32X4 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1298 = constructor_pulley_vnearest32x4(ctx, v641);
                                let v1299 = constructor_output_vreg(ctx, v1298);
                                let v1300 = Some(v1299);
                                // Rule at src/isa/pulley_shared/lower.isle line 1613.
                                return v1300;
                            }
                            F64X2 => {
                                let v641 = constructor_put_in_vreg(ctx, v633);
                                let v1301 = constructor_pulley_vnearest64x2(ctx, v641);
                                let v1302 = constructor_output_vreg(ctx, v1301);
                                let v1303 = Some(v1302);
                                // Rule at src/isa/pulley_shared/lower.isle line 1615.
                                return v1303;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::ScalarToVector => {
                    let v717 = C::value_type(ctx, v633);
                    match v717 {
                        I8 => {
                            let v1561 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1562 = constructor_put_in_xreg(ctx, v633);
                            let v1564 = constructor_pulley_vinsertx8(ctx, v1561, v1562, 0x0_u8);
                            let v1565 = constructor_output_vreg(ctx, v1564);
                            let v1566 = Some(v1565);
                            // Rule at src/isa/pulley_shared/lower.isle line 1795.
                            return v1566;
                        }
                        I16 => {
                            let v1561 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1562 = constructor_put_in_xreg(ctx, v633);
                            let v1567 = constructor_pulley_vinsertx16(ctx, v1561, v1562, 0x0_u8);
                            let v1568 = constructor_output_vreg(ctx, v1567);
                            let v1569 = Some(v1568);
                            // Rule at src/isa/pulley_shared/lower.isle line 1797.
                            return v1569;
                        }
                        I32 => {
                            let v1561 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1562 = constructor_put_in_xreg(ctx, v633);
                            let v1570 = constructor_pulley_vinsertx32(ctx, v1561, v1562, 0x0_u8);
                            let v1571 = constructor_output_vreg(ctx, v1570);
                            let v1572 = Some(v1571);
                            // Rule at src/isa/pulley_shared/lower.isle line 1799.
                            return v1572;
                        }
                        I64 => {
                            let v1561 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1562 = constructor_put_in_xreg(ctx, v633);
                            let v1573 = constructor_pulley_vinsertx64(ctx, v1561, v1562, 0x0_u8);
                            let v1574 = constructor_output_vreg(ctx, v1573);
                            let v1575 = Some(v1574);
                            // Rule at src/isa/pulley_shared/lower.isle line 1801.
                            return v1575;
                        }
                        F32 => {
                            let v1561 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1576 = constructor_put_in_freg(ctx, v633);
                            let v1577 = constructor_pulley_vinsertf32(ctx, v1561, v1576, 0x0_u8);
                            let v1578 = constructor_output_vreg(ctx, v1577);
                            let v1579 = Some(v1578);
                            // Rule at src/isa/pulley_shared/lower.isle line 1803.
                            return v1579;
                        }
                        F64 => {
                            let v1561 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1576 = constructor_put_in_freg(ctx, v633);
                            let v1580 = constructor_pulley_vinsertf64(ctx, v1561, v1576, 0x0_u8);
                            let v1581 = constructor_output_vreg(ctx, v1580);
                            let v1582 = Some(v1581);
                            // Rule at src/isa/pulley_shared/lower.isle line 1805.
                            return v1582;
                        }
                        _ => {}
                    }
                }
                &Opcode::Bmask => {
                    let v717 = C::value_type(ctx, v633);
                    if v717 == I64 {
                        let v634 = constructor_put_in_xreg(ctx, v633);
                        let v728 = constructor_pulley_xbmask64(ctx, v634);
                        let v729 = constructor_output_xreg(ctx, v728);
                        let v730 = Some(v729);
                        // Rule at src/isa/pulley_shared/lower.isle line 697.
                        return v730;
                    }
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == I64 {
                            let v724 = constructor_zext64(ctx, v633);
                            let v725 = constructor_pulley_xbmask64(ctx, v724);
                            let v726 = constructor_output_xreg(ctx, v725);
                            let v727 = Some(v726);
                            // Rule at src/isa/pulley_shared/lower.isle line 695.
                            return v727;
                        }
                        let v120 = C::ty_int(ctx, v101);
                        if let Some(v121) = v120 {
                            let v137 = C::fits_in_32(ctx, v121);
                            if let Some(v138) = v137 {
                                let v718 = C::fits_in_32(ctx, v717);
                                if let Some(v719) = v718 {
                                    let v720 = constructor_zext32(ctx, v633);
                                    let v721 = constructor_pulley_xbmask32(ctx, v720);
                                    let v722 = constructor_output_xreg(ctx, v721);
                                    let v723 = Some(v722);
                                    // Rule at src/isa/pulley_shared/lower.isle line 693.
                                    return v723;
                                }
                            }
                        }
                    }
                }
                &Opcode::Ireduce => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        let v993 = C::fits_in_64(ctx, v101);
                        if let Some(v994) = v993 {
                            let v995 = constructor_output_value(ctx, v633);
                            let v996 = Some(v995);
                            // Rule at src/isa/pulley_shared/lower.isle line 1320.
                            return v996;
                        }
                    }
                }
                &Opcode::SwidenLow => {
                    let v717 = C::value_type(ctx, v633);
                    match v717 {
                        I8X16 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1446 = constructor_pulley_vwidenlow8x16_s(ctx, v641);
                            let v1447 = constructor_output_vreg(ctx, v1446);
                            let v1448 = Some(v1447);
                            // Rule at src/isa/pulley_shared/lower.isle line 1714.
                            return v1448;
                        }
                        I16X8 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1449 = constructor_pulley_vwidenlow16x8_s(ctx, v641);
                            let v1450 = constructor_output_vreg(ctx, v1449);
                            let v1451 = Some(v1450);
                            // Rule at src/isa/pulley_shared/lower.isle line 1715.
                            return v1451;
                        }
                        I32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1452 = constructor_pulley_vwidenlow32x4_s(ctx, v641);
                            let v1453 = constructor_output_vreg(ctx, v1452);
                            let v1454 = Some(v1453);
                            // Rule at src/isa/pulley_shared/lower.isle line 1716.
                            return v1454;
                        }
                        _ => {}
                    }
                }
                &Opcode::SwidenHigh => {
                    let v717 = C::value_type(ctx, v633);
                    match v717 {
                        I8X16 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1455 = constructor_pulley_vwidenhigh8x16_s(ctx, v641);
                            let v1456 = constructor_output_vreg(ctx, v1455);
                            let v1457 = Some(v1456);
                            // Rule at src/isa/pulley_shared/lower.isle line 1720.
                            return v1457;
                        }
                        I16X8 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1458 = constructor_pulley_vwidenhigh16x8_s(ctx, v641);
                            let v1459 = constructor_output_vreg(ctx, v1458);
                            let v1460 = Some(v1459);
                            // Rule at src/isa/pulley_shared/lower.isle line 1721.
                            return v1460;
                        }
                        I32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1461 = constructor_pulley_vwidenhigh32x4_s(ctx, v641);
                            let v1462 = constructor_output_vreg(ctx, v1461);
                            let v1463 = Some(v1462);
                            // Rule at src/isa/pulley_shared/lower.isle line 1722.
                            return v1463;
                        }
                        _ => {}
                    }
                }
                &Opcode::UwidenLow => {
                    let v717 = C::value_type(ctx, v633);
                    match v717 {
                        I8X16 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1464 = constructor_pulley_vwidenlow8x16_u(ctx, v641);
                            let v1465 = constructor_output_vreg(ctx, v1464);
                            let v1466 = Some(v1465);
                            // Rule at src/isa/pulley_shared/lower.isle line 1726.
                            return v1466;
                        }
                        I16X8 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1467 = constructor_pulley_vwidenlow16x8_u(ctx, v641);
                            let v1468 = constructor_output_vreg(ctx, v1467);
                            let v1469 = Some(v1468);
                            // Rule at src/isa/pulley_shared/lower.isle line 1727.
                            return v1469;
                        }
                        I32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1470 = constructor_pulley_vwidenlow32x4_u(ctx, v641);
                            let v1471 = constructor_output_vreg(ctx, v1470);
                            let v1472 = Some(v1471);
                            // Rule at src/isa/pulley_shared/lower.isle line 1728.
                            return v1472;
                        }
                        _ => {}
                    }
                }
                &Opcode::UwidenHigh => {
                    let v717 = C::value_type(ctx, v633);
                    match v717 {
                        I8X16 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1473 = constructor_pulley_vwidenhigh8x16_u(ctx, v641);
                            let v1474 = constructor_output_vreg(ctx, v1473);
                            let v1475 = Some(v1474);
                            // Rule at src/isa/pulley_shared/lower.isle line 1732.
                            return v1475;
                        }
                        I16X8 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1476 = constructor_pulley_vwidenhigh16x8_u(ctx, v641);
                            let v1477 = constructor_output_vreg(ctx, v1476);
                            let v1478 = Some(v1477);
                            // Rule at src/isa/pulley_shared/lower.isle line 1733.
                            return v1478;
                        }
                        I32X4 => {
                            let v641 = constructor_put_in_vreg(ctx, v633);
                            let v1479 = constructor_pulley_vwidenhigh32x4_u(ctx, v641);
                            let v1480 = constructor_output_vreg(ctx, v1479);
                            let v1481 = Some(v1480);
                            // Rule at src/isa/pulley_shared/lower.isle line 1734.
                            return v1481;
                        }
                        _ => {}
                    }
                }
                &Opcode::Uextend => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v724 = constructor_zext64(ctx, v633);
                                let v968 = constructor_output_xreg(ctx, v724);
                                let v969 = Some(v968);
                                // Rule at src/isa/pulley_shared/lower.isle line 1298.
                                return v969;
                            }
                            I128 => {
                                let v724 = constructor_zext64(ctx, v633);
                                let v971 = constructor_pulley_xzero(ctx);
                                let v970 = C::xreg_to_reg(ctx, v724);
                                let v972 = C::xreg_to_reg(ctx, v971);
                                let v973 = C::value_regs(ctx, v970, v972);
                                let v974 = C::output(ctx, v973);
                                let v975 = Some(v974);
                                // Rule at src/isa/pulley_shared/lower.isle line 1301.
                                return v975;
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v720 = constructor_zext32(ctx, v633);
                            let v966 = constructor_output_xreg(ctx, v720);
                            let v967 = Some(v966);
                            // Rule at src/isa/pulley_shared/lower.isle line 1295.
                            return v967;
                        }
                    }
                }
                &Opcode::Sextend => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I64 => {
                                let v979 = constructor_sext64(ctx, v633);
                                let v980 = constructor_output_xreg(ctx, v979);
                                let v981 = Some(v980);
                                // Rule at src/isa/pulley_shared/lower.isle line 1309.
                                return v981;
                            }
                            I128 => {
                                let v983 = C::u64_try_into_u8(ctx, 0x3f_u64);
                                if let Some(v984) = v983 {
                                    let v985 = C::u6_from_u8(ctx, v984);
                                    if let Some(v986) = v985 {
                                        let v979 = constructor_sext64(ctx, v633);
                                        let v987 = constructor_pulley_xshr64_s_u6(ctx, v979, v986);
                                        let v988 = C::xreg_to_reg(ctx, v979);
                                        let v989 = C::xreg_to_reg(ctx, v987);
                                        let v990 = C::value_regs(ctx, v988, v989);
                                        let v991 = C::output(ctx, v990);
                                        let v992 = Some(v991);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1312.
                                        return v992;
                                    }
                                }
                            }
                            _ => {}
                        }
                        let v439 = C::fits_in_32(ctx, v101);
                        if let Some(v440) = v439 {
                            let v976 = constructor_sext32(ctx, v633);
                            let v977 = constructor_output_xreg(ctx, v976);
                            let v978 = Some(v977);
                            // Rule at src/isa/pulley_shared/lower.isle line 1306.
                            return v978;
                        }
                    }
                }
                &Opcode::Fpromote => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == F64 {
                            let v717 = C::value_type(ctx, v633);
                            if v717 == F32 {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1173 = constructor_pulley_f64_from_f32(ctx, v1073);
                                let v1174 = constructor_output_freg(ctx, v1173);
                                let v1175 = Some(v1174);
                                // Rule at src/isa/pulley_shared/lower.isle line 1531.
                                return v1175;
                            }
                        }
                    }
                }
                &Opcode::Fdemote => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        if v101 == F32 {
                            let v717 = C::value_type(ctx, v633);
                            if v717 == F64 {
                                let v1073 = constructor_put_in_freg(ctx, v633);
                                let v1170 = constructor_pulley_f32_from_f64(ctx, v1073);
                                let v1171 = constructor_output_freg(ctx, v1170);
                                let v1172 = Some(v1171);
                                // Rule at src/isa/pulley_shared/lower.isle line 1526.
                                return v1172;
                            }
                        }
                    }
                }
                &Opcode::Fvdemote => {
                    let v717 = C::value_type(ctx, v633);
                    if v717 == F64X2 {
                        let v641 = constructor_put_in_vreg(ctx, v633);
                        let v1504 = constructor_pulley_vfdemote(ctx, v641);
                        let v1505 = constructor_output_vreg(ctx, v1504);
                        let v1506 = Some(v1505);
                        // Rule at src/isa/pulley_shared/lower.isle line 1757.
                        return v1506;
                    }
                }
                &Opcode::FvpromoteLow => {
                    let v717 = C::value_type(ctx, v633);
                    if v717 == F32X4 {
                        let v641 = constructor_put_in_vreg(ctx, v633);
                        let v1501 = constructor_pulley_vfpromotelow(ctx, v641);
                        let v1502 = constructor_output_vreg(ctx, v1501);
                        let v1503 = Some(v1502);
                        // Rule at src/isa/pulley_shared/lower.isle line 1753.
                        return v1503;
                    }
                }
                &Opcode::FcvtToUint => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I32 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1074 = constructor_pulley_x32_from_f32_u(ctx, v1073);
                                        let v1075 = constructor_output_xreg(ctx, v1074);
                                        let v1076 = Some(v1075);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1424.
                                        return v1076;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1077 = constructor_pulley_x32_from_f64_u(ctx, v1073);
                                        let v1078 = constructor_output_xreg(ctx, v1077);
                                        let v1079 = Some(v1078);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1427.
                                        return v1079;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1080 = constructor_pulley_x64_from_f32_u(ctx, v1073);
                                        let v1081 = constructor_output_xreg(ctx, v1080);
                                        let v1082 = Some(v1081);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1430.
                                        return v1082;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1083 = constructor_pulley_x64_from_f64_u(ctx, v1073);
                                        let v1084 = constructor_output_xreg(ctx, v1083);
                                        let v1085 = Some(v1084);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1433.
                                        return v1085;
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtToSint => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I32 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1086 = constructor_pulley_x32_from_f32_s(ctx, v1073);
                                        let v1087 = constructor_output_xreg(ctx, v1086);
                                        let v1088 = Some(v1087);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1436.
                                        return v1088;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1089 = constructor_pulley_x32_from_f64_s(ctx, v1073);
                                        let v1090 = constructor_output_xreg(ctx, v1089);
                                        let v1091 = Some(v1090);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1439.
                                        return v1091;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1092 = constructor_pulley_x64_from_f32_s(ctx, v1073);
                                        let v1093 = constructor_output_xreg(ctx, v1092);
                                        let v1094 = Some(v1093);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1442.
                                        return v1094;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1095 = constructor_pulley_x64_from_f64_s(ctx, v1073);
                                        let v1096 = constructor_output_xreg(ctx, v1095);
                                        let v1097 = Some(v1096);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1445.
                                        return v1097;
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtToUintSat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I32 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1134 = constructor_pulley_x32_from_f32_u_sat(ctx, v1073);
                                        let v1135 = constructor_output_xreg(ctx, v1134);
                                        let v1136 = Some(v1135);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1488.
                                        return v1136;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1137 = constructor_pulley_x32_from_f64_u_sat(ctx, v1073);
                                        let v1138 = constructor_output_xreg(ctx, v1137);
                                        let v1139 = Some(v1138);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1491.
                                        return v1139;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1140 = constructor_pulley_x64_from_f32_u_sat(ctx, v1073);
                                        let v1141 = constructor_output_xreg(ctx, v1140);
                                        let v1142 = Some(v1141);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1494.
                                        return v1142;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1143 = constructor_pulley_x64_from_f64_u_sat(ctx, v1073);
                                        let v1144 = constructor_output_xreg(ctx, v1143);
                                        let v1145 = Some(v1144);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1497.
                                        return v1145;
                                    }
                                    _ => {}
                                }
                            }
                            I32X4 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == F32X4 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1161 = constructor_pulley_vi32x4_from_f32x4_u(ctx, v641);
                                    let v1162 = constructor_output_vreg(ctx, v1161);
                                    let v1163 = Some(v1162);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1515.
                                    return v1163;
                                }
                            }
                            I64X2 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == F64X2 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1167 = constructor_pulley_vi64x2_from_f64x2_u(ctx, v641);
                                    let v1168 = constructor_output_vreg(ctx, v1167);
                                    let v1169 = Some(v1168);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1521.
                                    return v1169;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtToSintSat => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            I32 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1146 = constructor_pulley_x32_from_f32_s_sat(ctx, v1073);
                                        let v1147 = constructor_output_xreg(ctx, v1146);
                                        let v1148 = Some(v1147);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1500.
                                        return v1148;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1149 = constructor_pulley_x32_from_f64_s_sat(ctx, v1073);
                                        let v1150 = constructor_output_xreg(ctx, v1149);
                                        let v1151 = Some(v1150);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1503.
                                        return v1151;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v717 = C::value_type(ctx, v633);
                                match v717 {
                                    F32 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1152 = constructor_pulley_x64_from_f32_s_sat(ctx, v1073);
                                        let v1153 = constructor_output_xreg(ctx, v1152);
                                        let v1154 = Some(v1153);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1506.
                                        return v1154;
                                    }
                                    F64 => {
                                        let v1073 = constructor_put_in_freg(ctx, v633);
                                        let v1155 = constructor_pulley_x64_from_f64_s_sat(ctx, v1073);
                                        let v1156 = constructor_output_xreg(ctx, v1155);
                                        let v1157 = Some(v1156);
                                        // Rule at src/isa/pulley_shared/lower.isle line 1509.
                                        return v1157;
                                    }
                                    _ => {}
                                }
                            }
                            I32X4 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == F32X4 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1158 = constructor_pulley_vi32x4_from_f32x4_s(ctx, v641);
                                    let v1159 = constructor_output_vreg(ctx, v1158);
                                    let v1160 = Some(v1159);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1512.
                                    return v1160;
                                }
                            }
                            I64X2 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == F64X2 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1164 = constructor_pulley_vi64x2_from_f64x2_s(ctx, v641);
                                    let v1165 = constructor_output_vreg(ctx, v1164);
                                    let v1166 = Some(v1165);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1518.
                                    return v1166;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtFromUint => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I64 {
                                    let v634 = constructor_put_in_xreg(ctx, v633);
                                    let v1101 = constructor_pulley_f32_from_x64_u(ctx, v634);
                                    let v1102 = constructor_output_freg(ctx, v1101);
                                    let v1103 = Some(v1102);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1453.
                                    return v1103;
                                }
                                let v718 = C::fits_in_32(ctx, v717);
                                if let Some(v719) = v718 {
                                    let v720 = constructor_zext32(ctx, v633);
                                    let v1098 = constructor_pulley_f32_from_x32_u(ctx, v720);
                                    let v1099 = constructor_output_freg(ctx, v1098);
                                    let v1100 = Some(v1099);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1450.
                                    return v1100;
                                }
                            }
                            F64 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I64 {
                                    let v634 = constructor_put_in_xreg(ctx, v633);
                                    let v1107 = constructor_pulley_f64_from_x64_u(ctx, v634);
                                    let v1108 = constructor_output_freg(ctx, v1107);
                                    let v1109 = Some(v1108);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1459.
                                    return v1109;
                                }
                                let v718 = C::fits_in_32(ctx, v717);
                                if let Some(v719) = v718 {
                                    let v720 = constructor_zext32(ctx, v633);
                                    let v1104 = constructor_pulley_f64_from_x32_u(ctx, v720);
                                    let v1105 = constructor_output_freg(ctx, v1104);
                                    let v1106 = Some(v1105);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1456.
                                    return v1106;
                                }
                            }
                            F32X4 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I32X4 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1125 = constructor_pulley_vf32x4_from_i32x4_u(ctx, v641);
                                    let v1126 = constructor_output_vreg(ctx, v1125);
                                    let v1127 = Some(v1126);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1477.
                                    return v1127;
                                }
                            }
                            F64X2 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I64X2 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1131 = constructor_pulley_vf64x2_from_i64x2_u(ctx, v641);
                                    let v1132 = constructor_output_vreg(ctx, v1131);
                                    let v1133 = Some(v1132);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1483.
                                    return v1133;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtFromSint => {
                    let v99 = C::first_result(ctx, arg0);
                    if let Some(v100) = v99 {
                        let v101 = C::value_type(ctx, v100);
                        match v101 {
                            F32 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I64 {
                                    let v634 = constructor_put_in_xreg(ctx, v633);
                                    let v1113 = constructor_pulley_f32_from_x64_s(ctx, v634);
                                    let v1114 = constructor_output_freg(ctx, v1113);
                                    let v1115 = Some(v1114);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1465.
                                    return v1115;
                                }
                                let v718 = C::fits_in_32(ctx, v717);
                                if let Some(v719) = v718 {
                                    let v976 = constructor_sext32(ctx, v633);
                                    let v1110 = constructor_pulley_f32_from_x32_s(ctx, v976);
                                    let v1111 = constructor_output_freg(ctx, v1110);
                                    let v1112 = Some(v1111);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1462.
                                    return v1112;
                                }
                            }
                            F64 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I64 {
                                    let v634 = constructor_put_in_xreg(ctx, v633);
                                    let v1119 = constructor_pulley_f64_from_x64_s(ctx, v634);
                                    let v1120 = constructor_output_freg(ctx, v1119);
                                    let v1121 = Some(v1120);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1471.
                                    return v1121;
                                }
                                let v718 = C::fits_in_32(ctx, v717);
                                if let Some(v719) = v718 {
                                    let v976 = constructor_sext32(ctx, v633);
                                    let v1116 = constructor_pulley_f64_from_x32_s(ctx, v976);
                                    let v1117 = constructor_output_freg(ctx, v1116);
                                    let v1118 = Some(v1117);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1468.
                                    return v1118;
                                }
                            }
                            F32X4 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I32X4 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1122 = constructor_pulley_vf32x4_from_i32x4_s(ctx, v641);
                                    let v1123 = constructor_output_vreg(ctx, v1122);
                                    let v1124 = Some(v1123);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1474.
                                    return v1124;
                                }
                            }
                            F64X2 => {
                                let v717 = C::value_type(ctx, v633);
                                if v717 == I64X2 {
                                    let v641 = constructor_put_in_vreg(ctx, v633);
                                    let v1128 = constructor_pulley_vf64x2_from_i64x2_s(ctx, v641);
                                    let v1129 = constructor_output_vreg(ctx, v1128);
                                    let v1130 = Some(v1129);
                                    // Rule at src/isa/pulley_shared/lower.isle line 1480.
                                    return v1130;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Isplit => {
                    let v717 = C::value_type(ctx, v633);
                    if v717 == I128 {
                        let v1002 = C::put_in_regs(ctx, v633);
                        let v1003 = C::value_regs_get(ctx, v1002, 0x0_usize);
                        let v1004 = C::xreg_new(ctx, v1003);
                        let v1005 = C::put_in_regs(ctx, v633);
                        let v1006 = C::value_regs_get(ctx, v1005, 0x1_usize);
                        let v1007 = C::xreg_new(ctx, v1006);
                        let v1008 = C::xreg_to_reg(ctx, v1004);
                        let v1009 = C::value_reg(ctx, v1008);
                        let v1010 = C::xreg_to_reg(ctx, v1007);
                        let v1011 = C::value_reg(ctx, v1010);
                        let v1012 = C::output_pair(ctx, v1009, v1011);
                        let v1013 = Some(v1012);
                        // Rule at src/isa/pulley_shared/lower.isle line 1330.
                        return v1013;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::UnaryConst {
            opcode: ref v1358,
            constant_handle: v1359,
        } => {
            if let &Opcode::Vconst = v1358 {
                let v99 = C::first_result(ctx, arg0);
                if let Some(v100) = v99 {
                    let v101 = C::value_type(ctx, v100);
                    let v585 = C::ty_vec128(ctx, v101);
                    if let Some(v586) = v585 {
                        let v1360 = C::u128_from_constant(ctx, v1359);
                        if let Some(v1361) = v1360 {
                            let v1362 = constructor_pulley_vconst128(ctx, v1361);
                            let v1363 = constructor_output_vreg(ctx, v1362);
                            let v1364 = Some(v1363);
                            // Rule at src/isa/pulley_shared/lower.isle line 1655.
                            return v1364;
                        }
                    }
                }
            }
        }
        &InstructionData::UnaryGlobalValue {
            opcode: ref v1605,
            global_value: v1606,
        } => {
            if let &Opcode::SymbolValue = v1605 {
                let v1607 = C::symbol_value_data(ctx, v1606);
                if let Some(v1608) = v1607 {
                    let v1612 = C::box_external_name(ctx, v1608.0);
                    let v1613 = constructor_load_ext_name(ctx, v1612, v1608.2, &v1608.1);
                    let v1614 = constructor_output_xreg(ctx, v1613);
                    let v1615 = Some(v1614);
                    // Rule at src/isa/pulley_shared/lower.isle line 1824.
                    return v1615;
                }
            }
        }
        &InstructionData::UnaryIeee32 {
            opcode: ref v108,
            imm: v109,
        } => {
            if let &Opcode::F32const = v108 {
                let v110 = C::u32_from_ieee32(ctx, v109);
                let v111 = constructor_pulley_fconst32(ctx, v110);
                let v112 = constructor_output_freg(ctx, v111);
                let v113 = Some(v112);
                // Rule at src/isa/pulley_shared/lower.isle line 235.
                return v113;
            }
        }
        &InstructionData::UnaryIeee64 {
            opcode: ref v114,
            imm: v115,
        } => {
            if let &Opcode::F64const = v114 {
                let v116 = C::u64_from_ieee64(ctx, v115);
                let v117 = constructor_pulley_fconst64(ctx, v116);
                let v118 = constructor_output_freg(ctx, v117);
                let v119 = Some(v118);
                // Rule at src/isa/pulley_shared/lower.isle line 239.
                return v119;
            }
        }
        &InstructionData::UnaryImm {
            opcode: ref v102,
            imm: v103,
        } => {
            if let &Opcode::Iconst = v102 {
                let v99 = C::first_result(ctx, arg0);
                if let Some(v100) = v99 {
                    let v101 = C::value_type(ctx, v100);
                    let v104 = C::i64_sextend_imm64(ctx, v101, v103);
                    let v105 = constructor_imm(ctx, v104);
                    let v106 = constructor_output_reg(ctx, v105);
                    let v107 = Some(v106);
                    // Rule at src/isa/pulley_shared/lower.isle line 231.
                    return v107;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term lower_cond.
pub fn constructor_lower_cond<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Cond {
    let v9 = C::def_inst(ctx, arg0);
    if let Some(v10) = v9 {
        let v11 = &C::inst_data_value(ctx, v10);
        match v11 {
            &InstructionData::IntCompare {
                opcode: ref v15,
                args: ref v16,
                cond: ref v17,
            } => {
                if let &Opcode::Icmp = v15 {
                    let v18 = C::unpack_value_array_2(ctx, v16);
                    let v21 = C::value_type(ctx, v18.1);
                    match v21 {
                        I32 => {
                            let v22 = &constructor_lower_cond_icmp32(ctx, v17, v18.0, v18.1);
                            // Rule at src/isa/pulley_shared/lower.isle line 21.
                            return v22.clone();
                        }
                        I64 => {
                            let v23 = &constructor_lower_cond_icmp64(ctx, v17, v18.0, v18.1);
                            // Rule at src/isa/pulley_shared/lower.isle line 22.
                            return v23.clone();
                        }
                        _ => {}
                    }
                }
            }
            &InstructionData::Unary {
                opcode: ref v12,
                arg: v13,
            } => {
                if let &Opcode::Uextend = v12 {
                    let v14 = &constructor_lower_cond(ctx, v13);
                    // Rule at src/isa/pulley_shared/lower.isle line 19.
                    return v14.clone();
                }
            }
            _ => {}
        }
    }
    let v1 = C::value_type(ctx, arg0);
    if v1 == I64 {
        let v6 = constructor_put_in_xreg(ctx, arg0);
        let v8 = Cond::IfXneq64I32 {
            src1: v6,
            src2: 0_i32,
        };
        // Rule at src/isa/pulley_shared/lower.isle line 15.
        return v8;
    }
    let v2 = C::fits_in_32(ctx, v1);
    if let Some(v3) = v2 {
        let v4 = constructor_zext32(ctx, arg0);
        let v5 = Cond::If32 {
            reg: v4,
        };
        // Rule at src/isa/pulley_shared/lower.isle line 14.
        return v5;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_cond", "src/isa/pulley_shared/lower.isle line 13")
}

// Generated as internal constructor for term lower_cond_icmp32.
pub fn constructor_lower_cond_icmp32<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Value,
    arg2: Value,
) -> Cond {
    match arg0 {
        &IntCC::Equal => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v21 = Cond::IfXeq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 37.
                    return v21;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v5 = Cond::IfXeq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 25.
            return v5;
        }
        &IntCC::NotEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v22 = Cond::IfXneq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 39.
                    return v22;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v6 = Cond::IfXneq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 26.
            return v6;
        }
        &IntCC::SignedGreaterThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v25 = Cond::IfXsgt32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 45.
                    return v25;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v13 = Cond::IfXslt32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 32.
            return v13;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v26 = Cond::IfXsgteq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 47.
                    return v26;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v14 = Cond::IfXslteq32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 33.
            return v14;
        }
        &IntCC::SignedLessThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v23 = Cond::IfXslt32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 41.
                    return v23;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v7 = Cond::IfXslt32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 27.
            return v7;
        }
        &IntCC::SignedLessThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v24 = Cond::IfXslteq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 43.
                    return v24;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v8 = Cond::IfXslteq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 28.
            return v8;
        }
        &IntCC::UnsignedGreaterThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v37 = Cond::IfXugt32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 53.
                            return v37;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v15 = Cond::IfXult32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 34.
            return v15;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v38 = Cond::IfXugteq32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 55.
                            return v38;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v16 = Cond::IfXulteq32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 35.
            return v16;
        }
        &IntCC::UnsignedLessThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v35 = Cond::IfXult32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 49.
                            return v35;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v9 = Cond::IfXult32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 29.
            return v9;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v36 = Cond::IfXulteq32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 51.
                            return v36;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v10 = Cond::IfXulteq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 30.
            return v10;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_cond_icmp32", "src/isa/pulley_shared/lower.isle line 24")
}

// Generated as internal constructor for term lower_cond_icmp64.
pub fn constructor_lower_cond_icmp64<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Value,
    arg2: Value,
) -> Cond {
    match arg0 {
        &IntCC::Equal => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v21 = Cond::IfXeq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 71.
                    return v21;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v5 = Cond::IfXeq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 59.
            return v5;
        }
        &IntCC::NotEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v22 = Cond::IfXneq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 73.
                    return v22;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v6 = Cond::IfXneq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 60.
            return v6;
        }
        &IntCC::SignedGreaterThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v25 = Cond::IfXsgt64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 79.
                    return v25;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v13 = Cond::IfXslt64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 66.
            return v13;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v26 = Cond::IfXsgteq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 81.
                    return v26;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v14 = Cond::IfXslteq64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 67.
            return v14;
        }
        &IntCC::SignedLessThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v23 = Cond::IfXslt64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 75.
                    return v23;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v7 = Cond::IfXslt64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 61.
            return v7;
        }
        &IntCC::SignedLessThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v24 = Cond::IfXslteq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src/isa/pulley_shared/lower.isle line 77.
                    return v24;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v8 = Cond::IfXslteq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 62.
            return v8;
        }
        &IntCC::UnsignedGreaterThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v37 = Cond::IfXugt64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 87.
                            return v37;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v15 = Cond::IfXult64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 68.
            return v15;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v38 = Cond::IfXugteq64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 89.
                            return v38;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v16 = Cond::IfXulteq64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 69.
            return v16;
        }
        &IntCC::UnsignedLessThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v35 = Cond::IfXult64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 83.
                            return v35;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v9 = Cond::IfXult64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 63.
            return v9;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v36 = Cond::IfXulteq64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src/isa/pulley_shared/lower.isle line 85.
                            return v36;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v10 = Cond::IfXulteq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src/isa/pulley_shared/lower.isle line 64.
            return v10;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_cond_icmp64", "src/isa/pulley_shared/lower.isle line 58")
}

// Generated as internal constructor for term lower_branch.
pub fn constructor_lower_branch<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: &MachLabelSlice,
) -> Option<Unit> {
    let v1 = &C::inst_data_value(ctx, arg0);
    match v1 {
        &InstructionData::BranchTable {
            opcode: ref v24,
            arg: v25,
            table: v26,
        } => {
            if let &Opcode::BrTable = v24 {
                let v27 = C::jump_table_targets(ctx, arg1);
                if let Some(v28) = v27 {
                    let v31 = constructor_put_in_xreg(ctx, v25);
                    let v32 = constructor_gen_br_table(ctx, v31, v28.0, &v28.1);
                    let v33 = Some(v32);
                    // Rule at src/isa/pulley_shared/lower.isle line 105.
                    return v33;
                }
            }
        }
        &InstructionData::Brif {
            opcode: ref v10,
            arg: v11,
            blocks: ref v12,
        } => {
            if let &Opcode::Brif = v10 {
                let v16 = C::two_targets(ctx, arg1);
                if let Some(v17) = v16 {
                    let v20 = &constructor_lower_cond(ctx, v11);
                    let v21 = &constructor_pulley_br_if(ctx, v20, v17.0, v17.1);
                    let v22 = constructor_emit_side_effect(ctx, v21);
                    let v23 = Some(v22);
                    // Rule at src/isa/pulley_shared/lower.isle line 101.
                    return v23;
                }
            }
        }
        &InstructionData::Jump {
            opcode: ref v2,
            destination: v3,
        } => {
            if let &Opcode::Jump = v2 {
                let v5 = C::single_target(ctx, arg1);
                if let Some(v6) = v5 {
                    let v7 = &constructor_pulley_jump(ctx, v6);
                    let v8 = constructor_emit_side_effect(ctx, v7);
                    let v9 = Some(v8);
                    // Rule at src/isa/pulley_shared/lower.isle line 97.
                    return v9;
                }
            }
        }
        &InstructionData::TryCall {
            opcode: ref v34,
            args: v35,
            func_ref: v36,
            exception: v37,
        } => {
            if let &Opcode::TryCall = v34 {
                let v39 = C::func_ref_data(ctx, v36);
                if let &RelocDistance::Near = &v39.2 {
                    let v43 = C::abi_sig(ctx, v39.0);
                    let v44 = C::try_call_info(ctx, v37, arg1);
                    let v38 = C::value_list_slice(ctx, v35);
                    let v45 = &C::put_in_regs_vec(ctx, v38);
                    let v46 = C::gen_call_args(ctx, v43, v45);
                    let v47 = C::gen_try_call_rets(ctx, v43);
                    let v48 = C::gen_call_info(ctx, v43, v39.1, v46, v47, v44);
                    let v49 = &constructor_call_impl(ctx, v48);
                    let v50 = constructor_emit_side_effect(ctx, v49);
                    let v51 = Some(v50);
                    // Rule at src/isa/pulley_shared/lower.isle line 176.
                    return v51;
                }
                let v43 = C::abi_sig(ctx, v39.0);
                let v44 = C::try_call_info(ctx, v37, arg1);
                let v38 = C::value_list_slice(ctx, v35);
                let v45 = &C::put_in_regs_vec(ctx, v38);
                let v46 = C::gen_call_args(ctx, v43, v45);
                let v47 = C::gen_try_call_rets(ctx, v43);
                let v52 = C::gen_call_host_info(ctx, v43, v39.1, v46, v47, v44);
                let v53 = &constructor_indirect_call_host_impl(ctx, v52);
                let v54 = constructor_emit_side_effect(ctx, v53);
                let v55 = Some(v54);
                // Rule at src/isa/pulley_shared/lower.isle line 185.
                return v55;
            }
        }
        &InstructionData::TryCallIndirect {
            opcode: ref v56,
            args: v57,
            exception: v58,
        } => {
            if let &Opcode::TryCallIndirect = v56 {
                let v59 = C::value_list_slice(ctx, v57);
                let v60 = C::value_slice_unwrap(ctx, v59);
                if let Some(v61) = v60 {
                    let v64 = C::exception_sig(ctx, v58);
                    let v65 = C::abi_sig(ctx, v64);
                    let v66 = C::try_call_info(ctx, v58, arg1);
                    let v67 = C::put_in_reg(ctx, v61.0);
                    let v68 = &C::put_in_regs_vec(ctx, v61.1);
                    let v69 = C::gen_call_args(ctx, v65, v68);
                    let v70 = C::gen_try_call_rets(ctx, v65);
                    let v71 = C::gen_call_ind_info(ctx, v65, v67, v69, v70, v66);
                    let v72 = &constructor_indirect_call_impl(ctx, v71);
                    let v73 = constructor_emit_side_effect(ctx, v72);
                    let v74 = Some(v73);
                    // Rule at src/isa/pulley_shared/lower.isle line 194.
                    return v74;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term u8_from_negated_iconst.
pub fn constructor_u8_from_negated_iconst<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<u8> {
    let v1 = C::i64_from_iconst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::i64_from_i32(ctx, v2);
        if let Some(v4) = v3 {
            let v5 = C::i32_into_i64(ctx, v4);
            let v6 = C::i64_checked_neg(ctx, v5);
            if let Some(v7) = v6 {
                let v8 = C::i64_try_into_u8(ctx, v7);
                if let Some(v9) = v8 {
                    let v10 = Some(v9);
                    // Rule at src/isa/pulley_shared/lower.isle line 274.
                    return v10;
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term u32_from_negated_iconst.
pub fn constructor_u32_from_negated_iconst<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<u32> {
    let v1 = C::i64_from_iconst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::i64_from_i32(ctx, v2);
        if let Some(v4) = v3 {
            let v5 = C::i32_into_i64(ctx, v4);
            let v6 = C::i64_checked_neg(ctx, v5);
            if let Some(v7) = v6 {
                let v8 = C::i64_try_into_u32(ctx, v7);
                if let Some(v9) = v8 {
                    let v10 = Some(v9);
                    // Rule at src/isa/pulley_shared/lower.isle line 282.
                    return v10;
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term u6_shift_from_iconst.
pub fn constructor_u6_shift_from_iconst<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<U6> {
    let v1 = C::def_inst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = &C::inst_data_value(ctx, v2);
        if let &InstructionData::UnaryImm {
            opcode: ref v4,
            imm: v5,
        } = v3 {
            if let &Opcode::Iconst = v4 {
                let v6 = C::u64_from_imm64(ctx, v5);
                let v8 = C::u64_and(ctx, v6, 0x3f_u64);
                let v9 = C::u64_try_into_u8(ctx, v8);
                if let Some(v10) = v9 {
                    let v11 = C::u6_from_u8(ctx, v10);
                    if let Some(v12) = v11 {
                        let v13 = Some(v12);
                        // Rule at src/isa/pulley_shared/lower.isle line 523.
                        return v13;
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term lower_icmp.
pub fn constructor_lower_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> XReg {
    if arg0 == I128 {
        let v58 = &C::intcc_unsigned(ctx, arg1);
        if let &IntCC::UnsignedLessThan = v58 {
            let v32 = C::put_in_regs(ctx, arg2);
            let v34 = C::value_regs_get(ctx, v32, 0x0_usize);
            let v35 = C::xreg_new(ctx, v34);
            let v59 = C::put_in_regs(ctx, arg2);
            let v60 = C::value_regs_get(ctx, v59, 0x1_usize);
            let v61 = C::xreg_new(ctx, v60);
            let v62 = C::put_in_regs(ctx, arg3);
            let v63 = C::value_regs_get(ctx, v62, 0x0_usize);
            let v64 = C::xreg_new(ctx, v63);
            let v65 = C::put_in_regs(ctx, arg3);
            let v66 = C::value_regs_get(ctx, v65, 0x1_usize);
            let v67 = C::xreg_new(ctx, v66);
            let v68 = constructor_lower_icmp128_hi(ctx, arg1, v61, v67);
            let v69 = constructor_pulley_xult64(ctx, v35, v64);
            let v70 = constructor_pulley_xbxor64(ctx, v61, v67);
            let v50 = constructor_pulley_xconst8(ctx, 0_i8);
            let v71 = constructor_pulley_xeq64(ctx, v70, v50);
            let v72 = constructor_pulley_xselect32(ctx, v71, v69, v68);
            // Rule at src/isa/pulley_shared/lower.isle line 826.
            return v72;
        }
        match arg1 {
            &IntCC::SignedGreaterThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src/isa/pulley_shared/lower.isle line 815.
                return v57;
            }
            &IntCC::SignedLessThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src/isa/pulley_shared/lower.isle line 813.
                return v57;
            }
            &IntCC::UnsignedGreaterThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src/isa/pulley_shared/lower.isle line 819.
                return v57;
            }
            &IntCC::UnsignedLessThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src/isa/pulley_shared/lower.isle line 817.
                return v57;
            }
            _ => {}
        }
    }
    match arg1 {
        &IntCC::Equal => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v16 = constructor_pulley_xeq32(ctx, v14, v15);
                // Rule at src/isa/pulley_shared/lower.isle line 759.
                return v16;
            }
            match arg0 {
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v6 = constructor_pulley_xeq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 741.
                    return v6;
                }
                I128 => {
                    let v32 = C::put_in_regs(ctx, arg2);
                    let v34 = C::value_regs_get(ctx, v32, 0x0_usize);
                    let v35 = C::xreg_new(ctx, v34);
                    let v36 = C::put_in_regs(ctx, arg3);
                    let v37 = C::value_regs_get(ctx, v36, 0x0_usize);
                    let v38 = C::xreg_new(ctx, v37);
                    let v39 = constructor_pulley_xbxor64(ctx, v35, v38);
                    let v40 = C::put_in_regs(ctx, arg2);
                    let v42 = C::value_regs_get(ctx, v40, 0x1_usize);
                    let v43 = C::xreg_new(ctx, v42);
                    let v44 = C::put_in_regs(ctx, arg3);
                    let v45 = C::value_regs_get(ctx, v44, 0x1_usize);
                    let v46 = C::xreg_new(ctx, v45);
                    let v47 = constructor_pulley_xbxor64(ctx, v43, v46);
                    let v48 = constructor_pulley_xbor64(ctx, v39, v47);
                    let v50 = constructor_pulley_xconst8(ctx, 0_i8);
                    let v51 = constructor_pulley_xeq64(ctx, v48, v50);
                    // Rule at src/isa/pulley_shared/lower.isle line 797.
                    return v51;
                }
                _ => {}
            }
        }
        &IntCC::NotEqual => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v17 = constructor_pulley_xneq32(ctx, v14, v15);
                // Rule at src/isa/pulley_shared/lower.isle line 762.
                return v17;
            }
            match arg0 {
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v7 = constructor_pulley_xneq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 744.
                    return v7;
                }
                I128 => {
                    let v32 = C::put_in_regs(ctx, arg2);
                    let v34 = C::value_regs_get(ctx, v32, 0x0_usize);
                    let v35 = C::xreg_new(ctx, v34);
                    let v36 = C::put_in_regs(ctx, arg3);
                    let v37 = C::value_regs_get(ctx, v36, 0x0_usize);
                    let v38 = C::xreg_new(ctx, v37);
                    let v39 = constructor_pulley_xbxor64(ctx, v35, v38);
                    let v40 = C::put_in_regs(ctx, arg2);
                    let v42 = C::value_regs_get(ctx, v40, 0x1_usize);
                    let v43 = C::xreg_new(ctx, v42);
                    let v44 = C::put_in_regs(ctx, arg3);
                    let v45 = C::value_regs_get(ctx, v44, 0x1_usize);
                    let v46 = C::xreg_new(ctx, v45);
                    let v47 = constructor_pulley_xbxor64(ctx, v43, v46);
                    let v48 = constructor_pulley_xbor64(ctx, v39, v47);
                    let v50 = constructor_pulley_xconst8(ctx, 0_i8);
                    let v52 = constructor_pulley_xneq64(ctx, v48, v50);
                    // Rule at src/isa/pulley_shared/lower.isle line 801.
                    return v52;
                }
                _ => {}
            }
        }
        &IntCC::SignedGreaterThan => {
            let v25 = constructor_lower_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 779.
            return v25;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v27 = constructor_lower_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 781.
            return v27;
        }
        &IntCC::SignedLessThan => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v18 = constructor_sext32(ctx, arg2);
                let v19 = constructor_sext32(ctx, arg3);
                let v20 = constructor_pulley_xslt32(ctx, v18, v19);
                // Rule at src/isa/pulley_shared/lower.isle line 765.
                return v20;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v8 = constructor_pulley_xslt64(ctx, v4, v5);
                // Rule at src/isa/pulley_shared/lower.isle line 747.
                return v8;
            }
        }
        &IntCC::SignedLessThanOrEqual => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v18 = constructor_sext32(ctx, arg2);
                let v19 = constructor_sext32(ctx, arg3);
                let v21 = constructor_pulley_xslteq32(ctx, v18, v19);
                // Rule at src/isa/pulley_shared/lower.isle line 768.
                return v21;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v9 = constructor_pulley_xslteq64(ctx, v4, v5);
                // Rule at src/isa/pulley_shared/lower.isle line 750.
                return v9;
            }
        }
        &IntCC::UnsignedGreaterThan => {
            let v29 = constructor_lower_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 783.
            return v29;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v31 = constructor_lower_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 785.
            return v31;
        }
        &IntCC::UnsignedLessThan => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v22 = constructor_pulley_xult32(ctx, v14, v15);
                // Rule at src/isa/pulley_shared/lower.isle line 771.
                return v22;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v10 = constructor_pulley_xult64(ctx, v4, v5);
                // Rule at src/isa/pulley_shared/lower.isle line 753.
                return v10;
            }
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v23 = constructor_pulley_xulteq32(ctx, v14, v15);
                // Rule at src/isa/pulley_shared/lower.isle line 774.
                return v23;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v11 = constructor_pulley_xulteq64(ctx, v4, v5);
                // Rule at src/isa/pulley_shared/lower.isle line 756.
                return v11;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_icmp", "src/isa/pulley_shared/lower.isle line 739")
}

// Generated as internal constructor for term lower_icmp128_hi.
pub fn constructor_lower_icmp128_hi<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    match arg0 {
        &IntCC::SignedLessThan => {
            let v3 = constructor_pulley_xslt64(ctx, arg1, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 840.
            return v3;
        }
        &IntCC::UnsignedLessThan => {
            let v4 = constructor_pulley_xult64(ctx, arg1, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 841.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_icmp128_hi", "src/isa/pulley_shared/lower.isle line 839")
}

// Generated as internal constructor for term lower_vcmp.
pub fn constructor_lower_vcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> VReg {
    match arg1 {
        &IntCC::Equal => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v6 = constructor_pulley_veq8x16(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 849.
                    return v6;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v12 = constructor_pulley_veq16x8(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 855.
                    return v12;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v18 = constructor_pulley_veq32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 861.
                    return v18;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v24 = constructor_pulley_veq64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 867.
                    return v24;
                }
                _ => {}
            }
        }
        &IntCC::NotEqual => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v7 = constructor_pulley_vneq8x16(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 850.
                    return v7;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v13 = constructor_pulley_vneq16x8(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 856.
                    return v13;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v19 = constructor_pulley_vneq32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 862.
                    return v19;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v25 = constructor_pulley_vneq64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 868.
                    return v25;
                }
                _ => {}
            }
        }
        &IntCC::SignedGreaterThan => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 875.
            return v31;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 877.
            return v31;
        }
        &IntCC::SignedLessThan => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v8 = constructor_pulley_vslt8x16(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 851.
                    return v8;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v14 = constructor_pulley_vslt16x8(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 857.
                    return v14;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v20 = constructor_pulley_vslt32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 863.
                    return v20;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v26 = constructor_pulley_vslt64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 869.
                    return v26;
                }
                _ => {}
            }
        }
        &IntCC::SignedLessThanOrEqual => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v9 = constructor_pulley_vslteq8x16(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 852.
                    return v9;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v15 = constructor_pulley_vslteq16x8(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 858.
                    return v15;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v21 = constructor_pulley_vslteq32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 864.
                    return v21;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v27 = constructor_pulley_vslteq64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 870.
                    return v27;
                }
                _ => {}
            }
        }
        &IntCC::UnsignedGreaterThan => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 879.
            return v31;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 881.
            return v31;
        }
        &IntCC::UnsignedLessThan => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v10 = constructor_pulley_vult8x16(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 853.
                    return v10;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v16 = constructor_pulley_vult16x8(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 859.
                    return v16;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v22 = constructor_pulley_vult32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 865.
                    return v22;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v28 = constructor_pulley_vult64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 871.
                    return v28;
                }
                _ => {}
            }
        }
        &IntCC::UnsignedLessThanOrEqual => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v11 = constructor_pulley_vulteq8x16(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 854.
                    return v11;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v17 = constructor_pulley_vulteq16x8(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 860.
                    return v17;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v23 = constructor_pulley_vulteq32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 866.
                    return v23;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v29 = constructor_pulley_vulteq64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 872.
                    return v29;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_vcmp", "src/isa/pulley_shared/lower.isle line 848")
}

// Generated as internal constructor for term lower_fcmp.
pub fn constructor_lower_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> XReg {
    match arg1 {
        &FloatCC::Equal => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v6 = constructor_pulley_feq32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 894.
                    return v6;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v7 = constructor_pulley_feq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 895.
                    return v7;
                }
                _ => {}
            }
        }
        &FloatCC::GreaterThan => {
            let v23 = constructor_lower_fcmp(ctx, arg0, &FloatCC::LessThan, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 913.
            return v23;
        }
        &FloatCC::GreaterThanOrEqual => {
            let v25 = constructor_lower_fcmp(ctx, arg0, &FloatCC::LessThanOrEqual, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 915.
            return v25;
        }
        &FloatCC::LessThan => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v10 = constructor_pulley_flt32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 898.
                    return v10;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v11 = constructor_pulley_flt64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 899.
                    return v11;
                }
                _ => {}
            }
        }
        &FloatCC::LessThanOrEqual => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v12 = constructor_pulley_flteq32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 900.
                    return v12;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v13 = constructor_pulley_flteq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 901.
                    return v13;
                }
                _ => {}
            }
        }
        &FloatCC::NotEqual => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v8 = constructor_pulley_fneq32(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 896.
                    return v8;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v9 = constructor_pulley_fneq64(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 897.
                    return v9;
                }
                _ => {}
            }
        }
        &FloatCC::Ordered => {
            let v15 = constructor_lower_fcmp(ctx, arg0, &FloatCC::Equal, arg2, arg2);
            let v16 = constructor_lower_fcmp(ctx, arg0, &FloatCC::Equal, arg3, arg3);
            let v17 = constructor_pulley_xband32(ctx, v15, v16);
            // Rule at src/isa/pulley_shared/lower.isle line 904.
            return v17;
        }
        &FloatCC::OrderedNotEqual => {
            let v19 = constructor_lower_fcmp(ctx, arg0, &FloatCC::LessThan, arg2, arg3);
            let v21 = constructor_lower_fcmp(ctx, arg0, &FloatCC::GreaterThan, arg2, arg3);
            let v22 = constructor_pulley_xbor32(ctx, v19, v21);
            // Rule at src/isa/pulley_shared/lower.isle line 908.
            return v22;
        }
        _ => {}
    }
    let v26 = C::floatcc_unordered(ctx, arg1);
    if v26 == true {
        let v27 = &C::floatcc_complement(ctx, arg1);
        let v28 = constructor_lower_fcmp(ctx, arg0, v27, arg2, arg3);
        let v30 = constructor_pulley_xbxor32_s8(ctx, v28, 1_i8);
        // Rule at src/isa/pulley_shared/lower.isle line 919.
        return v30;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_fcmp", "src/isa/pulley_shared/lower.isle line 892")
}

// Generated as internal constructor for term lower_vfcmp.
pub fn constructor_lower_vfcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> VReg {
    match arg1 {
        &FloatCC::Equal => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v6 = constructor_pulley_veqf32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 925.
                    return v6;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v7 = constructor_pulley_veqf64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 926.
                    return v7;
                }
                _ => {}
            }
        }
        &FloatCC::GreaterThan => {
            let v19 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::LessThan, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 944.
            return v19;
        }
        &FloatCC::GreaterThanOrEqual => {
            let v21 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::LessThanOrEqual, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 946.
            return v21;
        }
        &FloatCC::LessThan => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v10 = constructor_pulley_vltf32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 929.
                    return v10;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v11 = constructor_pulley_vltf64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 930.
                    return v11;
                }
                _ => {}
            }
        }
        &FloatCC::LessThanOrEqual => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v12 = constructor_pulley_vlteqf32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 931.
                    return v12;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v13 = constructor_pulley_vlteqf64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 932.
                    return v13;
                }
                _ => {}
            }
        }
        &FloatCC::NotEqual => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v8 = constructor_pulley_vneqf32x4(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 927.
                    return v8;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v9 = constructor_pulley_vneqf64x2(ctx, v4, v5);
                    // Rule at src/isa/pulley_shared/lower.isle line 928.
                    return v9;
                }
                _ => {}
            }
        }
        &FloatCC::Unordered => {
            let v15 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::NotEqual, arg2, arg2);
            let v16 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::NotEqual, arg3, arg3);
            let v17 = constructor_pulley_vbor128(ctx, v15, v16);
            // Rule at src/isa/pulley_shared/lower.isle line 934.
            return v17;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_vfcmp", "src/isa/pulley_shared/lower.isle line 923")
}

// Generated as internal constructor for term gen_xload.
pub fn constructor_gen_xload<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
    arg4: &ExtKind,
) -> XReg {
    let v14 = &constructor_wasm_g32(ctx, arg0, arg1, arg2, arg3);
    if let Some(v15) = v14 {
        let v16 = constructor_gen_xload_g32(ctx, v15, arg3, arg4);
        // Rule at src/isa/pulley_shared/lower.isle line 1087.
        return v16;
    }
    let v11 = C::memflags_is_wasm(ctx, arg2);
    if v11 == true {
        let v12 = &constructor_addrz(ctx, arg0, arg1);
        let v13 = constructor_emit_addrz_xload(ctx, v12, arg3, arg4);
        // Rule at src/isa/pulley_shared/lower.isle line 1062.
        return v13;
    }
    let v5 = C::memflags_nontrapping(ctx, arg2);
    if v5 == true {
        let v6 = &C::endianness(ctx, arg2);
        match v6 {
            &Endianness::Little => {
                let v9 = &constructor_addro32(ctx, arg0, arg1);
                let v10 = constructor_emit_addro32_xload(ctx, v9, arg3, arg4);
                // Rule at src/isa/pulley_shared/lower.isle line 1037.
                return v10;
            }
            &Endianness::Big => {
                if let &ExtKind::None = arg4 {
                    let v7 = &constructor_amode(ctx, arg0, arg1);
                    let v8 = constructor_pulley_xload(ctx, v7, arg3, arg2);
                    // Rule at src/isa/pulley_shared/lower.isle line 1030.
                    return v8;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_xload", "src/isa/pulley_shared/lower.isle line 1024")
}

// Generated as internal constructor for term emit_addro32_xload.
pub fn constructor_emit_addro32_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1043.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1044.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_o32(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src/isa/pulley_shared/lower.isle line 1046.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1045.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_o32(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src/isa/pulley_shared/lower.isle line 1047.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1048.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1049.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_o32(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src/isa/pulley_shared/lower.isle line 1051.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1050.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_o32(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src/isa/pulley_shared/lower.isle line 1052.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1053.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1054.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1056.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1055.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1057.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_o32(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1058.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addro32_xload", "src/isa/pulley_shared/lower.isle line 1042")
}

// Generated as internal constructor for term emit_addrz_xload.
pub fn constructor_emit_addrz_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1067.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1068.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_z(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src/isa/pulley_shared/lower.isle line 1070.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1069.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_z(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src/isa/pulley_shared/lower.isle line 1071.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1072.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1073.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_z(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src/isa/pulley_shared/lower.isle line 1075.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1074.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_z(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src/isa/pulley_shared/lower.isle line 1076.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1077.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1078.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1080.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1079.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1081.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_z(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1082.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_xload", "src/isa/pulley_shared/lower.isle line 1066")
}

// Generated as internal constructor for term gen_xload_g32.
pub fn constructor_gen_xload_g32<C: Context>(
    ctx: &mut C,
    arg0: &G32,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    let v5 = &constructor_addrg32bne(ctx, arg0);
    if let Some(v6) = v5 {
        let v7 = &constructor_gen_addrg32bne(ctx, v6);
        let v8 = constructor_emit_addrg32bne_xload(ctx, v7, arg1, arg2);
        // Rule at src/isa/pulley_shared/lower.isle line 1114.
        return v8;
    }
    let v3 = &constructor_gen_addrg32(ctx, arg0);
    let v4 = constructor_emit_addrg32_xload(ctx, v3, arg1, arg2);
    // Rule at src/isa/pulley_shared/lower.isle line 1093.
    return v4;
}

// Generated as internal constructor for term emit_addrg32_xload.
pub fn constructor_emit_addrg32_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1096.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1097.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_g32(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src/isa/pulley_shared/lower.isle line 1099.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1098.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_g32(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src/isa/pulley_shared/lower.isle line 1100.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1101.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1102.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_g32(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src/isa/pulley_shared/lower.isle line 1104.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1103.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_g32(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src/isa/pulley_shared/lower.isle line 1105.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1106.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1107.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1109.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1108.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1110.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_g32(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1111.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32_xload", "src/isa/pulley_shared/lower.isle line 1095")
}

// Generated as internal constructor for term emit_addrg32bne_xload.
pub fn constructor_emit_addrg32bne_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1119.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1120.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_g32bne(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src/isa/pulley_shared/lower.isle line 1122.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1121.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_g32bne(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src/isa/pulley_shared/lower.isle line 1123.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1124.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1125.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_g32bne(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src/isa/pulley_shared/lower.isle line 1127.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1126.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_g32bne(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src/isa/pulley_shared/lower.isle line 1128.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1129.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1130.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1132.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    // Rule at src/isa/pulley_shared/lower.isle line 1131.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src/isa/pulley_shared/lower.isle line 1133.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_g32bne(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1134.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32bne_xload", "src/isa/pulley_shared/lower.isle line 1118")
}

// Generated as internal constructor for term gen_fload.
pub fn constructor_gen_fload<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
) -> FReg {
    let v10 = &constructor_wasm_g32(ctx, arg0, arg1, arg2, arg3);
    if let Some(v11) = v10 {
        let v12 = &constructor_gen_addrg32(ctx, v11);
        let v13 = constructor_emit_addrg32_fload(ctx, v12, arg3);
        // Rule at src/isa/pulley_shared/lower.isle line 1157.
        return v13;
    }
    let v7 = C::memflags_is_wasm(ctx, arg2);
    if v7 == true {
        let v8 = &constructor_addrz(ctx, arg0, arg1);
        let v9 = constructor_emit_addrz_fload(ctx, v8, arg3);
        // Rule at src/isa/pulley_shared/lower.isle line 1147.
        return v9;
    }
    let v4 = C::memflags_nontrapping(ctx, arg2);
    if v4 == true {
        let v5 = &constructor_amode(ctx, arg0, arg1);
        let v6 = constructor_pulley_fload(ctx, v5, arg3, arg2);
        // Rule at src/isa/pulley_shared/lower.isle line 1141.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_fload", "src/isa/pulley_shared/lower.isle line 1137")
}

// Generated as internal constructor for term emit_addrz_fload.
pub fn constructor_emit_addrz_fload<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Type,
) -> FReg {
    match arg1 {
        F32 => {
            let v2 = constructor_pulley_fload32le_z(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1152.
            return v2;
        }
        F64 => {
            let v3 = constructor_pulley_fload64le_z(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1153.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_fload", "src/isa/pulley_shared/lower.isle line 1151")
}

// Generated as internal constructor for term emit_addrg32_fload.
pub fn constructor_emit_addrg32_fload<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: Type,
) -> FReg {
    match arg1 {
        F32 => {
            let v2 = constructor_pulley_fload32le_g32(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1162.
            return v2;
        }
        F64 => {
            let v3 = constructor_pulley_fload64le_g32(ctx, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1163.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32_fload", "src/isa/pulley_shared/lower.isle line 1161")
}

// Generated as internal constructor for term gen_vload.
pub fn constructor_gen_vload<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
    arg4: &VExtKind,
) -> VReg {
    if let &VExtKind::None = arg4 {
        let v11 = C::ty_vec128(ctx, arg3);
        if let Some(v12) = v11 {
            let v13 = &constructor_wasm_g32(ctx, arg0, arg1, arg2, v12);
            if let Some(v14) = v13 {
                let v15 = &constructor_gen_addrg32(ctx, v14);
                let v16 = constructor_pulley_vload128le_g32(ctx, v15);
                // Rule at src/isa/pulley_shared/lower.isle line 1191.
                return v16;
            }
        }
    }
    let v8 = C::memflags_is_wasm(ctx, arg2);
    if v8 == true {
        let v9 = &constructor_addrz(ctx, arg0, arg1);
        let v10 = constructor_emit_addrz_vload(ctx, v9, arg3, arg4);
        // Rule at src/isa/pulley_shared/lower.isle line 1176.
        return v10;
    }
    if let &VExtKind::None = arg4 {
        let v5 = C::memflags_nontrapping(ctx, arg2);
        if v5 == true {
            let v6 = &constructor_amode(ctx, arg0, arg1);
            let v7 = constructor_pulley_vload(ctx, v6, arg3, arg2);
            // Rule at src/isa/pulley_shared/lower.isle line 1171.
            return v7;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_vload", "src/isa/pulley_shared/lower.isle line 1166")
}

// Generated as internal constructor for term emit_addrz_vload.
pub fn constructor_emit_addrz_vload<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Type,
    arg2: &VExtKind,
) -> VReg {
    let v2 = C::ty_vec128(ctx, arg1);
    if let Some(v3) = v2 {
        match arg2 {
            &VExtKind::None => {
                let v5 = constructor_pulley_vload128le_z(ctx, arg0);
                // Rule at src/isa/pulley_shared/lower.isle line 1181.
                return v5;
            }
            &VExtKind::S8x8 => {
                let v6 = constructor_pulley_vload8x8_s_z(ctx, arg0);
                // Rule at src/isa/pulley_shared/lower.isle line 1182.
                return v6;
            }
            &VExtKind::U8x8 => {
                let v7 = constructor_pulley_vload8x8_u_z(ctx, arg0);
                // Rule at src/isa/pulley_shared/lower.isle line 1183.
                return v7;
            }
            &VExtKind::S16x4 => {
                let v8 = constructor_pulley_vload16x4le_s_z(ctx, arg0);
                // Rule at src/isa/pulley_shared/lower.isle line 1184.
                return v8;
            }
            &VExtKind::U16x4 => {
                let v9 = constructor_pulley_vload16x4le_u_z(ctx, arg0);
                // Rule at src/isa/pulley_shared/lower.isle line 1185.
                return v9;
            }
            &VExtKind::S32x2 => {
                let v10 = constructor_pulley_vload32x2le_s_z(ctx, arg0);
                // Rule at src/isa/pulley_shared/lower.isle line 1186.
                return v10;
            }
            &VExtKind::U32x2 => {
                let v11 = constructor_pulley_vload32x2le_u_z(ctx, arg0);
                // Rule at src/isa/pulley_shared/lower.isle line 1187.
                return v11;
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_vload", "src/isa/pulley_shared/lower.isle line 1180")
}

// Generated as internal constructor for term emit_store_i128.
pub fn constructor_emit_store_i128<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: XReg,
    arg2: XReg,
    arg3: &Amode,
    arg4: &Amode,
) -> SideEffectNoResult {
    let v5 = &C::endianness(ctx, arg0);
    match v5 {
        &Endianness::Little => {
            let v7 = &constructor_pulley_xstore(ctx, arg3, arg1, I64, arg0);
            let v8 = constructor_side_effect(ctx, v7);
            let v9 = &constructor_pulley_xstore(ctx, arg4, arg2, I64, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1229.
            return v9.clone();
        }
        &Endianness::Big => {
            let v10 = &constructor_pulley_xstore(ctx, arg3, arg2, I64, arg0);
            let v11 = constructor_side_effect(ctx, v10);
            let v12 = &constructor_pulley_xstore(ctx, arg4, arg1, I64, arg0);
            // Rule at src/isa/pulley_shared/lower.isle line 1233.
            return v12.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_store_i128", "src/isa/pulley_shared/lower.isle line 1228")
}

// Generated as internal constructor for term gen_store.
pub fn constructor_gen_store<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: Offset32,
    arg3: MemFlags,
    arg4: Type,
) -> SideEffectNoResult {
    let v22 = &constructor_wasm_g32(ctx, arg1, arg2, arg3, arg4);
    if let Some(v23) = v22 {
        let v24 = &constructor_gen_addrg32(ctx, v23);
        let v25 = &constructor_emit_addrg32_store(ctx, v24, arg0, arg4);
        // Rule at src/isa/pulley_shared/lower.isle line 1269.
        return v25.clone();
    }
    let v19 = C::memflags_is_wasm(ctx, arg3);
    if v19 == true {
        let v20 = &constructor_addrz(ctx, arg1, arg2);
        let v21 = &constructor_emit_addrz_store(ctx, v20, arg0, arg4);
        // Rule at src/isa/pulley_shared/lower.isle line 1255.
        return v21.clone();
    }
    let v7 = C::memflags_nontrapping(ctx, arg3);
    if v7 == true {
        let v15 = C::ty_vec128(ctx, arg4);
        if let Some(v16) = v15 {
            let v8 = &constructor_amode(ctx, arg1, arg2);
            let v17 = constructor_put_in_vreg(ctx, arg0);
            let v18 = &constructor_pulley_vstore(ctx, v8, v17, v16, arg3);
            // Rule at src/isa/pulley_shared/lower.isle line 1250.
            return v18.clone();
        }
        let v11 = C::ty_scalar_float(ctx, arg4);
        if let Some(v12) = v11 {
            let v8 = &constructor_amode(ctx, arg1, arg2);
            let v13 = constructor_put_in_freg(ctx, arg0);
            let v14 = &constructor_pulley_fstore(ctx, v8, v13, v12, arg3);
            // Rule at src/isa/pulley_shared/lower.isle line 1247.
            return v14.clone();
        }
        let v5 = C::ty_int(ctx, arg4);
        if let Some(v6) = v5 {
            let v8 = &constructor_amode(ctx, arg1, arg2);
            let v9 = constructor_put_in_xreg(ctx, arg0);
            let v10 = &constructor_pulley_xstore(ctx, v8, v9, v6, arg3);
            // Rule at src/isa/pulley_shared/lower.isle line 1244.
            return v10.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_store", "src/isa/pulley_shared/lower.isle line 1241")
}

// Generated as internal constructor for term emit_addrz_store.
pub fn constructor_emit_addrz_store<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Value,
    arg2: Type,
) -> SideEffectNoResult {
    let v11 = C::ty_vec128(ctx, arg2);
    if let Some(v12) = v11 {
        let v13 = constructor_put_in_vreg(ctx, arg1);
        let v14 = &constructor_pulley_vstore128le_z(ctx, arg0, v13);
        // Rule at src/isa/pulley_shared/lower.isle line 1266.
        return v14.clone();
    }
    match arg2 {
        I8 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = &constructor_pulley_xstore8_z(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1260.
            return v4.clone();
        }
        I16 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v5 = &constructor_pulley_xstore16le_z(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1261.
            return v5.clone();
        }
        I32 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v6 = &constructor_pulley_xstore32le_z(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1262.
            return v6.clone();
        }
        I64 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v7 = &constructor_pulley_xstore64le_z(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1263.
            return v7.clone();
        }
        F32 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v9 = &constructor_pulley_fstore32le_z(ctx, arg0, v8);
            // Rule at src/isa/pulley_shared/lower.isle line 1264.
            return v9.clone();
        }
        F64 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v10 = &constructor_pulley_fstore64le_z(ctx, arg0, v8);
            // Rule at src/isa/pulley_shared/lower.isle line 1265.
            return v10.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_store", "src/isa/pulley_shared/lower.isle line 1259")
}

// Generated as internal constructor for term emit_addrg32_store.
pub fn constructor_emit_addrg32_store<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: Value,
    arg2: Type,
) -> SideEffectNoResult {
    let v11 = C::ty_vec128(ctx, arg2);
    if let Some(v12) = v11 {
        let v13 = constructor_put_in_vreg(ctx, arg1);
        let v14 = &constructor_pulley_vstore128le_g32(ctx, arg0, v13);
        // Rule at src/isa/pulley_shared/lower.isle line 1280.
        return v14.clone();
    }
    match arg2 {
        I8 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = &constructor_pulley_xstore8_g32(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1274.
            return v4.clone();
        }
        I16 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v5 = &constructor_pulley_xstore16le_g32(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1275.
            return v5.clone();
        }
        I32 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v6 = &constructor_pulley_xstore32le_g32(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1276.
            return v6.clone();
        }
        I64 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v7 = &constructor_pulley_xstore64le_g32(ctx, arg0, v3);
            // Rule at src/isa/pulley_shared/lower.isle line 1277.
            return v7.clone();
        }
        F32 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v9 = &constructor_pulley_fstore32le_g32(ctx, arg0, v8);
            // Rule at src/isa/pulley_shared/lower.isle line 1278.
            return v9.clone();
        }
        F64 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v10 = &constructor_pulley_fstore64le_g32(ctx, arg0, v8);
            // Rule at src/isa/pulley_shared/lower.isle line 1279.
            return v10.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32_store", "src/isa/pulley_shared/lower.isle line 1273")
}

// Generated as internal constructor for term lower_stack_addr.
pub fn constructor_lower_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: StackSlot,
    arg1: Offset32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = C::writable_xreg_to_writable_reg(ctx, v2);
    let v4 = &C::abi_stackslot_addr(ctx, v3, arg0, arg1);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src/isa/pulley_shared/lower.isle line 1288.
    return v6;
}

// Generated as internal constructor for term emit_cond.
pub fn constructor_emit_cond<C: Context>(
    ctx: &mut C,
    arg0: &Cond,
) -> XReg {
    match arg0 {
        &Cond::If32 {
            reg: v1,
        } => {
            // Rule at src/isa/pulley_shared/lower.isle line 1362.
            return v1;
        }
        &Cond::IfNot32 {
            reg: v2,
        } => {
            let v4 = constructor_pulley_xconst8(ctx, 0_i8);
            let v5 = constructor_pulley_xeq32(ctx, v2, v4);
            // Rule at src/isa/pulley_shared/lower.isle line 1363.
            return v5;
        }
        &Cond::IfXeq32 {
            src1: v6,
            src2: v7,
        } => {
            let v8 = constructor_pulley_xeq32(ctx, v6, v7);
            // Rule at src/isa/pulley_shared/lower.isle line 1364.
            return v8;
        }
        &Cond::IfXneq32 {
            src1: v9,
            src2: v10,
        } => {
            let v11 = constructor_pulley_xneq32(ctx, v9, v10);
            // Rule at src/isa/pulley_shared/lower.isle line 1365.
            return v11;
        }
        &Cond::IfXslt32 {
            src1: v12,
            src2: v13,
        } => {
            let v14 = constructor_pulley_xslt32(ctx, v12, v13);
            // Rule at src/isa/pulley_shared/lower.isle line 1366.
            return v14;
        }
        &Cond::IfXslteq32 {
            src1: v15,
            src2: v16,
        } => {
            let v17 = constructor_pulley_xslteq32(ctx, v15, v16);
            // Rule at src/isa/pulley_shared/lower.isle line 1367.
            return v17;
        }
        &Cond::IfXult32 {
            src1: v18,
            src2: v19,
        } => {
            let v20 = constructor_pulley_xult32(ctx, v18, v19);
            // Rule at src/isa/pulley_shared/lower.isle line 1368.
            return v20;
        }
        &Cond::IfXulteq32 {
            src1: v21,
            src2: v22,
        } => {
            let v23 = constructor_pulley_xulteq32(ctx, v21, v22);
            // Rule at src/isa/pulley_shared/lower.isle line 1369.
            return v23;
        }
        &Cond::IfXeq32I32 {
            src1: v42,
            src2: v43,
        } => {
            let v44 = C::i32_into_i64(ctx, v43);
            let v45 = constructor_imm(ctx, v44);
            let v46 = C::xreg_new(ctx, v45);
            let v47 = constructor_pulley_xeq32(ctx, v42, v46);
            // Rule at src/isa/pulley_shared/lower.isle line 1377.
            return v47;
        }
        &Cond::IfXneq32I32 {
            src1: v48,
            src2: v49,
        } => {
            let v50 = C::i32_into_i64(ctx, v49);
            let v51 = constructor_imm(ctx, v50);
            let v52 = C::xreg_new(ctx, v51);
            let v53 = constructor_pulley_xneq32(ctx, v48, v52);
            // Rule at src/isa/pulley_shared/lower.isle line 1378.
            return v53;
        }
        &Cond::IfXslt32I32 {
            src1: v54,
            src2: v55,
        } => {
            let v56 = C::i32_into_i64(ctx, v55);
            let v57 = constructor_imm(ctx, v56);
            let v58 = C::xreg_new(ctx, v57);
            let v59 = constructor_pulley_xslt32(ctx, v54, v58);
            // Rule at src/isa/pulley_shared/lower.isle line 1379.
            return v59;
        }
        &Cond::IfXslteq32I32 {
            src1: v60,
            src2: v61,
        } => {
            let v62 = C::i32_into_i64(ctx, v61);
            let v63 = constructor_imm(ctx, v62);
            let v64 = C::xreg_new(ctx, v63);
            let v65 = constructor_pulley_xslteq32(ctx, v60, v64);
            // Rule at src/isa/pulley_shared/lower.isle line 1380.
            return v65;
        }
        &Cond::IfXult32I32 {
            src1: v66,
            src2: v67,
        } => {
            let v68 = C::u32_into_i64(ctx, v67);
            let v69 = constructor_imm(ctx, v68);
            let v70 = C::xreg_new(ctx, v69);
            let v71 = constructor_pulley_xult32(ctx, v66, v70);
            // Rule at src/isa/pulley_shared/lower.isle line 1381.
            return v71;
        }
        &Cond::IfXulteq32I32 {
            src1: v72,
            src2: v73,
        } => {
            let v74 = C::u32_into_i64(ctx, v73);
            let v75 = constructor_imm(ctx, v74);
            let v76 = C::xreg_new(ctx, v75);
            let v77 = constructor_pulley_xulteq32(ctx, v72, v76);
            // Rule at src/isa/pulley_shared/lower.isle line 1382.
            return v77;
        }
        &Cond::IfXsgt32I32 {
            src1: v78,
            src2: v79,
        } => {
            let v80 = C::i32_into_i64(ctx, v79);
            let v81 = constructor_imm(ctx, v80);
            let v82 = C::xreg_new(ctx, v81);
            let v83 = constructor_pulley_xslt32(ctx, v82, v78);
            // Rule at src/isa/pulley_shared/lower.isle line 1385.
            return v83;
        }
        &Cond::IfXsgteq32I32 {
            src1: v84,
            src2: v85,
        } => {
            let v86 = C::i32_into_i64(ctx, v85);
            let v87 = constructor_imm(ctx, v86);
            let v88 = C::xreg_new(ctx, v87);
            let v89 = constructor_pulley_xslteq32(ctx, v88, v84);
            // Rule at src/isa/pulley_shared/lower.isle line 1386.
            return v89;
        }
        &Cond::IfXugt32I32 {
            src1: v90,
            src2: v91,
        } => {
            let v92 = C::u32_into_i64(ctx, v91);
            let v93 = constructor_imm(ctx, v92);
            let v94 = C::xreg_new(ctx, v93);
            let v95 = constructor_pulley_xult32(ctx, v94, v90);
            // Rule at src/isa/pulley_shared/lower.isle line 1387.
            return v95;
        }
        &Cond::IfXugteq32I32 {
            src1: v96,
            src2: v97,
        } => {
            let v98 = C::u32_into_i64(ctx, v97);
            let v99 = constructor_imm(ctx, v98);
            let v100 = C::xreg_new(ctx, v99);
            let v101 = constructor_pulley_xulteq32(ctx, v100, v96);
            // Rule at src/isa/pulley_shared/lower.isle line 1388.
            return v101;
        }
        &Cond::IfXeq64 {
            src1: v24,
            src2: v25,
        } => {
            let v26 = constructor_pulley_xeq64(ctx, v24, v25);
            // Rule at src/isa/pulley_shared/lower.isle line 1370.
            return v26;
        }
        &Cond::IfXneq64 {
            src1: v27,
            src2: v28,
        } => {
            let v29 = constructor_pulley_xneq64(ctx, v27, v28);
            // Rule at src/isa/pulley_shared/lower.isle line 1371.
            return v29;
        }
        &Cond::IfXslt64 {
            src1: v30,
            src2: v31,
        } => {
            let v32 = constructor_pulley_xslt64(ctx, v30, v31);
            // Rule at src/isa/pulley_shared/lower.isle line 1372.
            return v32;
        }
        &Cond::IfXslteq64 {
            src1: v33,
            src2: v34,
        } => {
            let v35 = constructor_pulley_xslteq64(ctx, v33, v34);
            // Rule at src/isa/pulley_shared/lower.isle line 1373.
            return v35;
        }
        &Cond::IfXult64 {
            src1: v36,
            src2: v37,
        } => {
            let v38 = constructor_pulley_xult64(ctx, v36, v37);
            // Rule at src/isa/pulley_shared/lower.isle line 1374.
            return v38;
        }
        &Cond::IfXulteq64 {
            src1: v39,
            src2: v40,
        } => {
            let v41 = constructor_pulley_xulteq64(ctx, v39, v40);
            // Rule at src/isa/pulley_shared/lower.isle line 1375.
            return v41;
        }
        &Cond::IfXeq64I32 {
            src1: v102,
            src2: v103,
        } => {
            let v104 = C::i32_into_i64(ctx, v103);
            let v105 = constructor_imm(ctx, v104);
            let v106 = C::xreg_new(ctx, v105);
            let v107 = constructor_pulley_xeq64(ctx, v102, v106);
            // Rule at src/isa/pulley_shared/lower.isle line 1390.
            return v107;
        }
        &Cond::IfXneq64I32 {
            src1: v108,
            src2: v109,
        } => {
            let v110 = C::i32_into_i64(ctx, v109);
            let v111 = constructor_imm(ctx, v110);
            let v112 = C::xreg_new(ctx, v111);
            let v113 = constructor_pulley_xneq64(ctx, v108, v112);
            // Rule at src/isa/pulley_shared/lower.isle line 1391.
            return v113;
        }
        &Cond::IfXslt64I32 {
            src1: v114,
            src2: v115,
        } => {
            let v116 = C::i32_into_i64(ctx, v115);
            let v117 = constructor_imm(ctx, v116);
            let v118 = C::xreg_new(ctx, v117);
            let v119 = constructor_pulley_xslt64(ctx, v114, v118);
            // Rule at src/isa/pulley_shared/lower.isle line 1392.
            return v119;
        }
        &Cond::IfXslteq64I32 {
            src1: v120,
            src2: v121,
        } => {
            let v122 = C::i32_into_i64(ctx, v121);
            let v123 = constructor_imm(ctx, v122);
            let v124 = C::xreg_new(ctx, v123);
            let v125 = constructor_pulley_xslteq64(ctx, v120, v124);
            // Rule at src/isa/pulley_shared/lower.isle line 1393.
            return v125;
        }
        &Cond::IfXult64I32 {
            src1: v126,
            src2: v127,
        } => {
            let v128 = C::u32_into_i64(ctx, v127);
            let v129 = constructor_imm(ctx, v128);
            let v130 = C::xreg_new(ctx, v129);
            let v131 = constructor_pulley_xult64(ctx, v126, v130);
            // Rule at src/isa/pulley_shared/lower.isle line 1394.
            return v131;
        }
        &Cond::IfXulteq64I32 {
            src1: v132,
            src2: v133,
        } => {
            let v134 = C::u32_into_i64(ctx, v133);
            let v135 = constructor_imm(ctx, v134);
            let v136 = C::xreg_new(ctx, v135);
            let v137 = constructor_pulley_xulteq64(ctx, v132, v136);
            // Rule at src/isa/pulley_shared/lower.isle line 1395.
            return v137;
        }
        &Cond::IfXsgt64I32 {
            src1: v138,
            src2: v139,
        } => {
            let v140 = C::i32_into_i64(ctx, v139);
            let v141 = constructor_imm(ctx, v140);
            let v142 = C::xreg_new(ctx, v141);
            let v143 = constructor_pulley_xslt64(ctx, v142, v138);
            // Rule at src/isa/pulley_shared/lower.isle line 1398.
            return v143;
        }
        &Cond::IfXsgteq64I32 {
            src1: v144,
            src2: v145,
        } => {
            let v146 = C::i32_into_i64(ctx, v145);
            let v147 = constructor_imm(ctx, v146);
            let v148 = C::xreg_new(ctx, v147);
            let v149 = constructor_pulley_xslteq64(ctx, v148, v144);
            // Rule at src/isa/pulley_shared/lower.isle line 1399.
            return v149;
        }
        &Cond::IfXugt64I32 {
            src1: v150,
            src2: v151,
        } => {
            let v152 = C::u32_into_i64(ctx, v151);
            let v153 = constructor_imm(ctx, v152);
            let v154 = C::xreg_new(ctx, v153);
            let v155 = constructor_pulley_xult64(ctx, v154, v150);
            // Rule at src/isa/pulley_shared/lower.isle line 1400.
            return v155;
        }
        &Cond::IfXugteq64I32 {
            src1: v156,
            src2: v157,
        } => {
            let v158 = C::u32_into_i64(ctx, v157);
            let v159 = constructor_imm(ctx, v158);
            let v160 = C::xreg_new(ctx, v159);
            let v161 = constructor_pulley_xulteq64(ctx, v160, v156);
            // Rule at src/isa/pulley_shared/lower.isle line 1401.
            return v161;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_cond", "src/isa/pulley_shared/lower.isle line 1361")
}

// Generated as internal constructor for term pulley_ret.
pub fn constructor_pulley_ret<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::Ret);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 1652.
    return v2;
}

// Generated as internal constructor for term pulley_xjump.
pub fn constructor_pulley_xjump<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> SideEffectNoResult {
    let v1 = RawInst::XJump {
        reg: arg0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 1654.
    return v3;
}

// Generated as internal constructor for term pulley_xmov.
pub fn constructor_pulley_xmov<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xmov {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1656.
    return v5;
}

// Generated as internal constructor for term pulley_xzero.
pub fn constructor_pulley_xzero<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::Xzero {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1663.
    return v4;
}

// Generated as internal constructor for term pulley_xone.
pub fn constructor_pulley_xone<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::Xone {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1670.
    return v4;
}

// Generated as internal constructor for term pulley_xconst8.
pub fn constructor_pulley_xconst8<C: Context>(
    ctx: &mut C,
    arg0: i8,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst8 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1677.
    return v5;
}

// Generated as internal constructor for term pulley_xconst16.
pub fn constructor_pulley_xconst16<C: Context>(
    ctx: &mut C,
    arg0: i16,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst16 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1684.
    return v5;
}

// Generated as internal constructor for term pulley_xconst32.
pub fn constructor_pulley_xconst32<C: Context>(
    ctx: &mut C,
    arg0: i32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst32 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1691.
    return v5;
}

// Generated as internal constructor for term pulley_xconst64.
pub fn constructor_pulley_xconst64<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst64 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1698.
    return v5;
}

// Generated as internal constructor for term pulley_xadd32.
pub fn constructor_pulley_xadd32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1705.
    return v6;
}

// Generated as internal constructor for term pulley_xadd32_u8.
pub fn constructor_pulley_xadd32_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd32U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1712.
    return v6;
}

// Generated as internal constructor for term pulley_xadd32_u32.
pub fn constructor_pulley_xadd32_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd32U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1719.
    return v6;
}

// Generated as internal constructor for term pulley_xadd64.
pub fn constructor_pulley_xadd64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1726.
    return v6;
}

// Generated as internal constructor for term pulley_xadd64_u8.
pub fn constructor_pulley_xadd64_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd64U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1733.
    return v6;
}

// Generated as internal constructor for term pulley_xadd64_u32.
pub fn constructor_pulley_xadd64_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd64U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1740.
    return v6;
}

// Generated as internal constructor for term pulley_xmadd32.
pub fn constructor_pulley_xmadd32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xmadd32 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        src3: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1747.
    return v7;
}

// Generated as internal constructor for term pulley_xmadd64.
pub fn constructor_pulley_xmadd64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xmadd64 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        src3: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1754.
    return v7;
}

// Generated as internal constructor for term pulley_xsub32.
pub fn constructor_pulley_xsub32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1761.
    return v6;
}

// Generated as internal constructor for term pulley_xsub32_u8.
pub fn constructor_pulley_xsub32_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub32U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1768.
    return v6;
}

// Generated as internal constructor for term pulley_xsub32_u32.
pub fn constructor_pulley_xsub32_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub32U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1775.
    return v6;
}

// Generated as internal constructor for term pulley_xsub64.
pub fn constructor_pulley_xsub64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1782.
    return v6;
}

// Generated as internal constructor for term pulley_xsub64_u8.
pub fn constructor_pulley_xsub64_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub64U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1789.
    return v6;
}

// Generated as internal constructor for term pulley_xsub64_u32.
pub fn constructor_pulley_xsub64_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub64U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1796.
    return v6;
}

// Generated as internal constructor for term pulley_xmul32.
pub fn constructor_pulley_xmul32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMul32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1803.
    return v6;
}

// Generated as internal constructor for term pulley_xmul32_s8.
pub fn constructor_pulley_xmul32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1810.
    return v6;
}

// Generated as internal constructor for term pulley_xmul32_s32.
pub fn constructor_pulley_xmul32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1817.
    return v6;
}

// Generated as internal constructor for term pulley_xmul64.
pub fn constructor_pulley_xmul64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMul64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1824.
    return v6;
}

// Generated as internal constructor for term pulley_xmul64_s8.
pub fn constructor_pulley_xmul64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1831.
    return v6;
}

// Generated as internal constructor for term pulley_xmul64_s32.
pub fn constructor_pulley_xmul64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1838.
    return v6;
}

// Generated as internal constructor for term pulley_xctz32.
pub fn constructor_pulley_xctz32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xctz32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1845.
    return v5;
}

// Generated as internal constructor for term pulley_xctz64.
pub fn constructor_pulley_xctz64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xctz64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1852.
    return v5;
}

// Generated as internal constructor for term pulley_xclz32.
pub fn constructor_pulley_xclz32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xclz32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1859.
    return v5;
}

// Generated as internal constructor for term pulley_xclz64.
pub fn constructor_pulley_xclz64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xclz64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1866.
    return v5;
}

// Generated as internal constructor for term pulley_xpopcnt32.
pub fn constructor_pulley_xpopcnt32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xpopcnt32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1873.
    return v5;
}

// Generated as internal constructor for term pulley_xpopcnt64.
pub fn constructor_pulley_xpopcnt64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xpopcnt64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1880.
    return v5;
}

// Generated as internal constructor for term pulley_xrotl32.
pub fn constructor_pulley_xrotl32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotl32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1887.
    return v6;
}

// Generated as internal constructor for term pulley_xrotl64.
pub fn constructor_pulley_xrotl64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotl64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1894.
    return v6;
}

// Generated as internal constructor for term pulley_xrotr32.
pub fn constructor_pulley_xrotr32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotr32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1901.
    return v6;
}

// Generated as internal constructor for term pulley_xrotr64.
pub fn constructor_pulley_xrotr64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotr64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1908.
    return v6;
}

// Generated as internal constructor for term pulley_xshl32.
pub fn constructor_pulley_xshl32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1915.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_s.
pub fn constructor_pulley_xshr32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1922.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_u.
pub fn constructor_pulley_xshr32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1929.
    return v6;
}

// Generated as internal constructor for term pulley_xshl64.
pub fn constructor_pulley_xshl64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1936.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_s.
pub fn constructor_pulley_xshr64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1943.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_u.
pub fn constructor_pulley_xshr64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1950.
    return v6;
}

// Generated as internal constructor for term pulley_xshl32_u6.
pub fn constructor_pulley_xshl32_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl32U6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1957.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_s_u6.
pub fn constructor_pulley_xshr32_s_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32SU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1964.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_u_u6.
pub fn constructor_pulley_xshr32_u_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32UU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1971.
    return v6;
}

// Generated as internal constructor for term pulley_xshl64_u6.
pub fn constructor_pulley_xshl64_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl64U6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1978.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_s_u6.
pub fn constructor_pulley_xshr64_s_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64SU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1985.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_u_u6.
pub fn constructor_pulley_xshr64_u_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64UU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1992.
    return v6;
}

// Generated as internal constructor for term pulley_xneg32.
pub fn constructor_pulley_xneg32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xneg32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 1999.
    return v5;
}

// Generated as internal constructor for term pulley_xneg64.
pub fn constructor_pulley_xneg64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xneg64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2006.
    return v5;
}

// Generated as internal constructor for term pulley_xeq64.
pub fn constructor_pulley_xeq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xeq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2013.
    return v6;
}

// Generated as internal constructor for term pulley_xneq64.
pub fn constructor_pulley_xneq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xneq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2020.
    return v6;
}

// Generated as internal constructor for term pulley_xslt64.
pub fn constructor_pulley_xslt64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslt64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2027.
    return v6;
}

// Generated as internal constructor for term pulley_xslteq64.
pub fn constructor_pulley_xslteq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2034.
    return v6;
}

// Generated as internal constructor for term pulley_xult64.
pub fn constructor_pulley_xult64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xult64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2041.
    return v6;
}

// Generated as internal constructor for term pulley_xulteq64.
pub fn constructor_pulley_xulteq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xulteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2048.
    return v6;
}

// Generated as internal constructor for term pulley_xeq32.
pub fn constructor_pulley_xeq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xeq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2055.
    return v6;
}

// Generated as internal constructor for term pulley_xneq32.
pub fn constructor_pulley_xneq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xneq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2062.
    return v6;
}

// Generated as internal constructor for term pulley_xslt32.
pub fn constructor_pulley_xslt32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslt32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2069.
    return v6;
}

// Generated as internal constructor for term pulley_xslteq32.
pub fn constructor_pulley_xslteq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2076.
    return v6;
}

// Generated as internal constructor for term pulley_xult32.
pub fn constructor_pulley_xult32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xult32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2083.
    return v6;
}

// Generated as internal constructor for term pulley_xulteq32.
pub fn constructor_pulley_xulteq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xulteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2090.
    return v6;
}

// Generated as internal constructor for term pulley_xload8_u32_o32.
pub fn constructor_pulley_xload8_u32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2097.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_o32.
pub fn constructor_pulley_xload8_s32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2104.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_o32.
pub fn constructor_pulley_xload16le_u32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2111.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_o32.
pub fn constructor_pulley_xload16le_s32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2118.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_o32.
pub fn constructor_pulley_xload32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2125.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_o32.
pub fn constructor_pulley_xload64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2132.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_o32.
pub fn constructor_pulley_xstore8_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8O32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2139.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_o32.
pub fn constructor_pulley_xstore16le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2141.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_o32.
pub fn constructor_pulley_xstore32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2143.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_o32.
pub fn constructor_pulley_xstore64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2145.
    return v4;
}

// Generated as internal constructor for term pulley_xload8_u32_z.
pub fn constructor_pulley_xload8_u32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2147.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_z.
pub fn constructor_pulley_xload8_s32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2154.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_z.
pub fn constructor_pulley_xload16le_u32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2161.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_z.
pub fn constructor_pulley_xload16le_s32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2168.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_z.
pub fn constructor_pulley_xload32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2175.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_z.
pub fn constructor_pulley_xload64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2182.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_z.
pub fn constructor_pulley_xstore8_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8Z {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2189.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_z.
pub fn constructor_pulley_xstore16le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2191.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_z.
pub fn constructor_pulley_xstore32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2193.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_z.
pub fn constructor_pulley_xstore64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2195.
    return v4;
}

// Generated as internal constructor for term pulley_xload8_u32_g32.
pub fn constructor_pulley_xload8_u32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2197.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_g32.
pub fn constructor_pulley_xload8_s32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2204.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_g32.
pub fn constructor_pulley_xload16le_u32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2211.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_g32.
pub fn constructor_pulley_xload16le_s32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2218.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_g32.
pub fn constructor_pulley_xload32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2225.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_g32.
pub fn constructor_pulley_xload64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2232.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_g32.
pub fn constructor_pulley_xstore8_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8G32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2239.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_g32.
pub fn constructor_pulley_xstore16le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2241.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_g32.
pub fn constructor_pulley_xstore32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2243.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_g32.
pub fn constructor_pulley_xstore64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2245.
    return v4;
}

// Generated as internal constructor for term pulley_xload8_u32_g32bne.
pub fn constructor_pulley_xload8_u32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2247.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_g32bne.
pub fn constructor_pulley_xload8_s32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2254.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_g32bne.
pub fn constructor_pulley_xload16le_u32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2261.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_g32bne.
pub fn constructor_pulley_xload16le_s32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2268.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_g32bne.
pub fn constructor_pulley_xload32le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeG32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2275.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_g32bne.
pub fn constructor_pulley_xload64le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeG32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2282.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_g32bne.
pub fn constructor_pulley_xstore8_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8G32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2289.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_g32bne.
pub fn constructor_pulley_xstore16le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeG32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2291.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_g32bne.
pub fn constructor_pulley_xstore32le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeG32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2293.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_g32bne.
pub fn constructor_pulley_xstore64le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeG32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2295.
    return v4;
}

// Generated as internal constructor for term pulley_push_frame.
pub fn constructor_pulley_push_frame<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::PushFrame);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2297.
    return v2;
}

// Generated as internal constructor for term pulley_pop_frame.
pub fn constructor_pulley_pop_frame<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::PopFrame);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2299.
    return v2;
}

// Generated as internal constructor for term pulley_push_frame_save.
pub fn constructor_pulley_push_frame_save<C: Context>(
    ctx: &mut C,
    arg0: u16,
    arg1: UpperXRegSet,
) -> SideEffectNoResult {
    let v2 = RawInst::PushFrameSave {
        amt: arg0,
        regs: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2301.
    return v4;
}

// Generated as internal constructor for term pulley_pop_frame_restore.
pub fn constructor_pulley_pop_frame_restore<C: Context>(
    ctx: &mut C,
    arg0: u16,
    arg1: UpperXRegSet,
) -> SideEffectNoResult {
    let v2 = RawInst::PopFrameRestore {
        amt: arg0,
        regs: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2303.
    return v4;
}

// Generated as internal constructor for term pulley_stack_alloc32.
pub fn constructor_pulley_stack_alloc32<C: Context>(
    ctx: &mut C,
    arg0: u32,
) -> SideEffectNoResult {
    let v1 = RawInst::StackAlloc32 {
        amt: arg0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2305.
    return v3;
}

// Generated as internal constructor for term pulley_stack_free32.
pub fn constructor_pulley_stack_free32<C: Context>(
    ctx: &mut C,
    arg0: u32,
) -> SideEffectNoResult {
    let v1 = RawInst::StackFree32 {
        amt: arg0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2307.
    return v3;
}

// Generated as internal constructor for term pulley_zext8.
pub fn constructor_pulley_zext8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Zext8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2309.
    return v5;
}

// Generated as internal constructor for term pulley_zext16.
pub fn constructor_pulley_zext16<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Zext16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2316.
    return v5;
}

// Generated as internal constructor for term pulley_zext32.
pub fn constructor_pulley_zext32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Zext32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2323.
    return v5;
}

// Generated as internal constructor for term pulley_sext8.
pub fn constructor_pulley_sext8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Sext8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2330.
    return v5;
}

// Generated as internal constructor for term pulley_sext16.
pub fn constructor_pulley_sext16<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Sext16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2337.
    return v5;
}

// Generated as internal constructor for term pulley_sext32.
pub fn constructor_pulley_sext32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Sext32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2344.
    return v5;
}

// Generated as internal constructor for term pulley_xabs32.
pub fn constructor_pulley_xabs32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XAbs32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2351.
    return v5;
}

// Generated as internal constructor for term pulley_xabs64.
pub fn constructor_pulley_xabs64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XAbs64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2358.
    return v5;
}

// Generated as internal constructor for term pulley_xdiv32_s.
pub fn constructor_pulley_xdiv32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2365.
    return v6;
}

// Generated as internal constructor for term pulley_xdiv64_s.
pub fn constructor_pulley_xdiv64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2372.
    return v6;
}

// Generated as internal constructor for term pulley_xdiv32_u.
pub fn constructor_pulley_xdiv32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2379.
    return v6;
}

// Generated as internal constructor for term pulley_xdiv64_u.
pub fn constructor_pulley_xdiv64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2386.
    return v6;
}

// Generated as internal constructor for term pulley_xrem32_s.
pub fn constructor_pulley_xrem32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2393.
    return v6;
}

// Generated as internal constructor for term pulley_xrem64_s.
pub fn constructor_pulley_xrem64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2400.
    return v6;
}

// Generated as internal constructor for term pulley_xrem32_u.
pub fn constructor_pulley_xrem32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2407.
    return v6;
}

// Generated as internal constructor for term pulley_xrem64_u.
pub fn constructor_pulley_xrem64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2414.
    return v6;
}

// Generated as internal constructor for term pulley_xband32.
pub fn constructor_pulley_xband32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBand32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2421.
    return v6;
}

// Generated as internal constructor for term pulley_xband32_s8.
pub fn constructor_pulley_xband32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2428.
    return v6;
}

// Generated as internal constructor for term pulley_xband32_s32.
pub fn constructor_pulley_xband32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2435.
    return v6;
}

// Generated as internal constructor for term pulley_xband64.
pub fn constructor_pulley_xband64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBand64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2442.
    return v6;
}

// Generated as internal constructor for term pulley_xband64_s8.
pub fn constructor_pulley_xband64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2449.
    return v6;
}

// Generated as internal constructor for term pulley_xband64_s32.
pub fn constructor_pulley_xband64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2456.
    return v6;
}

// Generated as internal constructor for term pulley_xbor32.
pub fn constructor_pulley_xbor32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBor32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2463.
    return v6;
}

// Generated as internal constructor for term pulley_xbor32_s8.
pub fn constructor_pulley_xbor32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2470.
    return v6;
}

// Generated as internal constructor for term pulley_xbor32_s32.
pub fn constructor_pulley_xbor32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2477.
    return v6;
}

// Generated as internal constructor for term pulley_xbor64.
pub fn constructor_pulley_xbor64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBor64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2484.
    return v6;
}

// Generated as internal constructor for term pulley_xbor64_s8.
pub fn constructor_pulley_xbor64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2491.
    return v6;
}

// Generated as internal constructor for term pulley_xbor64_s32.
pub fn constructor_pulley_xbor64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2498.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor32.
pub fn constructor_pulley_xbxor32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBxor32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2505.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor32_s8.
pub fn constructor_pulley_xbxor32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2512.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor32_s32.
pub fn constructor_pulley_xbxor32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2519.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor64.
pub fn constructor_pulley_xbxor64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBxor64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2526.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor64_s8.
pub fn constructor_pulley_xbxor64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2533.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor64_s32.
pub fn constructor_pulley_xbxor64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2540.
    return v6;
}

// Generated as internal constructor for term pulley_xbnot32.
pub fn constructor_pulley_xbnot32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XBnot32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2547.
    return v5;
}

// Generated as internal constructor for term pulley_xbnot64.
pub fn constructor_pulley_xbnot64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XBnot64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2554.
    return v5;
}

// Generated as internal constructor for term pulley_xmin32_u.
pub fn constructor_pulley_xmin32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2561.
    return v6;
}

// Generated as internal constructor for term pulley_xmin32_s.
pub fn constructor_pulley_xmin32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2568.
    return v6;
}

// Generated as internal constructor for term pulley_xmax32_u.
pub fn constructor_pulley_xmax32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2575.
    return v6;
}

// Generated as internal constructor for term pulley_xmax32_s.
pub fn constructor_pulley_xmax32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2582.
    return v6;
}

// Generated as internal constructor for term pulley_xmin64_u.
pub fn constructor_pulley_xmin64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2589.
    return v6;
}

// Generated as internal constructor for term pulley_xmin64_s.
pub fn constructor_pulley_xmin64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2596.
    return v6;
}

// Generated as internal constructor for term pulley_xmax64_u.
pub fn constructor_pulley_xmax64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2603.
    return v6;
}

// Generated as internal constructor for term pulley_xmax64_s.
pub fn constructor_pulley_xmax64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2610.
    return v6;
}

// Generated as internal constructor for term pulley_xselect32.
pub fn constructor_pulley_xselect32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::XSelect32 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2617.
    return v7;
}

// Generated as internal constructor for term pulley_xselect64.
pub fn constructor_pulley_xselect64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::XSelect64 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2624.
    return v7;
}

// Generated as internal constructor for term pulley_trap.
pub fn constructor_pulley_trap<C: Context>(
    ctx: &mut C,
    arg0: &TrapCode,
) -> SideEffectNoResult {
    let v1 = RawInst::Trap {
        code: arg0.clone(),
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2631.
    return v3;
}

// Generated as internal constructor for term pulley_nop.
pub fn constructor_pulley_nop<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::Nop);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2633.
    return v2;
}

// Generated as internal constructor for term pulley_xpcadd.
pub fn constructor_pulley_xpcadd<C: Context>(
    ctx: &mut C,
    arg0: PcRelOffset,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xpcadd {
        dst: v1,
        offset: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2635.
    return v5;
}

// Generated as internal constructor for term pulley_xmov_fp.
pub fn constructor_pulley_xmov_fp<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::XmovFp {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2642.
    return v4;
}

// Generated as internal constructor for term pulley_xmov_lr.
pub fn constructor_pulley_xmov_lr<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::XmovLr {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2649.
    return v4;
}

// Generated as internal constructor for term pulley_bswap32.
pub fn constructor_pulley_bswap32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Bswap32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2656.
    return v5;
}

// Generated as internal constructor for term pulley_bswap64.
pub fn constructor_pulley_bswap64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Bswap64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2663.
    return v5;
}

// Generated as internal constructor for term pulley_xadd32_uoverflow_trap.
pub fn constructor_pulley_xadd32_uoverflow_trap<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: &TrapCode,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xadd32UoverflowTrap {
        dst: v3,
        src1: arg0,
        src2: arg1,
        code: arg2.clone(),
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2670.
    return v7;
}

// Generated as internal constructor for term pulley_xadd64_uoverflow_trap.
pub fn constructor_pulley_xadd64_uoverflow_trap<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: &TrapCode,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xadd64UoverflowTrap {
        dst: v3,
        src1: arg0,
        src2: arg1,
        code: arg2.clone(),
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2677.
    return v7;
}

// Generated as internal constructor for term pulley_xmulhi64_s.
pub fn constructor_pulley_xmulhi64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMulHi64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2684.
    return v6;
}

// Generated as internal constructor for term pulley_xmulhi64_u.
pub fn constructor_pulley_xmulhi64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMulHi64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2691.
    return v6;
}

// Generated as internal constructor for term pulley_xbmask32.
pub fn constructor_pulley_xbmask32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xbmask32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2698.
    return v5;
}

// Generated as internal constructor for term pulley_xbmask64.
pub fn constructor_pulley_xbmask64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xbmask64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2705.
    return v5;
}

// Generated as internal constructor for term pulley_xload16be_u32_o32.
pub fn constructor_pulley_xload16be_u32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16BeU32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2712.
    return v5;
}

// Generated as internal constructor for term pulley_xload16be_s32_o32.
pub fn constructor_pulley_xload16be_s32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16BeS32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2719.
    return v5;
}

// Generated as internal constructor for term pulley_xload32be_o32.
pub fn constructor_pulley_xload32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2726.
    return v5;
}

// Generated as internal constructor for term pulley_xload64be_o32.
pub fn constructor_pulley_xload64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2733.
    return v5;
}

// Generated as internal constructor for term pulley_xstore16be_o32.
pub fn constructor_pulley_xstore16be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2740.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32be_o32.
pub fn constructor_pulley_xstore32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2742.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64be_o32.
pub fn constructor_pulley_xstore64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2744.
    return v4;
}

// Generated as internal constructor for term pulley_fload32be_o32.
pub fn constructor_pulley_fload32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2746.
    return v5;
}

// Generated as internal constructor for term pulley_fload64be_o32.
pub fn constructor_pulley_fload64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2753.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32be_o32.
pub fn constructor_pulley_fstore32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2760.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64be_o32.
pub fn constructor_pulley_fstore64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2762.
    return v4;
}

// Generated as internal constructor for term pulley_fload32le_o32.
pub fn constructor_pulley_fload32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2764.
    return v5;
}

// Generated as internal constructor for term pulley_fload64le_o32.
pub fn constructor_pulley_fload64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2771.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32le_o32.
pub fn constructor_pulley_fstore32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2778.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64le_o32.
pub fn constructor_pulley_fstore64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2780.
    return v4;
}

// Generated as internal constructor for term pulley_fload32le_z.
pub fn constructor_pulley_fload32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2782.
    return v5;
}

// Generated as internal constructor for term pulley_fload64le_z.
pub fn constructor_pulley_fload64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2789.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32le_z.
pub fn constructor_pulley_fstore32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2796.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64le_z.
pub fn constructor_pulley_fstore64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2798.
    return v4;
}

// Generated as internal constructor for term pulley_fload32le_g32.
pub fn constructor_pulley_fload32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2800.
    return v5;
}

// Generated as internal constructor for term pulley_fload64le_g32.
pub fn constructor_pulley_fload64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2807.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32le_g32.
pub fn constructor_pulley_fstore32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2814.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64le_g32.
pub fn constructor_pulley_fstore64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2816.
    return v4;
}

// Generated as internal constructor for term pulley_vload128le_o32.
pub fn constructor_pulley_vload128le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad128O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2818.
    return v5;
}

// Generated as internal constructor for term pulley_vstore128le_o32.
pub fn constructor_pulley_vstore128le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: VReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Vstore128LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2825.
    return v4;
}

// Generated as internal constructor for term pulley_vload128le_z.
pub fn constructor_pulley_vload128le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad128Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2827.
    return v5;
}

// Generated as internal constructor for term pulley_vstore128le_z.
pub fn constructor_pulley_vstore128le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: VReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Vstore128LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2834.
    return v4;
}

// Generated as internal constructor for term pulley_vload128le_g32.
pub fn constructor_pulley_vload128le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad128G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2836.
    return v5;
}

// Generated as internal constructor for term pulley_vstore128le_g32.
pub fn constructor_pulley_vstore128le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: VReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Vstore128LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>/pulley_gen.isle line 2843.
    return v4;
}

// Generated as internal constructor for term pulley_fmov.
pub fn constructor_pulley_fmov<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fmov {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2845.
    return v5;
}

// Generated as internal constructor for term pulley_vmov.
pub fn constructor_pulley_vmov<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vmov {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2852.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_int_from_float_32.
pub fn constructor_pulley_bitcast_int_from_float_32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::BitcastIntFromFloat32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2859.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_int_from_float_64.
pub fn constructor_pulley_bitcast_int_from_float_64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::BitcastIntFromFloat64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2866.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_float_from_int_32.
pub fn constructor_pulley_bitcast_float_from_int_32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::BitcastFloatFromInt32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2873.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_float_from_int_64.
pub fn constructor_pulley_bitcast_float_from_int_64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::BitcastFloatFromInt64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2880.
    return v5;
}

// Generated as internal constructor for term pulley_fconst32.
pub fn constructor_pulley_fconst32<C: Context>(
    ctx: &mut C,
    arg0: u32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::FConst32 {
        dst: v1,
        bits: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2887.
    return v5;
}

// Generated as internal constructor for term pulley_fconst64.
pub fn constructor_pulley_fconst64<C: Context>(
    ctx: &mut C,
    arg0: u64,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::FConst64 {
        dst: v1,
        bits: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2894.
    return v5;
}

// Generated as internal constructor for term pulley_feq32.
pub fn constructor_pulley_feq32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Feq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2901.
    return v6;
}

// Generated as internal constructor for term pulley_fneq32.
pub fn constructor_pulley_fneq32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Fneq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2908.
    return v6;
}

// Generated as internal constructor for term pulley_flt32.
pub fn constructor_pulley_flt32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flt32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2915.
    return v6;
}

// Generated as internal constructor for term pulley_flteq32.
pub fn constructor_pulley_flteq32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2922.
    return v6;
}

// Generated as internal constructor for term pulley_feq64.
pub fn constructor_pulley_feq64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Feq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2929.
    return v6;
}

// Generated as internal constructor for term pulley_fneq64.
pub fn constructor_pulley_fneq64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Fneq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2936.
    return v6;
}

// Generated as internal constructor for term pulley_flt64.
pub fn constructor_pulley_flt64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flt64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2943.
    return v6;
}

// Generated as internal constructor for term pulley_flteq64.
pub fn constructor_pulley_flteq64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2950.
    return v6;
}

// Generated as internal constructor for term pulley_fselect32.
pub fn constructor_pulley_fselect32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: FReg,
    arg2: FReg,
) -> FReg {
    let v3 = constructor_temp_writable_freg(ctx);
    let v4 = RawInst::FSelect32 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_freg_to_freg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2957.
    return v7;
}

// Generated as internal constructor for term pulley_fselect64.
pub fn constructor_pulley_fselect64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: FReg,
    arg2: FReg,
) -> FReg {
    let v3 = constructor_temp_writable_freg(ctx);
    let v4 = RawInst::FSelect64 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_freg_to_freg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2964.
    return v7;
}

// Generated as internal constructor for term pulley_f32_from_f64.
pub fn constructor_pulley_f32_from_f64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromF64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2971.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_f32.
pub fn constructor_pulley_f64_from_f32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromF32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2978.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x32_s.
pub fn constructor_pulley_f32_from_x32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2985.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x32_u.
pub fn constructor_pulley_f32_from_x32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2992.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x64_s.
pub fn constructor_pulley_f32_from_x64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 2999.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x64_u.
pub fn constructor_pulley_f32_from_x64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3006.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x32_s.
pub fn constructor_pulley_f64_from_x32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3013.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x32_u.
pub fn constructor_pulley_f64_from_x32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3020.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x64_s.
pub fn constructor_pulley_f64_from_x64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3027.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x64_u.
pub fn constructor_pulley_f64_from_x64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3034.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_s.
pub fn constructor_pulley_x32_from_f32_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3041.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_u.
pub fn constructor_pulley_x32_from_f32_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3048.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_s.
pub fn constructor_pulley_x32_from_f64_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3055.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_u.
pub fn constructor_pulley_x32_from_f64_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3062.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_s.
pub fn constructor_pulley_x64_from_f32_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3069.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_u.
pub fn constructor_pulley_x64_from_f32_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3076.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_s.
pub fn constructor_pulley_x64_from_f64_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3083.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_u.
pub fn constructor_pulley_x64_from_f64_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3090.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_s_sat.
pub fn constructor_pulley_x32_from_f32_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3097.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_u_sat.
pub fn constructor_pulley_x32_from_f32_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3104.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_s_sat.
pub fn constructor_pulley_x32_from_f64_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3111.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_u_sat.
pub fn constructor_pulley_x32_from_f64_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3118.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_s_sat.
pub fn constructor_pulley_x64_from_f32_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3125.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_u_sat.
pub fn constructor_pulley_x64_from_f32_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3132.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_s_sat.
pub fn constructor_pulley_x64_from_f64_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3139.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_u_sat.
pub fn constructor_pulley_x64_from_f64_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3146.
    return v5;
}

// Generated as internal constructor for term pulley_fcopysign32.
pub fn constructor_pulley_fcopysign32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FCopySign32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3153.
    return v6;
}

// Generated as internal constructor for term pulley_fcopysign64.
pub fn constructor_pulley_fcopysign64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FCopySign64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3160.
    return v6;
}

// Generated as internal constructor for term pulley_fadd32.
pub fn constructor_pulley_fadd32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fadd32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3167.
    return v6;
}

// Generated as internal constructor for term pulley_fsub32.
pub fn constructor_pulley_fsub32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fsub32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3174.
    return v6;
}

// Generated as internal constructor for term pulley_vsubf32x4.
pub fn constructor_pulley_vsubf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vsubf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3181.
    return v6;
}

// Generated as internal constructor for term pulley_fmul32.
pub fn constructor_pulley_fmul32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmul32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3188.
    return v6;
}

// Generated as internal constructor for term pulley_vmulf32x4.
pub fn constructor_pulley_vmulf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmulf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3195.
    return v6;
}

// Generated as internal constructor for term pulley_fdiv32.
pub fn constructor_pulley_fdiv32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fdiv32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3202.
    return v6;
}

// Generated as internal constructor for term pulley_vdivf32x4.
pub fn constructor_pulley_vdivf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vdivf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3209.
    return v6;
}

// Generated as internal constructor for term pulley_fmaximum32.
pub fn constructor_pulley_fmaximum32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmaximum32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3216.
    return v6;
}

// Generated as internal constructor for term pulley_fminimum32.
pub fn constructor_pulley_fminimum32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fminimum32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3223.
    return v6;
}

// Generated as internal constructor for term pulley_ftrunc32.
pub fn constructor_pulley_ftrunc32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ftrunc32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3230.
    return v5;
}

// Generated as internal constructor for term pulley_vtrunc32x4.
pub fn constructor_pulley_vtrunc32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vtrunc32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3237.
    return v5;
}

// Generated as internal constructor for term pulley_vtrunc64x2.
pub fn constructor_pulley_vtrunc64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vtrunc64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3244.
    return v5;
}

// Generated as internal constructor for term pulley_ffloor32.
pub fn constructor_pulley_ffloor32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ffloor32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3251.
    return v5;
}

// Generated as internal constructor for term pulley_vfloor32x4.
pub fn constructor_pulley_vfloor32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vfloor32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3258.
    return v5;
}

// Generated as internal constructor for term pulley_vfloor64x2.
pub fn constructor_pulley_vfloor64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vfloor64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3265.
    return v5;
}

// Generated as internal constructor for term pulley_fceil32.
pub fn constructor_pulley_fceil32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fceil32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3272.
    return v5;
}

// Generated as internal constructor for term pulley_vceil32x4.
pub fn constructor_pulley_vceil32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vceil32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3279.
    return v5;
}

// Generated as internal constructor for term pulley_vceil64x2.
pub fn constructor_pulley_vceil64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vceil64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3286.
    return v5;
}

// Generated as internal constructor for term pulley_fnearest32.
pub fn constructor_pulley_fnearest32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fnearest32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3293.
    return v5;
}

// Generated as internal constructor for term pulley_fsqrt32.
pub fn constructor_pulley_fsqrt32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fsqrt32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3300.
    return v5;
}

// Generated as internal constructor for term pulley_vsqrt32x4.
pub fn constructor_pulley_vsqrt32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vsqrt32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3307.
    return v5;
}

// Generated as internal constructor for term pulley_vsqrt64x2.
pub fn constructor_pulley_vsqrt64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vsqrt64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3314.
    return v5;
}

// Generated as internal constructor for term pulley_fneg32.
pub fn constructor_pulley_fneg32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fneg32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3321.
    return v5;
}

// Generated as internal constructor for term pulley_vnegf32x4.
pub fn constructor_pulley_vnegf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vnegf32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3328.
    return v5;
}

// Generated as internal constructor for term pulley_fabs32.
pub fn constructor_pulley_fabs32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fabs32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3335.
    return v5;
}

// Generated as internal constructor for term pulley_fadd64.
pub fn constructor_pulley_fadd64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fadd64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3342.
    return v6;
}

// Generated as internal constructor for term pulley_fsub64.
pub fn constructor_pulley_fsub64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fsub64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3349.
    return v6;
}

// Generated as internal constructor for term pulley_fmul64.
pub fn constructor_pulley_fmul64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmul64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3356.
    return v6;
}

// Generated as internal constructor for term pulley_fdiv64.
pub fn constructor_pulley_fdiv64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fdiv64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3363.
    return v6;
}

// Generated as internal constructor for term pulley_vdivf64x2.
pub fn constructor_pulley_vdivf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VDivF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3370.
    return v6;
}

// Generated as internal constructor for term pulley_fmaximum64.
pub fn constructor_pulley_fmaximum64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmaximum64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3377.
    return v6;
}

// Generated as internal constructor for term pulley_fminimum64.
pub fn constructor_pulley_fminimum64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fminimum64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3384.
    return v6;
}

// Generated as internal constructor for term pulley_ftrunc64.
pub fn constructor_pulley_ftrunc64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ftrunc64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3391.
    return v5;
}

// Generated as internal constructor for term pulley_ffloor64.
pub fn constructor_pulley_ffloor64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ffloor64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3398.
    return v5;
}

// Generated as internal constructor for term pulley_fceil64.
pub fn constructor_pulley_fceil64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fceil64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3405.
    return v5;
}

// Generated as internal constructor for term pulley_fnearest64.
pub fn constructor_pulley_fnearest64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fnearest64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3412.
    return v5;
}

// Generated as internal constructor for term pulley_vnearest32x4.
pub fn constructor_pulley_vnearest32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vnearest32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3419.
    return v5;
}

// Generated as internal constructor for term pulley_vnearest64x2.
pub fn constructor_pulley_vnearest64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vnearest64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3426.
    return v5;
}

// Generated as internal constructor for term pulley_fsqrt64.
pub fn constructor_pulley_fsqrt64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fsqrt64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3433.
    return v5;
}

// Generated as internal constructor for term pulley_fneg64.
pub fn constructor_pulley_fneg64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fneg64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3440.
    return v5;
}

// Generated as internal constructor for term pulley_fabs64.
pub fn constructor_pulley_fabs64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fabs64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3447.
    return v5;
}

// Generated as internal constructor for term pulley_vconst128.
pub fn constructor_pulley_vconst128<C: Context>(
    ctx: &mut C,
    arg0: u128,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vconst128 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3454.
    return v5;
}

// Generated as internal constructor for term pulley_vaddi8x16.
pub fn constructor_pulley_vaddi8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3461.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi16x8.
pub fn constructor_pulley_vaddi16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3468.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi32x4.
pub fn constructor_pulley_vaddi32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3475.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi64x2.
pub fn constructor_pulley_vaddi64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3482.
    return v6;
}

// Generated as internal constructor for term pulley_vaddf32x4.
pub fn constructor_pulley_vaddf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3489.
    return v6;
}

// Generated as internal constructor for term pulley_vaddf64x2.
pub fn constructor_pulley_vaddf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3496.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi8x16_sat.
pub fn constructor_pulley_vaddi8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3503.
    return v6;
}

// Generated as internal constructor for term pulley_vaddu8x16_sat.
pub fn constructor_pulley_vaddu8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddU8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3510.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi16x8_sat.
pub fn constructor_pulley_vaddi16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3517.
    return v6;
}

// Generated as internal constructor for term pulley_vaddu16x8_sat.
pub fn constructor_pulley_vaddu16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddU16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3524.
    return v6;
}

// Generated as internal constructor for term pulley_vaddpairwisei16x8_s.
pub fn constructor_pulley_vaddpairwisei16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddpairwiseI16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3531.
    return v6;
}

// Generated as internal constructor for term pulley_vaddpairwisei32x4_s.
pub fn constructor_pulley_vaddpairwisei32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddpairwiseI32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3538.
    return v6;
}

// Generated as internal constructor for term pulley_vshli8x16.
pub fn constructor_pulley_vshli8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3545.
    return v6;
}

// Generated as internal constructor for term pulley_vshli16x8.
pub fn constructor_pulley_vshli16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3552.
    return v6;
}

// Generated as internal constructor for term pulley_vshli32x4.
pub fn constructor_pulley_vshli32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3559.
    return v6;
}

// Generated as internal constructor for term pulley_vshli64x2.
pub fn constructor_pulley_vshli64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3566.
    return v6;
}

// Generated as internal constructor for term pulley_vshri8x16_s.
pub fn constructor_pulley_vshri8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI8x16S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3573.
    return v6;
}

// Generated as internal constructor for term pulley_vshri16x8_s.
pub fn constructor_pulley_vshri16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3580.
    return v6;
}

// Generated as internal constructor for term pulley_vshri32x4_s.
pub fn constructor_pulley_vshri32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3587.
    return v6;
}

// Generated as internal constructor for term pulley_vshri64x2_s.
pub fn constructor_pulley_vshri64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI64x2S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3594.
    return v6;
}

// Generated as internal constructor for term pulley_vshri8x16_u.
pub fn constructor_pulley_vshri8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI8x16U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3601.
    return v6;
}

// Generated as internal constructor for term pulley_vshri16x8_u.
pub fn constructor_pulley_vshri16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3608.
    return v6;
}

// Generated as internal constructor for term pulley_vshri32x4_u.
pub fn constructor_pulley_vshri32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3615.
    return v6;
}

// Generated as internal constructor for term pulley_vshri64x2_u.
pub fn constructor_pulley_vshri64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI64x2U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3622.
    return v6;
}

// Generated as internal constructor for term pulley_vsplatx8.
pub fn constructor_pulley_vsplatx8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3629.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatx16.
pub fn constructor_pulley_vsplatx16<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3636.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatx32.
pub fn constructor_pulley_vsplatx32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3643.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatx64.
pub fn constructor_pulley_vsplatx64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3650.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatf32.
pub fn constructor_pulley_vsplatf32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatF32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3657.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatf64.
pub fn constructor_pulley_vsplatf64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatF64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3664.
    return v5;
}

// Generated as internal constructor for term pulley_vload8x8_s_z.
pub fn constructor_pulley_vload8x8_s_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad8x8SZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3671.
    return v5;
}

// Generated as internal constructor for term pulley_vload8x8_u_z.
pub fn constructor_pulley_vload8x8_u_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad8x8UZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3678.
    return v5;
}

// Generated as internal constructor for term pulley_vload16x4le_s_z.
pub fn constructor_pulley_vload16x4le_s_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad16x4LeSZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3685.
    return v5;
}

// Generated as internal constructor for term pulley_vload16x4le_u_z.
pub fn constructor_pulley_vload16x4le_u_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad16x4LeUZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3692.
    return v5;
}

// Generated as internal constructor for term pulley_vload32x2le_s_z.
pub fn constructor_pulley_vload32x2le_s_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad32x2LeSZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3699.
    return v5;
}

// Generated as internal constructor for term pulley_vload32x2le_u_z.
pub fn constructor_pulley_vload32x2le_u_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad32x2LeUZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3706.
    return v5;
}

// Generated as internal constructor for term pulley_vband128.
pub fn constructor_pulley_vband128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VBand128 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3713.
    return v6;
}

// Generated as internal constructor for term pulley_vbor128.
pub fn constructor_pulley_vbor128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VBor128 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3720.
    return v6;
}

// Generated as internal constructor for term pulley_vbxor128.
pub fn constructor_pulley_vbxor128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VBxor128 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3727.
    return v6;
}

// Generated as internal constructor for term pulley_vbnot128.
pub fn constructor_pulley_vbnot128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VBnot128 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3734.
    return v5;
}

// Generated as internal constructor for term pulley_vbitselect128.
pub fn constructor_pulley_vbitselect128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VBitselect128 {
        dst: v3,
        c: arg0,
        x: arg1,
        y: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3741.
    return v7;
}

// Generated as internal constructor for term pulley_vbitmask8x16.
pub fn constructor_pulley_vbitmask8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3748.
    return v5;
}

// Generated as internal constructor for term pulley_vbitmask16x8.
pub fn constructor_pulley_vbitmask16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3755.
    return v5;
}

// Generated as internal constructor for term pulley_vbitmask32x4.
pub fn constructor_pulley_vbitmask32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3762.
    return v5;
}

// Generated as internal constructor for term pulley_vbitmask64x2.
pub fn constructor_pulley_vbitmask64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3769.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue8x16.
pub fn constructor_pulley_valltrue8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3776.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue16x8.
pub fn constructor_pulley_valltrue16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3783.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue32x4.
pub fn constructor_pulley_valltrue32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3790.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue64x2.
pub fn constructor_pulley_valltrue64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3797.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue8x16.
pub fn constructor_pulley_vanytrue8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3804.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue16x8.
pub fn constructor_pulley_vanytrue16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3811.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue32x4.
pub fn constructor_pulley_vanytrue32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3818.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue64x2.
pub fn constructor_pulley_vanytrue64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3825.
    return v5;
}

// Generated as internal constructor for term pulley_vf32x4_from_i32x4_s.
pub fn constructor_pulley_vf32x4_from_i32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF32x4FromI32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3832.
    return v5;
}

// Generated as internal constructor for term pulley_vf32x4_from_i32x4_u.
pub fn constructor_pulley_vf32x4_from_i32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF32x4FromI32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3839.
    return v5;
}

// Generated as internal constructor for term pulley_vf64x2_from_i64x2_s.
pub fn constructor_pulley_vf64x2_from_i64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF64x2FromI64x2S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3846.
    return v5;
}

// Generated as internal constructor for term pulley_vf64x2_from_i64x2_u.
pub fn constructor_pulley_vf64x2_from_i64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF64x2FromI64x2U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3853.
    return v5;
}

// Generated as internal constructor for term pulley_vi32x4_from_f32x4_s.
pub fn constructor_pulley_vi32x4_from_f32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI32x4FromF32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3860.
    return v5;
}

// Generated as internal constructor for term pulley_vi32x4_from_f32x4_u.
pub fn constructor_pulley_vi32x4_from_f32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI32x4FromF32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3867.
    return v5;
}

// Generated as internal constructor for term pulley_vi64x2_from_f64x2_s.
pub fn constructor_pulley_vi64x2_from_f64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI64x2FromF64x2S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3874.
    return v5;
}

// Generated as internal constructor for term pulley_vi64x2_from_f64x2_u.
pub fn constructor_pulley_vi64x2_from_f64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI64x2FromF64x2U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3881.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow8x16_s.
pub fn constructor_pulley_vwidenlow8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow8x16S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3888.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow8x16_u.
pub fn constructor_pulley_vwidenlow8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow8x16U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3895.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow16x8_s.
pub fn constructor_pulley_vwidenlow16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow16x8S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3902.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow16x8_u.
pub fn constructor_pulley_vwidenlow16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow16x8U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3909.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow32x4_s.
pub fn constructor_pulley_vwidenlow32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3916.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow32x4_u.
pub fn constructor_pulley_vwidenlow32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3923.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh8x16_s.
pub fn constructor_pulley_vwidenhigh8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh8x16S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3930.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh8x16_u.
pub fn constructor_pulley_vwidenhigh8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh8x16U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3937.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh16x8_s.
pub fn constructor_pulley_vwidenhigh16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh16x8S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3944.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh16x8_u.
pub fn constructor_pulley_vwidenhigh16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh16x8U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3951.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh32x4_s.
pub fn constructor_pulley_vwidenhigh32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3958.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh32x4_u.
pub fn constructor_pulley_vwidenhigh32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3965.
    return v5;
}

// Generated as internal constructor for term pulley_vnarrow16x8_s.
pub fn constructor_pulley_vnarrow16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3972.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow16x8_u.
pub fn constructor_pulley_vnarrow16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3979.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow32x4_s.
pub fn constructor_pulley_vnarrow32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3986.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow32x4_u.
pub fn constructor_pulley_vnarrow32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 3993.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow64x2_s.
pub fn constructor_pulley_vnarrow64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow64x2S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4000.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow64x2_u.
pub fn constructor_pulley_vnarrow64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow64x2U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4007.
    return v6;
}

// Generated as internal constructor for term pulley_vunarrow64x2_u.
pub fn constructor_pulley_vunarrow64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vunarrow64x2U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4014.
    return v6;
}

// Generated as internal constructor for term pulley_vfpromotelow.
pub fn constructor_pulley_vfpromotelow<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VFpromoteLow {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4021.
    return v5;
}

// Generated as internal constructor for term pulley_vfdemote.
pub fn constructor_pulley_vfdemote<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VFdemote {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4028.
    return v5;
}

// Generated as internal constructor for term pulley_vsubi8x16.
pub fn constructor_pulley_vsubi8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4035.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi16x8.
pub fn constructor_pulley_vsubi16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4042.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi32x4.
pub fn constructor_pulley_vsubi32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4049.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi64x2.
pub fn constructor_pulley_vsubi64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4056.
    return v6;
}

// Generated as internal constructor for term pulley_vsubf64x2.
pub fn constructor_pulley_vsubf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4063.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi8x16_sat.
pub fn constructor_pulley_vsubi8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4070.
    return v6;
}

// Generated as internal constructor for term pulley_vsubu8x16_sat.
pub fn constructor_pulley_vsubu8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubU8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4077.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi16x8_sat.
pub fn constructor_pulley_vsubi16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4084.
    return v6;
}

// Generated as internal constructor for term pulley_vsubu16x8_sat.
pub fn constructor_pulley_vsubu16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubU16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4091.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli8x16.
pub fn constructor_pulley_vmuli8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4098.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli16x8.
pub fn constructor_pulley_vmuli16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4105.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli32x4.
pub fn constructor_pulley_vmuli32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4112.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli64x2.
pub fn constructor_pulley_vmuli64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4119.
    return v6;
}

// Generated as internal constructor for term pulley_vmulf64x2.
pub fn constructor_pulley_vmulf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4126.
    return v6;
}

// Generated as internal constructor for term pulley_vqmulrsi16x8.
pub fn constructor_pulley_vqmulrsi16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VQmulrsI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4133.
    return v6;
}

// Generated as internal constructor for term pulley_vpopcnt8x16.
pub fn constructor_pulley_vpopcnt8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VPopcnt8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4140.
    return v5;
}

// Generated as internal constructor for term pulley_xextractv8x16.
pub fn constructor_pulley_xextractv8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV8x16 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4147.
    return v6;
}

// Generated as internal constructor for term pulley_xextractv16x8.
pub fn constructor_pulley_xextractv16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV16x8 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4154.
    return v6;
}

// Generated as internal constructor for term pulley_xextractv32x4.
pub fn constructor_pulley_xextractv32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV32x4 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4161.
    return v6;
}

// Generated as internal constructor for term pulley_xextractv64x2.
pub fn constructor_pulley_xextractv64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV64x2 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4168.
    return v6;
}

// Generated as internal constructor for term pulley_fextractv32x4.
pub fn constructor_pulley_fextractv32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FExtractV32x4 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4175.
    return v6;
}

// Generated as internal constructor for term pulley_fextractv64x2.
pub fn constructor_pulley_fextractv64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FExtractV64x2 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4182.
    return v6;
}

// Generated as internal constructor for term pulley_vinsertx8.
pub fn constructor_pulley_vinsertx8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX8 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4189.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertx16.
pub fn constructor_pulley_vinsertx16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX16 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4196.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertx32.
pub fn constructor_pulley_vinsertx32<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX32 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4203.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertx64.
pub fn constructor_pulley_vinsertx64<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX64 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4210.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertf32.
pub fn constructor_pulley_vinsertf32<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: FReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertF32 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4217.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertf64.
pub fn constructor_pulley_vinsertf64<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: FReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertF64 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4224.
    return v7;
}

// Generated as internal constructor for term pulley_veq8x16.
pub fn constructor_pulley_veq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4231.
    return v6;
}

// Generated as internal constructor for term pulley_vneq8x16.
pub fn constructor_pulley_vneq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4238.
    return v6;
}

// Generated as internal constructor for term pulley_vslt8x16.
pub fn constructor_pulley_vslt8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4245.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq8x16.
pub fn constructor_pulley_vslteq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4252.
    return v6;
}

// Generated as internal constructor for term pulley_vult8x16.
pub fn constructor_pulley_vult8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4259.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq8x16.
pub fn constructor_pulley_vulteq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4266.
    return v6;
}

// Generated as internal constructor for term pulley_veq16x8.
pub fn constructor_pulley_veq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4273.
    return v6;
}

// Generated as internal constructor for term pulley_vneq16x8.
pub fn constructor_pulley_vneq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4280.
    return v6;
}

// Generated as internal constructor for term pulley_vslt16x8.
pub fn constructor_pulley_vslt16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4287.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq16x8.
pub fn constructor_pulley_vslteq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4294.
    return v6;
}

// Generated as internal constructor for term pulley_vult16x8.
pub fn constructor_pulley_vult16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4301.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq16x8.
pub fn constructor_pulley_vulteq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4308.
    return v6;
}

// Generated as internal constructor for term pulley_veq32x4.
pub fn constructor_pulley_veq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4315.
    return v6;
}

// Generated as internal constructor for term pulley_vneq32x4.
pub fn constructor_pulley_vneq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4322.
    return v6;
}

// Generated as internal constructor for term pulley_vslt32x4.
pub fn constructor_pulley_vslt32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4329.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq32x4.
pub fn constructor_pulley_vslteq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4336.
    return v6;
}

// Generated as internal constructor for term pulley_vult32x4.
pub fn constructor_pulley_vult32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4343.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq32x4.
pub fn constructor_pulley_vulteq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4350.
    return v6;
}

// Generated as internal constructor for term pulley_veq64x2.
pub fn constructor_pulley_veq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4357.
    return v6;
}

// Generated as internal constructor for term pulley_vneq64x2.
pub fn constructor_pulley_vneq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4364.
    return v6;
}

// Generated as internal constructor for term pulley_vslt64x2.
pub fn constructor_pulley_vslt64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4371.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq64x2.
pub fn constructor_pulley_vslteq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4378.
    return v6;
}

// Generated as internal constructor for term pulley_vult64x2.
pub fn constructor_pulley_vult64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4385.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq64x2.
pub fn constructor_pulley_vulteq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4392.
    return v6;
}

// Generated as internal constructor for term pulley_vneg8x16.
pub fn constructor_pulley_vneg8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4399.
    return v5;
}

// Generated as internal constructor for term pulley_vneg16x8.
pub fn constructor_pulley_vneg16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4406.
    return v5;
}

// Generated as internal constructor for term pulley_vneg32x4.
pub fn constructor_pulley_vneg32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4413.
    return v5;
}

// Generated as internal constructor for term pulley_vneg64x2.
pub fn constructor_pulley_vneg64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4420.
    return v5;
}

// Generated as internal constructor for term pulley_vnegf64x2.
pub fn constructor_pulley_vnegf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VnegF64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4427.
    return v5;
}

// Generated as internal constructor for term pulley_vmin8x16_s.
pub fn constructor_pulley_vmin8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin8x16S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4434.
    return v6;
}

// Generated as internal constructor for term pulley_vmin8x16_u.
pub fn constructor_pulley_vmin8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin8x16U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4441.
    return v6;
}

// Generated as internal constructor for term pulley_vmin16x8_s.
pub fn constructor_pulley_vmin16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4448.
    return v6;
}

// Generated as internal constructor for term pulley_vmin16x8_u.
pub fn constructor_pulley_vmin16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4455.
    return v6;
}

// Generated as internal constructor for term pulley_vmax8x16_s.
pub fn constructor_pulley_vmax8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax8x16S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4462.
    return v6;
}

// Generated as internal constructor for term pulley_vmax8x16_u.
pub fn constructor_pulley_vmax8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax8x16U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4469.
    return v6;
}

// Generated as internal constructor for term pulley_vmax16x8_s.
pub fn constructor_pulley_vmax16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4476.
    return v6;
}

// Generated as internal constructor for term pulley_vmax16x8_u.
pub fn constructor_pulley_vmax16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4483.
    return v6;
}

// Generated as internal constructor for term pulley_vmin32x4_s.
pub fn constructor_pulley_vmin32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4490.
    return v6;
}

// Generated as internal constructor for term pulley_vmin32x4_u.
pub fn constructor_pulley_vmin32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4497.
    return v6;
}

// Generated as internal constructor for term pulley_vmax32x4_s.
pub fn constructor_pulley_vmax32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4504.
    return v6;
}

// Generated as internal constructor for term pulley_vmax32x4_u.
pub fn constructor_pulley_vmax32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4511.
    return v6;
}

// Generated as internal constructor for term pulley_vabs8x16.
pub fn constructor_pulley_vabs8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4518.
    return v5;
}

// Generated as internal constructor for term pulley_vabs16x8.
pub fn constructor_pulley_vabs16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4525.
    return v5;
}

// Generated as internal constructor for term pulley_vabs32x4.
pub fn constructor_pulley_vabs32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4532.
    return v5;
}

// Generated as internal constructor for term pulley_vabs64x2.
pub fn constructor_pulley_vabs64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4539.
    return v5;
}

// Generated as internal constructor for term pulley_vabsf32x4.
pub fn constructor_pulley_vabsf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabsf32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4546.
    return v5;
}

// Generated as internal constructor for term pulley_vabsf64x2.
pub fn constructor_pulley_vabsf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabsf64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4553.
    return v5;
}

// Generated as internal constructor for term pulley_vmaximumf32x4.
pub fn constructor_pulley_vmaximumf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmaximumf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4560.
    return v6;
}

// Generated as internal constructor for term pulley_vmaximumf64x2.
pub fn constructor_pulley_vmaximumf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmaximumf64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4567.
    return v6;
}

// Generated as internal constructor for term pulley_vminimumf32x4.
pub fn constructor_pulley_vminimumf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vminimumf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4574.
    return v6;
}

// Generated as internal constructor for term pulley_vminimumf64x2.
pub fn constructor_pulley_vminimumf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vminimumf64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4581.
    return v6;
}

// Generated as internal constructor for term pulley_vshuffle.
pub fn constructor_pulley_vshuffle<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: u128,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VShuffle {
        dst: v3,
        src1: arg0,
        src2: arg1,
        mask: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4588.
    return v7;
}

// Generated as internal constructor for term pulley_vswizzlei8x16.
pub fn constructor_pulley_vswizzlei8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vswizzlei8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4595.
    return v6;
}

// Generated as internal constructor for term pulley_vavground8x16.
pub fn constructor_pulley_vavground8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vavground8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4602.
    return v6;
}

// Generated as internal constructor for term pulley_vavground16x8.
pub fn constructor_pulley_vavground16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vavground16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4609.
    return v6;
}

// Generated as internal constructor for term pulley_veqf32x4.
pub fn constructor_pulley_veqf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VeqF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4616.
    return v6;
}

// Generated as internal constructor for term pulley_vneqf32x4.
pub fn constructor_pulley_vneqf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VneqF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4623.
    return v6;
}

// Generated as internal constructor for term pulley_vltf32x4.
pub fn constructor_pulley_vltf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VltF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4630.
    return v6;
}

// Generated as internal constructor for term pulley_vlteqf32x4.
pub fn constructor_pulley_vlteqf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VlteqF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4637.
    return v6;
}

// Generated as internal constructor for term pulley_veqf64x2.
pub fn constructor_pulley_veqf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VeqF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4644.
    return v6;
}

// Generated as internal constructor for term pulley_vneqf64x2.
pub fn constructor_pulley_vneqf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VneqF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4651.
    return v6;
}

// Generated as internal constructor for term pulley_vltf64x2.
pub fn constructor_pulley_vltf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VltF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4658.
    return v6;
}

// Generated as internal constructor for term pulley_vlteqf64x2.
pub fn constructor_pulley_vlteqf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VlteqF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4665.
    return v6;
}

// Generated as internal constructor for term pulley_vfma32x4.
pub fn constructor_pulley_vfma32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::Vfma32x4 {
        dst: v3,
        a: arg0,
        b: arg1,
        c: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4672.
    return v7;
}

// Generated as internal constructor for term pulley_vfma64x2.
pub fn constructor_pulley_vfma64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::Vfma64x2 {
        dst: v3,
        a: arg0,
        b: arg1,
        c: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4679.
    return v7;
}

// Generated as internal constructor for term pulley_vselect.
pub fn constructor_pulley_vselect<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::Vselect {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4686.
    return v7;
}

// Generated as internal constructor for term pulley_xadd128.
pub fn constructor_pulley_xadd128<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
    arg3: XReg,
) -> ValueRegs {
    let v4 = constructor_temp_writable_xreg(ctx);
    let v5 = constructor_temp_writable_xreg(ctx);
    let v6 = RawInst::Xadd128 {
        dst_lo: v4,
        dst_hi: v5,
        lhs_lo: arg0,
        lhs_hi: arg1,
        rhs_lo: arg2,
        rhs_hi: arg3,
    };
    let v7 = &constructor_raw_inst_to_inst(ctx, &v6);
    let v8 = C::emit(ctx, v7);
    let v9 = constructor_writable_xreg_to_reg(ctx, v4);
    let v10 = constructor_writable_xreg_to_reg(ctx, v5);
    let v11 = C::value_regs(ctx, v9, v10);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4693.
    return v11;
}

// Generated as internal constructor for term pulley_xsub128.
pub fn constructor_pulley_xsub128<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
    arg3: XReg,
) -> ValueRegs {
    let v4 = constructor_temp_writable_xreg(ctx);
    let v5 = constructor_temp_writable_xreg(ctx);
    let v6 = RawInst::Xsub128 {
        dst_lo: v4,
        dst_hi: v5,
        lhs_lo: arg0,
        lhs_hi: arg1,
        rhs_lo: arg2,
        rhs_hi: arg3,
    };
    let v7 = &constructor_raw_inst_to_inst(ctx, &v6);
    let v8 = C::emit(ctx, v7);
    let v9 = constructor_writable_xreg_to_reg(ctx, v4);
    let v10 = constructor_writable_xreg_to_reg(ctx, v5);
    let v11 = C::value_regs(ctx, v9, v10);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4701.
    return v11;
}

// Generated as internal constructor for term pulley_xwidemul64_s.
pub fn constructor_pulley_xwidemul64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> ValueRegs {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xwidemul64S {
        dst_lo: v2,
        dst_hi: v3,
        lhs: arg0,
        rhs: arg1,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = constructor_writable_xreg_to_reg(ctx, v2);
    let v8 = constructor_writable_xreg_to_reg(ctx, v3);
    let v9 = C::value_regs(ctx, v7, v8);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4709.
    return v9;
}

// Generated as internal constructor for term pulley_xwidemul64_u.
pub fn constructor_pulley_xwidemul64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> ValueRegs {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xwidemul64U {
        dst_lo: v2,
        dst_hi: v3,
        lhs: arg0,
        rhs: arg1,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = constructor_writable_xreg_to_reg(ctx, v2);
    let v8 = constructor_writable_xreg_to_reg(ctx, v3);
    let v9 = C::value_regs(ctx, v7, v8);
    // Rule at <OUT_DIR>/pulley_gen.isle line 4717.
    return v9;
}
