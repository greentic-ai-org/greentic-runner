// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod greentic {
  pub mod events {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod event_types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type TenantCtx = super::super::super::greentic::interfaces_types::types::TenantCtx;
      /// Metadata entries preserved end-to-end.
      pub type MetadataEntry = (_rt::String,_rt::String,);
      /// Canonical event envelope shared across providers.
      #[derive(Clone)]
      pub struct EventEnvelope {
        pub id: _rt::String,
        pub topic: _rt::String,
        pub type_: _rt::String,
        pub source: _rt::String,
        pub tenant: TenantCtx,
        pub subject: Option<_rt::String>,
        /// RFC3339 UTC timestamp.
        pub time: _rt::String,
        pub correlation_id: Option<_rt::String>,
        /// JSON payload (opaque to the ABI).
        pub payload_json: _rt::String,
        pub metadata: _rt::Vec::<MetadataEntry>,
      }
      impl ::core::fmt::Debug for EventEnvelope {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EventEnvelope").field("id", &self.id).field("topic", &self.topic).field("type", &self.type_).field("source", &self.source).field("tenant", &self.tenant).field("subject", &self.subject).field("time", &self.time).field("correlation-id", &self.correlation_id).field("payload-json", &self.payload_json).field("metadata", &self.metadata).finish()
        }
      }
      /// A registered subscription handle.
      pub type SubscriptionId = _rt::String;
      /// Source configuration (topic filters, cursor, tenant).
      #[derive(Clone)]
      pub struct SourceConfig {
        pub topics: _rt::Vec::<_rt::String>,
        pub tenant: Option<TenantCtx>,
        pub cursor: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for SourceConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SourceConfig").field("topics", &self.topics).field("tenant", &self.tenant).field("cursor", &self.cursor).finish()
        }
      }
      /// Sink configuration (target topic plus optional tenant override).
      #[derive(Clone)]
      pub struct SinkConfig {
        pub topic: _rt::String,
        pub tenant: Option<TenantCtx>,
      }
      impl ::core::fmt::Debug for SinkConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SinkConfig").field("topic", &self.topic).field("tenant", &self.tenant).finish()
        }
      }
      /// Delivery outcome classification.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum DeliveryStatus {
        Ok,
        RetryableFailure,
        PermanentFailure,
      }
      impl ::core::fmt::Debug for DeliveryStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            DeliveryStatus::Ok => {
              f.debug_tuple("DeliveryStatus::Ok").finish()
            }
            DeliveryStatus::RetryableFailure => {
              f.debug_tuple("DeliveryStatus::RetryableFailure").finish()
            }
            DeliveryStatus::PermanentFailure => {
              f.debug_tuple("DeliveryStatus::PermanentFailure").finish()
            }
          }
        }
      }

      impl DeliveryStatus{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> DeliveryStatus{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => DeliveryStatus::Ok,
            1 => DeliveryStatus::RetryableFailure,
            2 => DeliveryStatus::PermanentFailure,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Delivery result describing the status and optional error.
      #[derive(Clone)]
      pub struct DeliveryResult {
        pub status: DeliveryStatus,
        pub error_code: Option<_rt::String>,
        pub error_message: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for DeliveryResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeliveryResult").field("status", &self.status).field("error-code", &self.error_code).field("error-message", &self.error_message).finish()
        }
      }
      /// Ack behaviour for pull-based subscriptions.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum AckMode {
        Auto,
        Manual,
      }
      impl ::core::fmt::Debug for AckMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            AckMode::Auto => {
              f.debug_tuple("AckMode::Auto").finish()
            }
            AckMode::Manual => {
              f.debug_tuple("AckMode::Manual").finish()
            }
          }
        }
      }

      impl AckMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> AckMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => AckMode::Auto,
            1 => AckMode::Manual,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Subscription tuning knobs.
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct SubscriptionOptions {
        pub durable: bool,
        pub deliver_existing: bool,
        pub ack_mode: AckMode,
      }
      impl ::core::fmt::Debug for SubscriptionOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SubscriptionOptions").field("durable", &self.durable).field("deliver-existing", &self.deliver_existing).field("ack-mode", &self.ack_mode).finish()
        }
      }
      /// Canonical host error payload.
      #[derive(Clone)]
      pub struct HostError {
        pub code: _rt::String,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for HostError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("HostError").field("code", &self.code).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for HostError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for HostError {}
      /// Trivial acknowledgment for operations.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum OpAck {
        Ok,
      }
      impl ::core::fmt::Debug for OpAck {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            OpAck::Ok => {
              f.debug_tuple("OpAck::Ok").finish()
            }
          }
        }
      }

      impl OpAck{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> OpAck{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => OpAck::Ok,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }


    }

  }
  pub mod interfaces_types {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// Environment identifier.
      pub type EnvId = _rt::String;
      /// Tenant identifier propagated across providers.
      pub type TenantId = _rt::String;
      /// Team identifier scoped to a tenant.
      pub type TeamId = _rt::String;
      /// User identifier scoped to a tenant.
      pub type UserId = _rt::String;
      /// Stable key referencing persisted state blobs.
      pub type StateKey = _rt::String;
      /// Stable key referencing sessions.
      pub type SessionKey = _rt::String;
      /// Impersonation context propagated with a tenant.
      #[derive(Clone)]
      pub struct Impersonation {
        pub actor_id: UserId,
        pub reason: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for Impersonation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Impersonation").field("actor-id", &self.actor_id).field("reason", &self.reason).finish()
        }
      }
      /// Invocation tenant context shared across Greentic surfaces.
      #[derive(Clone)]
      pub struct TenantCtx {
        pub env: EnvId,
        pub tenant: TenantId,
        pub tenant_id: TenantId,
        pub team: Option<TeamId>,
        pub team_id: Option<TeamId>,
        pub user: Option<UserId>,
        pub user_id: Option<UserId>,
        pub trace_id: Option<_rt::String>,
        pub correlation_id: Option<_rt::String>,
        pub attributes: _rt::Vec::<(_rt::String,_rt::String,)>,
        pub session_id: Option<_rt::String>,
        pub flow_id: Option<_rt::String>,
        pub node_id: Option<_rt::String>,
        pub provider_id: Option<_rt::String>,
        pub deadline_ms: Option<i64>,
        pub attempt: u32,
        pub idempotency_key: Option<_rt::String>,
        pub impersonation: Option<Impersonation>,
      }
      impl ::core::fmt::Debug for TenantCtx {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TenantCtx").field("env", &self.env).field("tenant", &self.tenant).field("tenant-id", &self.tenant_id).field("team", &self.team).field("team-id", &self.team_id).field("user", &self.user).field("user-id", &self.user_id).field("trace-id", &self.trace_id).field("correlation-id", &self.correlation_id).field("attributes", &self.attributes).field("session-id", &self.session_id).field("flow-id", &self.flow_id).field("node-id", &self.node_id).field("provider-id", &self.provider_id).field("deadline-ms", &self.deadline_ms).field("attempt", &self.attempt).field("idempotency-key", &self.idempotency_key).field("impersonation", &self.impersonation).finish()
        }
      }
      /// Cursor describing a session position.
      #[derive(Clone)]
      pub struct SessionCursor {
        pub node_pointer: _rt::String,
        pub wait_reason: Option<_rt::String>,
        pub outbox_marker: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for SessionCursor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SessionCursor").field("node-pointer", &self.node_pointer).field("wait-reason", &self.wait_reason).field("outbox-marker", &self.outbox_marker).finish()
        }
      }
      /// Canonical error codes surfaced by the platform.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum ErrorCode {
        Unknown,
        InvalidInput,
        NotFound,
        Conflict,
        Timeout,
        Unauthenticated,
        PermissionDenied,
        RateLimited,
        Unavailable,
        Internal,
      }
      impl ::core::fmt::Debug for ErrorCode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ErrorCode::Unknown => {
              f.debug_tuple("ErrorCode::Unknown").finish()
            }
            ErrorCode::InvalidInput => {
              f.debug_tuple("ErrorCode::InvalidInput").finish()
            }
            ErrorCode::NotFound => {
              f.debug_tuple("ErrorCode::NotFound").finish()
            }
            ErrorCode::Conflict => {
              f.debug_tuple("ErrorCode::Conflict").finish()
            }
            ErrorCode::Timeout => {
              f.debug_tuple("ErrorCode::Timeout").finish()
            }
            ErrorCode::Unauthenticated => {
              f.debug_tuple("ErrorCode::Unauthenticated").finish()
            }
            ErrorCode::PermissionDenied => {
              f.debug_tuple("ErrorCode::PermissionDenied").finish()
            }
            ErrorCode::RateLimited => {
              f.debug_tuple("ErrorCode::RateLimited").finish()
            }
            ErrorCode::Unavailable => {
              f.debug_tuple("ErrorCode::Unavailable").finish()
            }
            ErrorCode::Internal => {
              f.debug_tuple("ErrorCode::Internal").finish()
            }
          }
        }
      }

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ErrorCode::Unknown,
            1 => ErrorCode::InvalidInput,
            2 => ErrorCode::NotFound,
            3 => ErrorCode::Conflict,
            4 => ErrorCode::Timeout,
            5 => ErrorCode::Unauthenticated,
            6 => ErrorCode::PermissionDenied,
            7 => ErrorCode::RateLimited,
            8 => ErrorCode::Unavailable,
            9 => ErrorCode::Internal,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Pending outcome payload.
      #[derive(Clone)]
      pub struct OutcomePending {
        pub reason: _rt::String,
        pub expected_input: Option<_rt::Vec::<_rt::String>>,
      }
      impl ::core::fmt::Debug for OutcomePending {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("OutcomePending").field("reason", &self.reason).field("expected-input", &self.expected_input).finish()
        }
      }
      /// Error outcome payload.
      #[derive(Clone)]
      pub struct OutcomeError {
        pub code: ErrorCode,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for OutcomeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("OutcomeError").field("code", &self.code).field("message", &self.message).finish()
        }
      }
      /// Execution outcome for string payloads.
      #[derive(Clone)]
      pub enum Outcome {
        Done(_rt::String),
        Pending(OutcomePending),
        Error(OutcomeError),
      }
      impl ::core::fmt::Debug for Outcome {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Outcome::Done(e) => {
              f.debug_tuple("Outcome::Done").field(e).finish()
            }
            Outcome::Pending(e) => {
              f.debug_tuple("Outcome::Pending").field(e).finish()
            }
            Outcome::Error(e) => {
              f.debug_tuple("Outcome::Error").field(e).finish()
            }
          }
        }
      }
      /// Supported network protocols.
      #[derive(Clone)]
      pub enum Protocol {
        Http,
        Https,
        Tcp,
        Udp,
        Grpc,
        Custom(_rt::String),
      }
      impl ::core::fmt::Debug for Protocol {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Protocol::Http => {
              f.debug_tuple("Protocol::Http").finish()
            }
            Protocol::Https => {
              f.debug_tuple("Protocol::Https").finish()
            }
            Protocol::Tcp => {
              f.debug_tuple("Protocol::Tcp").finish()
            }
            Protocol::Udp => {
              f.debug_tuple("Protocol::Udp").finish()
            }
            Protocol::Grpc => {
              f.debug_tuple("Protocol::Grpc").finish()
            }
            Protocol::Custom(e) => {
              f.debug_tuple("Protocol::Custom").field(e).finish()
            }
          }
        }
      }
      /// Allow list describing permitted connectivity.
      #[derive(Clone)]
      pub struct AllowList {
        pub domains: _rt::Vec::<_rt::String>,
        pub ports: _rt::Vec::<u16>,
        pub protocols: _rt::Vec::<Protocol>,
      }
      impl ::core::fmt::Debug for AllowList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("AllowList").field("domains", &self.domains).field("ports", &self.ports).field("protocols", &self.protocols).finish()
        }
      }
      /// Network policy composed of allow lists.
      #[derive(Clone)]
      pub struct NetworkPolicy {
        pub egress: AllowList,
        pub deny_on_miss: bool,
      }
      impl ::core::fmt::Debug for NetworkPolicy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("NetworkPolicy").field("egress", &self.egress).field("deny-on-miss", &self.deny_on_miss).finish()
        }
      }
      /// Detached signature accompanying a pack.
      #[derive(Clone)]
      pub enum SignatureAlgorithm {
        Ed25519,
        Other(_rt::String),
      }
      impl ::core::fmt::Debug for SignatureAlgorithm {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            SignatureAlgorithm::Ed25519 => {
              f.debug_tuple("SignatureAlgorithm::Ed25519").finish()
            }
            SignatureAlgorithm::Other(e) => {
              f.debug_tuple("SignatureAlgorithm::Other").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct Signature {
        pub key_id: _rt::String,
        pub algorithm: SignatureAlgorithm,
        pub signature: _rt::Vec::<u8>,
      }
      impl ::core::fmt::Debug for Signature {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Signature").field("key-id", &self.key_id).field("algorithm", &self.algorithm).field("signature", &self.signature).finish()
        }
      }
      /// Pack reference stored in registries.
      #[derive(Clone)]
      pub struct PackRef {
        pub oci_url: _rt::String,
        pub version: _rt::String,
        pub digest: _rt::String,
        pub signatures: _rt::Vec::<Signature>,
      }
      impl ::core::fmt::Debug for PackRef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PackRef").field("oci-url", &self.oci_url).field("version", &self.version).field("digest", &self.digest).field("signatures", &self.signatures).finish()
        }
      }
      /// Minimal telemetry span context.
      #[derive(Clone)]
      pub struct SpanContext {
        pub tenant: TenantId,
        pub session_id: Option<SessionKey>,
        pub flow_id: _rt::String,
        pub node_id: Option<_rt::String>,
        pub provider: _rt::String,
        pub start_ms: Option<i64>,
        pub end_ms: Option<i64>,
      }
      impl ::core::fmt::Debug for SpanContext {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SpanContext").field("tenant", &self.tenant).field("session-id", &self.session_id).field("flow-id", &self.flow_id).field("node-id", &self.node_id).field("provider", &self.provider).field("start-ms", &self.start_ms).field("end-ms", &self.end_ms).finish()
        }
      }

    }

  }
  pub mod messaging {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod session_api {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type TenantCtx = super::super::super::greentic::interfaces_types::types::TenantCtx;
      /// Metadata entries preserved across adapters and bridges.
      pub type MetadataEntry = (_rt::String,_rt::String,);
      /// Generic attachment descriptor for channel messages.
      #[derive(Clone)]
      pub struct Attachment {
        pub mime_type: _rt::String,
        pub url: _rt::String,
        pub name: Option<_rt::String>,
        pub size_bytes: Option<u64>,
        pub description: Option<_rt::String>,
        pub metadata: _rt::Vec::<MetadataEntry>,
      }
      impl ::core::fmt::Debug for Attachment {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Attachment").field("mime-type", &self.mime_type).field("url", &self.url).field("name", &self.name).field("size-bytes", &self.size_bytes).field("description", &self.description).field("metadata", &self.metadata).finish()
        }
      }
      /// Provider-agnostic channel message envelope.
      #[derive(Clone)]
      pub struct ChannelMessageEnvelope {
        pub id: _rt::String,
        pub tenant: TenantCtx,
        pub channel: _rt::String,
        pub session_id: _rt::String,
        pub user_id: Option<_rt::String>,
        pub text: Option<_rt::String>,
        pub attachments: _rt::Vec::<Attachment>,
        pub metadata: _rt::Vec::<MetadataEntry>,
      }
      impl ::core::fmt::Debug for ChannelMessageEnvelope {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ChannelMessageEnvelope").field("id", &self.id).field("tenant", &self.tenant).field("channel", &self.channel).field("session-id", &self.session_id).field("user-id", &self.user_id).field("text", &self.text).field("attachments", &self.attachments).field("metadata", &self.metadata).finish()
        }
      }
      /// Canonical host error payload.
      #[derive(Clone)]
      pub struct HostError {
        pub code: _rt::String,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for HostError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("HostError").field("code", &self.code).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for HostError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for HostError {}
      /// Trivial acknowledgment for sends.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum OpAck {
        Ok,
      }
      impl ::core::fmt::Debug for OpAck {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            OpAck::Ok => {
              f.debug_tuple("OpAck::Ok").finish()
            }
          }
        }
      }

      impl OpAck{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> OpAck{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => OpAck::Ok,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Opaque outbound message.
      #[derive(Clone)]
      pub struct OutboundMessage {
        pub route: Option<_rt::String>,
        pub payload_json: _rt::String,
        pub attachments: Option<_rt::Vec::<_rt::Vec::<u8>>>,
      }
      impl ::core::fmt::Debug for OutboundMessage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("OutboundMessage").field("route", &self.route).field("payload-json", &self.payload_json).field("attachments", &self.attachments).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Emits an outbound message for the active session.
      #[allow(async_fn_in_trait)]
      pub fn send(message: &OutboundMessage,ctx: &TenantCtx,) -> Result<OpAck,HostError>{
        unsafe {
          let mut cleanup_list = _rt::Vec::new();

          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 16+56*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16+56*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let OutboundMessage{ route:route1, payload_json:payload_json1, attachments:attachments1, } = message;
          match route1 {
            Some(e) => {
              *ptr0.add(0).cast::<u8>() = (1i32) as u8;
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
              *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
            },
            None => {
              {
                *ptr0.add(0).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec3 = payload_json1;
          let ptr3 = vec3.as_ptr().cast::<u8>();
          let len3 = vec3.len();
          *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
          *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
          match attachments1 {
            Some(e) => {
              *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec5 = e;
              let len5 = vec5.len();
              let layout5 = _rt::alloc::Layout::from_size_align(vec5.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
              let (result5, _cleanup5) = wit_bindgen::rt::Cleanup::new(layout5);cleanup_list.extend(_cleanup5);
              for (i, e) in vec5.into_iter().enumerate() {
                let base = result5.add(i * (2*::core::mem::size_of::<*const u8>()));
                {
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();
                  *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                  *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                }
              }
              *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
              *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result5;
            },
            None => {
              {
                *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };let super::super::super::greentic::interfaces_types::types::TenantCtx{ env:env6, tenant:tenant6, tenant_id:tenant_id6, team:team6, team_id:team_id6, user:user6, user_id:user_id6, trace_id:trace_id6, correlation_id:correlation_id6, attributes:attributes6, session_id:session_id6, flow_id:flow_id6, node_id:node_id6, provider_id:provider_id6, deadline_ms:deadline_ms6, attempt:attempt6, idempotency_key:idempotency_key6, impersonation:impersonation6, } = ctx;
          let vec7 = env6;
          let ptr7 = vec7.as_ptr().cast::<u8>();
          let len7 = vec7.len();
          *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
          *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
          let vec8 = tenant6;
          let ptr8 = vec8.as_ptr().cast::<u8>();
          let len8 = vec8.len();
          *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
          *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
          let vec9 = tenant_id6;
          let ptr9 = vec9.as_ptr().cast::<u8>();
          let len9 = vec9.len();
          *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
          *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
          match team6 {
            Some(e) => {
              *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec10 = e;
              let ptr10 = vec10.as_ptr().cast::<u8>();
              let len10 = vec10.len();
              *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
              *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
            },
            None => {
              {
                *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match team_id6 {
            Some(e) => {
              *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec11 = e;
              let ptr11 = vec11.as_ptr().cast::<u8>();
              let len11 = vec11.len();
              *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
              *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
            },
            None => {
              {
                *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match user6 {
            Some(e) => {
              *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec12 = e;
              let ptr12 = vec12.as_ptr().cast::<u8>();
              let len12 = vec12.len();
              *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
              *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
            },
            None => {
              {
                *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match user_id6 {
            Some(e) => {
              *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec13 = e;
              let ptr13 = vec13.as_ptr().cast::<u8>();
              let len13 = vec13.len();
              *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
              *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr13.cast_mut();
            },
            None => {
              {
                *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match trace_id6 {
            Some(e) => {
              *ptr0.add(26*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec14 = e;
              let ptr14 = vec14.as_ptr().cast::<u8>();
              let len14 = vec14.len();
              *ptr0.add(28*::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
              *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr14.cast_mut();
            },
            None => {
              {
                *ptr0.add(26*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match correlation_id6 {
            Some(e) => {
              *ptr0.add(29*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec15 = e;
              let ptr15 = vec15.as_ptr().cast::<u8>();
              let len15 = vec15.len();
              *ptr0.add(31*::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
              *ptr0.add(30*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr15.cast_mut();
            },
            None => {
              {
                *ptr0.add(29*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };let vec19 = attributes6;
          let len19 = vec19.len();
          let layout19 = _rt::alloc::Layout::from_size_align(vec19.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
          let (result19, _cleanup19) = wit_bindgen::rt::Cleanup::new(layout19);for (i, e) in vec19.into_iter().enumerate() {
            let base = result19.add(i * (4*::core::mem::size_of::<*const u8>()));
            {
              let (t16_0, t16_1, ) = e;
              let vec17 = t16_0;
              let ptr17 = vec17.as_ptr().cast::<u8>();
              let len17 = vec17.len();
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len17;
              *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
              let vec18 = t16_1;
              let ptr18 = vec18.as_ptr().cast::<u8>();
              let len18 = vec18.len();
              *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
              *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr18.cast_mut();
            }
          }
          *ptr0.add(33*::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
          *ptr0.add(32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result19;
          match session_id6 {
            Some(e) => {
              *ptr0.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec20 = e;
              let ptr20 = vec20.as_ptr().cast::<u8>();
              let len20 = vec20.len();
              *ptr0.add(36*::core::mem::size_of::<*const u8>()).cast::<usize>() = len20;
              *ptr0.add(35*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr20.cast_mut();
            },
            None => {
              {
                *ptr0.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match flow_id6 {
            Some(e) => {
              *ptr0.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec21 = e;
              let ptr21 = vec21.as_ptr().cast::<u8>();
              let len21 = vec21.len();
              *ptr0.add(39*::core::mem::size_of::<*const u8>()).cast::<usize>() = len21;
              *ptr0.add(38*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr21.cast_mut();
            },
            None => {
              {
                *ptr0.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match node_id6 {
            Some(e) => {
              *ptr0.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec22 = e;
              let ptr22 = vec22.as_ptr().cast::<u8>();
              let len22 = vec22.len();
              *ptr0.add(42*::core::mem::size_of::<*const u8>()).cast::<usize>() = len22;
              *ptr0.add(41*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr22.cast_mut();
            },
            None => {
              {
                *ptr0.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match provider_id6 {
            Some(e) => {
              *ptr0.add(43*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec23 = e;
              let ptr23 = vec23.as_ptr().cast::<u8>();
              let len23 = vec23.len();
              *ptr0.add(45*::core::mem::size_of::<*const u8>()).cast::<usize>() = len23;
              *ptr0.add(44*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr23.cast_mut();
            },
            None => {
              {
                *ptr0.add(43*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match deadline_ms6 {
            Some(e) => {
              *ptr0.add(46*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              *ptr0.add(8+46*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
            },
            None => {
              {
                *ptr0.add(46*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };*ptr0.add(16+46*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(attempt6);
          match idempotency_key6 {
            Some(e) => {
              *ptr0.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let vec24 = e;
              let ptr24 = vec24.as_ptr().cast::<u8>();
              let len24 = vec24.len();
              *ptr0.add(16+49*::core::mem::size_of::<*const u8>()).cast::<usize>() = len24;
              *ptr0.add(16+48*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr24.cast_mut();
            },
            None => {
              {
                *ptr0.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
              }
            },
          };match impersonation6 {
            Some(e) => {
              *ptr0.add(16+50*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let super::super::super::greentic::interfaces_types::types::Impersonation{ actor_id:actor_id25, reason:reason25, } = e;
              let vec26 = actor_id25;
              let ptr26 = vec26.as_ptr().cast::<u8>();
              let len26 = vec26.len();
              *ptr0.add(16+52*::core::mem::size_of::<*const u8>()).cast::<usize>() = len26;
              *ptr0.add(16+51*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr26.cast_mut();
              match reason25 {
                Some(e) => {
                  *ptr0.add(16+53*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec27 = e;
                  let ptr27 = vec27.as_ptr().cast::<u8>();
                  let len27 = vec27.len();
                  *ptr0.add(16+55*::core::mem::size_of::<*const u8>()).cast::<usize>() = len27;
                  *ptr0.add(16+54*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr27.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(16+53*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };},
              None => {
                {
                  *ptr0.add(16+50*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };let ptr28 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "greentic:messaging/session-api@1.0.0")]
            unsafe extern "C" {
              #[link_name = "send"]
              fn wit_import29(_: *mut u8, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import29(_: *mut u8, _: *mut u8, ) { unreachable!() }
            wit_import29(ptr0, ptr28);
            let l30 = i32::from(*ptr28.add(0).cast::<u8>());
            let result38 = match l30 {
              0 => {
                let e = {
                  let l31 = i32::from(*ptr28.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                  OpAck::_lift(l31 as u8)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l32 = *ptr28.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l33 = *ptr28.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len34 = l33;
                  let bytes34 = _rt::Vec::from_raw_parts(l32.cast(), len34, len34);
                  let l35 = *ptr28.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l36 = *ptr28.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len37 = l36;
                  let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);

                  HostError{
                    code: _rt::string_lift(bytes34),
                    message: _rt::string_lift(bytes37),
                  }
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result38
          }
        }

      }

    }
  }
  #[allow(dead_code, clippy::all)]
  pub mod exports {
    pub mod greentic {
      pub mod events_bridge {

        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod bridge_api {
          #[used]
          #[doc(hidden)]
          static __FORCE_SECTION_REF: fn() =
          super::super::super::super::__link_custom_section_describing_imports;
          
          use super::super::super::super::_rt;
          pub type TenantCtx = super::super::super::super::greentic::interfaces_types::types::TenantCtx;
          pub type EventEnvelope = super::super::super::super::greentic::events::event_types::EventEnvelope;
          pub type ChannelMessageEnvelope = super::super::super::super::greentic::messaging::session_api::ChannelMessageEnvelope;
          #[doc(hidden)]
          #[allow(non_snake_case, unused_unsafe)]
          pub unsafe fn _export_handle_message_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
          _rt::run_ctors_once();let result127 = {
            let l0 = *arg0.add(0).cast::<*mut u8>();
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len2 = l1;
            let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
            let l3 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l4 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len5 = l4;
            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
            let l6 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l7 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len8 = l7;
            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
            let l9 = *arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l10 = *arg0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len11 = l10;
            let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
            let l12 = i32::from(*arg0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l16 = i32::from(*arg0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l20 = i32::from(*arg0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l24 = i32::from(*arg0.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l28 = i32::from(*arg0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l32 = i32::from(*arg0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l36 = *arg0.add(26*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l37 = *arg0.add(27*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base44 = l36;
            let len44 = l37;
            let mut result44 = _rt::Vec::with_capacity(len44);
            for i in 0..len44 {
              let base = base44.add(i * (4*::core::mem::size_of::<*const u8>()));
              let e44 = {
                let l38 = *base.add(0).cast::<*mut u8>();
                let l39 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len40 = l39;
                let bytes40 = _rt::Vec::from_raw_parts(l38.cast(), len40, len40);
                let l41 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l42 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len43 = l42;
                let bytes43 = _rt::Vec::from_raw_parts(l41.cast(), len43, len43);

                (_rt::string_lift(bytes40), _rt::string_lift(bytes43))
              };
              result44.push(e44);
            }
            _rt::cabi_dealloc(base44, len44 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
            let l45 = i32::from(*arg0.add(28*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l49 = i32::from(*arg0.add(31*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l53 = i32::from(*arg0.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l57 = i32::from(*arg0.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l61 = i32::from(*arg0.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l63 = *arg0.add(16+40*::core::mem::size_of::<*const u8>()).cast::<i32>();
            let l64 = i32::from(*arg0.add(16+41*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l68 = i32::from(*arg0.add(16+44*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l76 = *arg0.add(16+50*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l77 = *arg0.add(16+51*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len78 = l77;
            let bytes78 = _rt::Vec::from_raw_parts(l76.cast(), len78, len78);
            let l79 = *arg0.add(16+52*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l80 = *arg0.add(16+53*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len81 = l80;
            let bytes81 = _rt::Vec::from_raw_parts(l79.cast(), len81, len81);
            let l82 = i32::from(*arg0.add(16+54*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l86 = i32::from(*arg0.add(16+57*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l90 = *arg0.add(16+60*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l91 = *arg0.add(16+61*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base117 = l90;
            let len117 = l91;
            let mut result117 = _rt::Vec::with_capacity(len117);
            for i in 0..len117 {
              let base = base117.add(i * (32+10*::core::mem::size_of::<*const u8>()));
              let e117 = {
                let l92 = *base.add(0).cast::<*mut u8>();
                let l93 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len94 = l93;
                let bytes94 = _rt::Vec::from_raw_parts(l92.cast(), len94, len94);
                let l95 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l96 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len97 = l96;
                let bytes97 = _rt::Vec::from_raw_parts(l95.cast(), len97, len97);
                let l98 = i32::from(*base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l102 = i32::from(*base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l104 = i32::from(*base.add(24+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l108 = *base.add(24+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l109 = *base.add(24+10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base116 = l108;
                let len116 = l109;
                let mut result116 = _rt::Vec::with_capacity(len116);
                for i in 0..len116 {
                  let base = base116.add(i * (4*::core::mem::size_of::<*const u8>()));
                  let e116 = {
                    let l110 = *base.add(0).cast::<*mut u8>();
                    let l111 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len112 = l111;
                    let bytes112 = _rt::Vec::from_raw_parts(l110.cast(), len112, len112);
                    let l113 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l114 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len115 = l114;
                    let bytes115 = _rt::Vec::from_raw_parts(l113.cast(), len115, len115);

                    (_rt::string_lift(bytes112), _rt::string_lift(bytes115))
                  };
                  result116.push(e116);
                }
                _rt::cabi_dealloc(base116, len116 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                super::super::super::super::greentic::messaging::session_api::Attachment{
                  mime_type: _rt::string_lift(bytes94),
                  url: _rt::string_lift(bytes97),
                  name: match l98 {
                    0 => None,
                    1 => {
                      let e = {
                        let l99 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l100 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len101 = l100;
                        let bytes101 = _rt::Vec::from_raw_parts(l99.cast(), len101, len101);

                        _rt::string_lift(bytes101)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  size_bytes: match l102 {
                    0 => None,
                    1 => {
                      let e = {
                        let l103 = *base.add(16+6*::core::mem::size_of::<*const u8>()).cast::<i64>();

                        l103 as u64
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  description: match l104 {
                    0 => None,
                    1 => {
                      let e = {
                        let l105 = *base.add(24+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l106 = *base.add(24+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len107 = l106;
                        let bytes107 = _rt::Vec::from_raw_parts(l105.cast(), len107, len107);

                        _rt::string_lift(bytes107)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  metadata: result116,
                }
              };
              result117.push(e117);
            }
            _rt::cabi_dealloc(base117, len117 * (32+10*::core::mem::size_of::<*const u8>()), 8);
            let l118 = *arg0.add(16+62*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l119 = *arg0.add(16+63*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base126 = l118;
            let len126 = l119;
            let mut result126 = _rt::Vec::with_capacity(len126);
            for i in 0..len126 {
              let base = base126.add(i * (4*::core::mem::size_of::<*const u8>()));
              let e126 = {
                let l120 = *base.add(0).cast::<*mut u8>();
                let l121 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len122 = l121;
                let bytes122 = _rt::Vec::from_raw_parts(l120.cast(), len122, len122);
                let l123 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l124 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len125 = l124;
                let bytes125 = _rt::Vec::from_raw_parts(l123.cast(), len125, len125);

                (_rt::string_lift(bytes122), _rt::string_lift(bytes125))
              };
              result126.push(e126);
            }
            _rt::cabi_dealloc(base126, len126 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
            T::handle_message(super::super::super::super::greentic::messaging::session_api::ChannelMessageEnvelope{
              id: _rt::string_lift(bytes2),
              tenant: super::super::super::super::greentic::interfaces_types::types::TenantCtx{
                env: _rt::string_lift(bytes5),
                tenant: _rt::string_lift(bytes8),
                tenant_id: _rt::string_lift(bytes11),
                team: match l12 {
                  0 => None,
                  1 => {
                    let e = {
                      let l13 = *arg0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l14 = *arg0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len15 = l14;
                      let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                      _rt::string_lift(bytes15)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                team_id: match l16 {
                  0 => None,
                  1 => {
                    let e = {
                      let l17 = *arg0.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l18 = *arg0.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len19 = l18;
                      let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                      _rt::string_lift(bytes19)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                user: match l20 {
                  0 => None,
                  1 => {
                    let e = {
                      let l21 = *arg0.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l22 = *arg0.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len23 = l22;
                      let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);

                      _rt::string_lift(bytes23)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                user_id: match l24 {
                  0 => None,
                  1 => {
                    let e = {
                      let l25 = *arg0.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l26 = *arg0.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len27 = l26;
                      let bytes27 = _rt::Vec::from_raw_parts(l25.cast(), len27, len27);

                      _rt::string_lift(bytes27)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                trace_id: match l28 {
                  0 => None,
                  1 => {
                    let e = {
                      let l29 = *arg0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l30 = *arg0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len31 = l30;
                      let bytes31 = _rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                      _rt::string_lift(bytes31)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                correlation_id: match l32 {
                  0 => None,
                  1 => {
                    let e = {
                      let l33 = *arg0.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l34 = *arg0.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len35 = l34;
                      let bytes35 = _rt::Vec::from_raw_parts(l33.cast(), len35, len35);

                      _rt::string_lift(bytes35)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                attributes: result44,
                session_id: match l45 {
                  0 => None,
                  1 => {
                    let e = {
                      let l46 = *arg0.add(29*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l47 = *arg0.add(30*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len48 = l47;
                      let bytes48 = _rt::Vec::from_raw_parts(l46.cast(), len48, len48);

                      _rt::string_lift(bytes48)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                flow_id: match l49 {
                  0 => None,
                  1 => {
                    let e = {
                      let l50 = *arg0.add(32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l51 = *arg0.add(33*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len52 = l51;
                      let bytes52 = _rt::Vec::from_raw_parts(l50.cast(), len52, len52);

                      _rt::string_lift(bytes52)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                node_id: match l53 {
                  0 => None,
                  1 => {
                    let e = {
                      let l54 = *arg0.add(35*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l55 = *arg0.add(36*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len56 = l55;
                      let bytes56 = _rt::Vec::from_raw_parts(l54.cast(), len56, len56);

                      _rt::string_lift(bytes56)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                provider_id: match l57 {
                  0 => None,
                  1 => {
                    let e = {
                      let l58 = *arg0.add(38*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l59 = *arg0.add(39*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len60 = l59;
                      let bytes60 = _rt::Vec::from_raw_parts(l58.cast(), len60, len60);

                      _rt::string_lift(bytes60)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                deadline_ms: match l61 {
                  0 => None,
                  1 => {
                    let e = {
                      let l62 = *arg0.add(8+40*::core::mem::size_of::<*const u8>()).cast::<i64>();

                      l62
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                attempt: l63 as u32,
                idempotency_key: match l64 {
                  0 => None,
                  1 => {
                    let e = {
                      let l65 = *arg0.add(16+42*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l66 = *arg0.add(16+43*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len67 = l66;
                      let bytes67 = _rt::Vec::from_raw_parts(l65.cast(), len67, len67);

                      _rt::string_lift(bytes67)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                impersonation: match l68 {
                  0 => None,
                  1 => {
                    let e = {
                      let l69 = *arg0.add(16+45*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l70 = *arg0.add(16+46*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len71 = l70;
                      let bytes71 = _rt::Vec::from_raw_parts(l69.cast(), len71, len71);
                      let l72 = i32::from(*arg0.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      super::super::super::super::greentic::interfaces_types::types::Impersonation{
                        actor_id: _rt::string_lift(bytes71),
                        reason: match l72 {
                          0 => None,
                          1 => {
                            let e = {
                              let l73 = *arg0.add(16+48*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l74 = *arg0.add(16+49*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len75 = l74;
                              let bytes75 = _rt::Vec::from_raw_parts(l73.cast(), len75, len75);

                              _rt::string_lift(bytes75)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
              },
              channel: _rt::string_lift(bytes78),
              session_id: _rt::string_lift(bytes81),
              user_id: match l82 {
                0 => None,
                1 => {
                  let e = {
                    let l83 = *arg0.add(16+55*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l84 = *arg0.add(16+56*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len85 = l84;
                    let bytes85 = _rt::Vec::from_raw_parts(l83.cast(), len85, len85);

                    _rt::string_lift(bytes85)
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
              text: match l86 {
                0 => None,
                1 => {
                  let e = {
                    let l87 = *arg0.add(16+58*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l88 = *arg0.add(16+59*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len89 = l88;
                    let bytes89 = _rt::Vec::from_raw_parts(l87.cast(), len89, len89);

                    _rt::string_lift(bytes89)
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
              attachments: result117,
              metadata: result126,
            })
          };
          _rt::cabi_dealloc(arg0, 16+64*::core::mem::size_of::<*const u8>(), 8);
          let ptr128 = (&raw mut _RET_AREA.0).cast::<u8>();
          let vec164 = result127;
          let len164 = vec164.len();
          let layout164 = _rt::alloc::Layout::from_size_align(vec164.len() * (16+68*::core::mem::size_of::<*const u8>()), 8).unwrap();
          let (result164, _cleanup164) = wit_bindgen::rt::Cleanup::new(layout164);if let Some(cleanup) = _cleanup164 { cleanup.forget(); }
          for (i, e) in vec164.into_iter().enumerate() {
            let base = result164.add(i * (16+68*::core::mem::size_of::<*const u8>()));
            {
              let super::super::super::super::greentic::events::event_types::EventEnvelope{ id:id129, topic:topic129, type_:type_129, source:source129, tenant:tenant129, subject:subject129, time:time129, correlation_id:correlation_id129, payload_json:payload_json129, metadata:metadata129, } = e;
              let vec130 = (id129.into_bytes()).into_boxed_slice();
              let ptr130 = vec130.as_ptr().cast::<u8>();
              let len130 = vec130.len();
              ::core::mem::forget(vec130);
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len130;
              *base.add(0).cast::<*mut u8>() = ptr130.cast_mut();
              let vec131 = (topic129.into_bytes()).into_boxed_slice();
              let ptr131 = vec131.as_ptr().cast::<u8>();
              let len131 = vec131.len();
              ::core::mem::forget(vec131);
              *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len131;
              *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr131.cast_mut();
              let vec132 = (type_129.into_bytes()).into_boxed_slice();
              let ptr132 = vec132.as_ptr().cast::<u8>();
              let len132 = vec132.len();
              ::core::mem::forget(vec132);
              *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len132;
              *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr132.cast_mut();
              let vec133 = (source129.into_bytes()).into_boxed_slice();
              let ptr133 = vec133.as_ptr().cast::<u8>();
              let len133 = vec133.len();
              ::core::mem::forget(vec133);
              *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len133;
              *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr133.cast_mut();
              let super::super::super::super::greentic::interfaces_types::types::TenantCtx{ env:env134, tenant:tenant134, tenant_id:tenant_id134, team:team134, team_id:team_id134, user:user134, user_id:user_id134, trace_id:trace_id134, correlation_id:correlation_id134, attributes:attributes134, session_id:session_id134, flow_id:flow_id134, node_id:node_id134, provider_id:provider_id134, deadline_ms:deadline_ms134, attempt:attempt134, idempotency_key:idempotency_key134, impersonation:impersonation134, } = tenant129;
              let vec135 = (env134.into_bytes()).into_boxed_slice();
              let ptr135 = vec135.as_ptr().cast::<u8>();
              let len135 = vec135.len();
              ::core::mem::forget(vec135);
              *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len135;
              *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr135.cast_mut();
              let vec136 = (tenant134.into_bytes()).into_boxed_slice();
              let ptr136 = vec136.as_ptr().cast::<u8>();
              let len136 = vec136.len();
              ::core::mem::forget(vec136);
              *base.add(11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len136;
              *base.add(10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr136.cast_mut();
              let vec137 = (tenant_id134.into_bytes()).into_boxed_slice();
              let ptr137 = vec137.as_ptr().cast::<u8>();
              let len137 = vec137.len();
              ::core::mem::forget(vec137);
              *base.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len137;
              *base.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr137.cast_mut();
              match team134 {
                Some(e) => {
                  *base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec138 = (e.into_bytes()).into_boxed_slice();
                  let ptr138 = vec138.as_ptr().cast::<u8>();
                  let len138 = vec138.len();
                  ::core::mem::forget(vec138);
                  *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>() = len138;
                  *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr138.cast_mut();
                },
                None => {
                  {
                    *base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match team_id134 {
                Some(e) => {
                  *base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec139 = (e.into_bytes()).into_boxed_slice();
                  let ptr139 = vec139.as_ptr().cast::<u8>();
                  let len139 = vec139.len();
                  ::core::mem::forget(vec139);
                  *base.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>() = len139;
                  *base.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr139.cast_mut();
                },
                None => {
                  {
                    *base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match user134 {
                Some(e) => {
                  *base.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec140 = (e.into_bytes()).into_boxed_slice();
                  let ptr140 = vec140.as_ptr().cast::<u8>();
                  let len140 = vec140.len();
                  ::core::mem::forget(vec140);
                  *base.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len140;
                  *base.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr140.cast_mut();
                },
                None => {
                  {
                    *base.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match user_id134 {
                Some(e) => {
                  *base.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec141 = (e.into_bytes()).into_boxed_slice();
                  let ptr141 = vec141.as_ptr().cast::<u8>();
                  let len141 = vec141.len();
                  ::core::mem::forget(vec141);
                  *base.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>() = len141;
                  *base.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr141.cast_mut();
                },
                None => {
                  {
                    *base.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match trace_id134 {
                Some(e) => {
                  *base.add(26*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec142 = (e.into_bytes()).into_boxed_slice();
                  let ptr142 = vec142.as_ptr().cast::<u8>();
                  let len142 = vec142.len();
                  ::core::mem::forget(vec142);
                  *base.add(28*::core::mem::size_of::<*const u8>()).cast::<usize>() = len142;
                  *base.add(27*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr142.cast_mut();
                },
                None => {
                  {
                    *base.add(26*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match correlation_id134 {
                Some(e) => {
                  *base.add(29*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec143 = (e.into_bytes()).into_boxed_slice();
                  let ptr143 = vec143.as_ptr().cast::<u8>();
                  let len143 = vec143.len();
                  ::core::mem::forget(vec143);
                  *base.add(31*::core::mem::size_of::<*const u8>()).cast::<usize>() = len143;
                  *base.add(30*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr143.cast_mut();
                },
                None => {
                  {
                    *base.add(29*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let vec147 = attributes134;
              let len147 = vec147.len();
              let layout147 = _rt::alloc::Layout::from_size_align(vec147.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
              let (result147, _cleanup147) = wit_bindgen::rt::Cleanup::new(layout147);if let Some(cleanup) = _cleanup147 { cleanup.forget(); }
              for (i, e) in vec147.into_iter().enumerate() {
                let base = result147.add(i * (4*::core::mem::size_of::<*const u8>()));
                {
                  let (t144_0, t144_1, ) = e;
                  let vec145 = (t144_0.into_bytes()).into_boxed_slice();
                  let ptr145 = vec145.as_ptr().cast::<u8>();
                  let len145 = vec145.len();
                  ::core::mem::forget(vec145);
                  *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len145;
                  *base.add(0).cast::<*mut u8>() = ptr145.cast_mut();
                  let vec146 = (t144_1.into_bytes()).into_boxed_slice();
                  let ptr146 = vec146.as_ptr().cast::<u8>();
                  let len146 = vec146.len();
                  ::core::mem::forget(vec146);
                  *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len146;
                  *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr146.cast_mut();
                }
              }
              *base.add(33*::core::mem::size_of::<*const u8>()).cast::<usize>() = len147;
              *base.add(32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result147;
              match session_id134 {
                Some(e) => {
                  *base.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec148 = (e.into_bytes()).into_boxed_slice();
                  let ptr148 = vec148.as_ptr().cast::<u8>();
                  let len148 = vec148.len();
                  ::core::mem::forget(vec148);
                  *base.add(36*::core::mem::size_of::<*const u8>()).cast::<usize>() = len148;
                  *base.add(35*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr148.cast_mut();
                },
                None => {
                  {
                    *base.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match flow_id134 {
                Some(e) => {
                  *base.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec149 = (e.into_bytes()).into_boxed_slice();
                  let ptr149 = vec149.as_ptr().cast::<u8>();
                  let len149 = vec149.len();
                  ::core::mem::forget(vec149);
                  *base.add(39*::core::mem::size_of::<*const u8>()).cast::<usize>() = len149;
                  *base.add(38*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr149.cast_mut();
                },
                None => {
                  {
                    *base.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match node_id134 {
                Some(e) => {
                  *base.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec150 = (e.into_bytes()).into_boxed_slice();
                  let ptr150 = vec150.as_ptr().cast::<u8>();
                  let len150 = vec150.len();
                  ::core::mem::forget(vec150);
                  *base.add(42*::core::mem::size_of::<*const u8>()).cast::<usize>() = len150;
                  *base.add(41*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr150.cast_mut();
                },
                None => {
                  {
                    *base.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match provider_id134 {
                Some(e) => {
                  *base.add(43*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec151 = (e.into_bytes()).into_boxed_slice();
                  let ptr151 = vec151.as_ptr().cast::<u8>();
                  let len151 = vec151.len();
                  ::core::mem::forget(vec151);
                  *base.add(45*::core::mem::size_of::<*const u8>()).cast::<usize>() = len151;
                  *base.add(44*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr151.cast_mut();
                },
                None => {
                  {
                    *base.add(43*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match deadline_ms134 {
                Some(e) => {
                  *base.add(46*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *base.add(8+46*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                },
                None => {
                  {
                    *base.add(46*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };*base.add(16+46*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(attempt134);
              match idempotency_key134 {
                Some(e) => {
                  *base.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec152 = (e.into_bytes()).into_boxed_slice();
                  let ptr152 = vec152.as_ptr().cast::<u8>();
                  let len152 = vec152.len();
                  ::core::mem::forget(vec152);
                  *base.add(16+49*::core::mem::size_of::<*const u8>()).cast::<usize>() = len152;
                  *base.add(16+48*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr152.cast_mut();
                },
                None => {
                  {
                    *base.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match impersonation134 {
                Some(e) => {
                  *base.add(16+50*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let super::super::super::super::greentic::interfaces_types::types::Impersonation{ actor_id:actor_id153, reason:reason153, } = e;
                  let vec154 = (actor_id153.into_bytes()).into_boxed_slice();
                  let ptr154 = vec154.as_ptr().cast::<u8>();
                  let len154 = vec154.len();
                  ::core::mem::forget(vec154);
                  *base.add(16+52*::core::mem::size_of::<*const u8>()).cast::<usize>() = len154;
                  *base.add(16+51*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr154.cast_mut();
                  match reason153 {
                    Some(e) => {
                      *base.add(16+53*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec155 = (e.into_bytes()).into_boxed_slice();
                      let ptr155 = vec155.as_ptr().cast::<u8>();
                      let len155 = vec155.len();
                      ::core::mem::forget(vec155);
                      *base.add(16+55*::core::mem::size_of::<*const u8>()).cast::<usize>() = len155;
                      *base.add(16+54*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr155.cast_mut();
                    },
                    None => {
                      {
                        *base.add(16+53*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                  None => {
                    {
                      *base.add(16+50*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match subject129 {
                  Some(e) => {
                    *base.add(16+56*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec156 = (e.into_bytes()).into_boxed_slice();
                    let ptr156 = vec156.as_ptr().cast::<u8>();
                    let len156 = vec156.len();
                    ::core::mem::forget(vec156);
                    *base.add(16+58*::core::mem::size_of::<*const u8>()).cast::<usize>() = len156;
                    *base.add(16+57*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr156.cast_mut();
                  },
                  None => {
                    {
                      *base.add(16+56*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let vec157 = (time129.into_bytes()).into_boxed_slice();
                let ptr157 = vec157.as_ptr().cast::<u8>();
                let len157 = vec157.len();
                ::core::mem::forget(vec157);
                *base.add(16+60*::core::mem::size_of::<*const u8>()).cast::<usize>() = len157;
                *base.add(16+59*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr157.cast_mut();
                match correlation_id129 {
                  Some(e) => {
                    *base.add(16+61*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec158 = (e.into_bytes()).into_boxed_slice();
                    let ptr158 = vec158.as_ptr().cast::<u8>();
                    let len158 = vec158.len();
                    ::core::mem::forget(vec158);
                    *base.add(16+63*::core::mem::size_of::<*const u8>()).cast::<usize>() = len158;
                    *base.add(16+62*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr158.cast_mut();
                  },
                  None => {
                    {
                      *base.add(16+61*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let vec159 = (payload_json129.into_bytes()).into_boxed_slice();
                let ptr159 = vec159.as_ptr().cast::<u8>();
                let len159 = vec159.len();
                ::core::mem::forget(vec159);
                *base.add(16+65*::core::mem::size_of::<*const u8>()).cast::<usize>() = len159;
                *base.add(16+64*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr159.cast_mut();
                let vec163 = metadata129;
                let len163 = vec163.len();
                let layout163 = _rt::alloc::Layout::from_size_align(vec163.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                let (result163, _cleanup163) = wit_bindgen::rt::Cleanup::new(layout163);if let Some(cleanup) = _cleanup163 { cleanup.forget(); }
                for (i, e) in vec163.into_iter().enumerate() {
                  let base = result163.add(i * (4*::core::mem::size_of::<*const u8>()));
                  {
                    let (t160_0, t160_1, ) = e;
                    let vec161 = (t160_0.into_bytes()).into_boxed_slice();
                    let ptr161 = vec161.as_ptr().cast::<u8>();
                    let len161 = vec161.len();
                    ::core::mem::forget(vec161);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len161;
                    *base.add(0).cast::<*mut u8>() = ptr161.cast_mut();
                    let vec162 = (t160_1.into_bytes()).into_boxed_slice();
                    let ptr162 = vec162.as_ptr().cast::<u8>();
                    let len162 = vec162.len();
                    ::core::mem::forget(vec162);
                    *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len162;
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr162.cast_mut();
                  }
                }
                *base.add(16+67*::core::mem::size_of::<*const u8>()).cast::<usize>() = len163;
                *base.add(16+66*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result163;
              }
            }
            *ptr128.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len164;
            *ptr128.add(0).cast::<*mut u8>() = result164;
            ptr128
          } }
          #[doc(hidden)]
          #[allow(non_snake_case)]
          pub unsafe fn __post_return_handle_message<T: Guest>(arg0: *mut u8,) { unsafe {
            let l0 = *arg0.add(0).cast::<*mut u8>();
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base79 = l0;
            let len79 = l1;
            for i in 0..len79 {
              let base = base79.add(i * (16+68*::core::mem::size_of::<*const u8>()));
              {
                let l2 = *base.add(0).cast::<*mut u8>();
                let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l2, l3, 1);
                let l4 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l4, l5, 1);
                let l6 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l7 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l6, l7, 1);
                let l8 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l9 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l8, l9, 1);
                let l10 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l11 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l10, l11, 1);
                let l12 = *base.add(10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l13 = *base.add(11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l12, l13, 1);
                let l14 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l15 = *base.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l14, l15, 1);
                let l16 = i32::from(*base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l16 {
                  0 => (),
                  _ => {
                    let l17 = *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l18 = *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l17, l18, 1);
                  },
                }
                let l19 = i32::from(*base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l19 {
                  0 => (),
                  _ => {
                    let l20 = *base.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l21 = *base.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l20, l21, 1);
                  },
                }
                let l22 = i32::from(*base.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l22 {
                  0 => (),
                  _ => {
                    let l23 = *base.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l24 = *base.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l23, l24, 1);
                  },
                }
                let l25 = i32::from(*base.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l25 {
                  0 => (),
                  _ => {
                    let l26 = *base.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l27 = *base.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l26, l27, 1);
                  },
                }
                let l28 = i32::from(*base.add(26*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l28 {
                  0 => (),
                  _ => {
                    let l29 = *base.add(27*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l30 = *base.add(28*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l29, l30, 1);
                  },
                }
                let l31 = i32::from(*base.add(29*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l31 {
                  0 => (),
                  _ => {
                    let l32 = *base.add(30*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l33 = *base.add(31*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l32, l33, 1);
                  },
                }
                let l34 = *base.add(32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l35 = *base.add(33*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base40 = l34;
                let len40 = l35;
                for i in 0..len40 {
                  let base = base40.add(i * (4*::core::mem::size_of::<*const u8>()));
                  {
                    let l36 = *base.add(0).cast::<*mut u8>();
                    let l37 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l36, l37, 1);
                    let l38 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l39 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l38, l39, 1);
                  }
                }
                _rt::cabi_dealloc(base40, len40 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                let l41 = i32::from(*base.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l41 {
                  0 => (),
                  _ => {
                    let l42 = *base.add(35*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l43 = *base.add(36*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l42, l43, 1);
                  },
                }
                let l44 = i32::from(*base.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l44 {
                  0 => (),
                  _ => {
                    let l45 = *base.add(38*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l46 = *base.add(39*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l45, l46, 1);
                  },
                }
                let l47 = i32::from(*base.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l47 {
                  0 => (),
                  _ => {
                    let l48 = *base.add(41*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l49 = *base.add(42*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l48, l49, 1);
                  },
                }
                let l50 = i32::from(*base.add(43*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l50 {
                  0 => (),
                  _ => {
                    let l51 = *base.add(44*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l52 = *base.add(45*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l51, l52, 1);
                  },
                }
                let l53 = i32::from(*base.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l53 {
                  0 => (),
                  _ => {
                    let l54 = *base.add(16+48*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l55 = *base.add(16+49*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l54, l55, 1);
                  },
                }
                let l56 = i32::from(*base.add(16+50*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l56 {
                  0 => (),
                  _ => {
                    let l57 = *base.add(16+51*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l58 = *base.add(16+52*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l57, l58, 1);
                    let l59 = i32::from(*base.add(16+53*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l59 {
                      0 => (),
                      _ => {
                        let l60 = *base.add(16+54*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l61 = *base.add(16+55*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l60, l61, 1);
                      },
                    }
                  },
                }
                let l62 = i32::from(*base.add(16+56*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l62 {
                  0 => (),
                  _ => {
                    let l63 = *base.add(16+57*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l64 = *base.add(16+58*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l63, l64, 1);
                  },
                }
                let l65 = *base.add(16+59*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l66 = *base.add(16+60*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l65, l66, 1);
                let l67 = i32::from(*base.add(16+61*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l67 {
                  0 => (),
                  _ => {
                    let l68 = *base.add(16+62*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l69 = *base.add(16+63*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l68, l69, 1);
                  },
                }
                let l70 = *base.add(16+64*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l71 = *base.add(16+65*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l70, l71, 1);
                let l72 = *base.add(16+66*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l73 = *base.add(16+67*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base78 = l72;
                let len78 = l73;
                for i in 0..len78 {
                  let base = base78.add(i * (4*::core::mem::size_of::<*const u8>()));
                  {
                    let l74 = *base.add(0).cast::<*mut u8>();
                    let l75 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l74, l75, 1);
                    let l76 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l77 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l76, l77, 1);
                  }
                }
                _rt::cabi_dealloc(base78, len78 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              }
            }
            _rt::cabi_dealloc(base79, len79 * (16+68*::core::mem::size_of::<*const u8>()), 8);
          } }
          #[doc(hidden)]
          #[allow(non_snake_case, unused_unsafe)]
          pub unsafe fn _export_handle_event_cabi<T: Guest>(arg0: *mut u8,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
          _rt::run_ctors_once();let result108 = {
            let l0 = *arg0.add(0).cast::<*mut u8>();
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len2 = l1;
            let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
            let l3 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l4 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len5 = l4;
            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
            let l6 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l7 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len8 = l7;
            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
            let l9 = *arg0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l10 = *arg0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len11 = l10;
            let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
            let l12 = *arg0.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l13 = *arg0.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len14 = l13;
            let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
            let l15 = *arg0.add(10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l16 = *arg0.add(11*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len17 = l16;
            let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);
            let l18 = *arg0.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l19 = *arg0.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len20 = l19;
            let bytes20 = _rt::Vec::from_raw_parts(l18.cast(), len20, len20);
            let l21 = i32::from(*arg0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l25 = i32::from(*arg0.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l29 = i32::from(*arg0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l33 = i32::from(*arg0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l37 = i32::from(*arg0.add(26*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l41 = i32::from(*arg0.add(29*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l45 = *arg0.add(32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l46 = *arg0.add(33*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base53 = l45;
            let len53 = l46;
            let mut result53 = _rt::Vec::with_capacity(len53);
            for i in 0..len53 {
              let base = base53.add(i * (4*::core::mem::size_of::<*const u8>()));
              let e53 = {
                let l47 = *base.add(0).cast::<*mut u8>();
                let l48 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len49 = l48;
                let bytes49 = _rt::Vec::from_raw_parts(l47.cast(), len49, len49);
                let l50 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l51 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len52 = l51;
                let bytes52 = _rt::Vec::from_raw_parts(l50.cast(), len52, len52);

                (_rt::string_lift(bytes49), _rt::string_lift(bytes52))
              };
              result53.push(e53);
            }
            _rt::cabi_dealloc(base53, len53 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
            let l54 = i32::from(*arg0.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l58 = i32::from(*arg0.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l62 = i32::from(*arg0.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l66 = i32::from(*arg0.add(43*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l70 = i32::from(*arg0.add(46*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l72 = *arg0.add(16+46*::core::mem::size_of::<*const u8>()).cast::<i32>();
            let l73 = i32::from(*arg0.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l77 = i32::from(*arg0.add(16+50*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l85 = i32::from(*arg0.add(16+56*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l89 = *arg0.add(16+59*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l90 = *arg0.add(16+60*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len91 = l90;
            let bytes91 = _rt::Vec::from_raw_parts(l89.cast(), len91, len91);
            let l92 = i32::from(*arg0.add(16+61*::core::mem::size_of::<*const u8>()).cast::<u8>());
            let l96 = *arg0.add(16+64*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l97 = *arg0.add(16+65*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len98 = l97;
            let bytes98 = _rt::Vec::from_raw_parts(l96.cast(), len98, len98);
            let l99 = *arg0.add(16+66*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l100 = *arg0.add(16+67*::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base107 = l99;
            let len107 = l100;
            let mut result107 = _rt::Vec::with_capacity(len107);
            for i in 0..len107 {
              let base = base107.add(i * (4*::core::mem::size_of::<*const u8>()));
              let e107 = {
                let l101 = *base.add(0).cast::<*mut u8>();
                let l102 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len103 = l102;
                let bytes103 = _rt::Vec::from_raw_parts(l101.cast(), len103, len103);
                let l104 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l105 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len106 = l105;
                let bytes106 = _rt::Vec::from_raw_parts(l104.cast(), len106, len106);

                (_rt::string_lift(bytes103), _rt::string_lift(bytes106))
              };
              result107.push(e107);
            }
            _rt::cabi_dealloc(base107, len107 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
            T::handle_event(super::super::super::super::greentic::events::event_types::EventEnvelope{
              id: _rt::string_lift(bytes2),
              topic: _rt::string_lift(bytes5),
              type_: _rt::string_lift(bytes8),
              source: _rt::string_lift(bytes11),
              tenant: super::super::super::super::greentic::interfaces_types::types::TenantCtx{
                env: _rt::string_lift(bytes14),
                tenant: _rt::string_lift(bytes17),
                tenant_id: _rt::string_lift(bytes20),
                team: match l21 {
                  0 => None,
                  1 => {
                    let e = {
                      let l22 = *arg0.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l23 = *arg0.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len24 = l23;
                      let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);

                      _rt::string_lift(bytes24)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                team_id: match l25 {
                  0 => None,
                  1 => {
                    let e = {
                      let l26 = *arg0.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l27 = *arg0.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len28 = l27;
                      let bytes28 = _rt::Vec::from_raw_parts(l26.cast(), len28, len28);

                      _rt::string_lift(bytes28)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                user: match l29 {
                  0 => None,
                  1 => {
                    let e = {
                      let l30 = *arg0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l31 = *arg0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len32 = l31;
                      let bytes32 = _rt::Vec::from_raw_parts(l30.cast(), len32, len32);

                      _rt::string_lift(bytes32)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                user_id: match l33 {
                  0 => None,
                  1 => {
                    let e = {
                      let l34 = *arg0.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l35 = *arg0.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len36 = l35;
                      let bytes36 = _rt::Vec::from_raw_parts(l34.cast(), len36, len36);

                      _rt::string_lift(bytes36)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                trace_id: match l37 {
                  0 => None,
                  1 => {
                    let e = {
                      let l38 = *arg0.add(27*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l39 = *arg0.add(28*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len40 = l39;
                      let bytes40 = _rt::Vec::from_raw_parts(l38.cast(), len40, len40);

                      _rt::string_lift(bytes40)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                correlation_id: match l41 {
                  0 => None,
                  1 => {
                    let e = {
                      let l42 = *arg0.add(30*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l43 = *arg0.add(31*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len44 = l43;
                      let bytes44 = _rt::Vec::from_raw_parts(l42.cast(), len44, len44);

                      _rt::string_lift(bytes44)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                attributes: result53,
                session_id: match l54 {
                  0 => None,
                  1 => {
                    let e = {
                      let l55 = *arg0.add(35*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l56 = *arg0.add(36*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len57 = l56;
                      let bytes57 = _rt::Vec::from_raw_parts(l55.cast(), len57, len57);

                      _rt::string_lift(bytes57)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                flow_id: match l58 {
                  0 => None,
                  1 => {
                    let e = {
                      let l59 = *arg0.add(38*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l60 = *arg0.add(39*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len61 = l60;
                      let bytes61 = _rt::Vec::from_raw_parts(l59.cast(), len61, len61);

                      _rt::string_lift(bytes61)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                node_id: match l62 {
                  0 => None,
                  1 => {
                    let e = {
                      let l63 = *arg0.add(41*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l64 = *arg0.add(42*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len65 = l64;
                      let bytes65 = _rt::Vec::from_raw_parts(l63.cast(), len65, len65);

                      _rt::string_lift(bytes65)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                provider_id: match l66 {
                  0 => None,
                  1 => {
                    let e = {
                      let l67 = *arg0.add(44*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l68 = *arg0.add(45*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len69 = l68;
                      let bytes69 = _rt::Vec::from_raw_parts(l67.cast(), len69, len69);

                      _rt::string_lift(bytes69)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                deadline_ms: match l70 {
                  0 => None,
                  1 => {
                    let e = {
                      let l71 = *arg0.add(8+46*::core::mem::size_of::<*const u8>()).cast::<i64>();

                      l71
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                attempt: l72 as u32,
                idempotency_key: match l73 {
                  0 => None,
                  1 => {
                    let e = {
                      let l74 = *arg0.add(16+48*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l75 = *arg0.add(16+49*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len76 = l75;
                      let bytes76 = _rt::Vec::from_raw_parts(l74.cast(), len76, len76);

                      _rt::string_lift(bytes76)
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
                impersonation: match l77 {
                  0 => None,
                  1 => {
                    let e = {
                      let l78 = *arg0.add(16+51*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l79 = *arg0.add(16+52*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len80 = l79;
                      let bytes80 = _rt::Vec::from_raw_parts(l78.cast(), len80, len80);
                      let l81 = i32::from(*arg0.add(16+53*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      super::super::super::super::greentic::interfaces_types::types::Impersonation{
                        actor_id: _rt::string_lift(bytes80),
                        reason: match l81 {
                          0 => None,
                          1 => {
                            let e = {
                              let l82 = *arg0.add(16+54*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l83 = *arg0.add(16+55*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len84 = l83;
                              let bytes84 = _rt::Vec::from_raw_parts(l82.cast(), len84, len84);

                              _rt::string_lift(bytes84)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                },
              },
              subject: match l85 {
                0 => None,
                1 => {
                  let e = {
                    let l86 = *arg0.add(16+57*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l87 = *arg0.add(16+58*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len88 = l87;
                    let bytes88 = _rt::Vec::from_raw_parts(l86.cast(), len88, len88);

                    _rt::string_lift(bytes88)
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
              time: _rt::string_lift(bytes91),
              correlation_id: match l92 {
                0 => None,
                1 => {
                  let e = {
                    let l93 = *arg0.add(16+62*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l94 = *arg0.add(16+63*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len95 = l94;
                    let bytes95 = _rt::Vec::from_raw_parts(l93.cast(), len95, len95);

                    _rt::string_lift(bytes95)
                  };
                  Some(e)
                }
                _ => _rt::invalid_enum_discriminant(),
              },
              payload_json: _rt::string_lift(bytes98),
              metadata: result107,
            })
          };
          _rt::cabi_dealloc(arg0, 16+68*::core::mem::size_of::<*const u8>(), 8);
          let ptr109 = (&raw mut _RET_AREA.0).cast::<u8>();
          let vec152 = result108;
          let len152 = vec152.len();
          let layout152 = _rt::alloc::Layout::from_size_align(vec152.len() * (16+64*::core::mem::size_of::<*const u8>()), 8).unwrap();
          let (result152, _cleanup152) = wit_bindgen::rt::Cleanup::new(layout152);if let Some(cleanup) = _cleanup152 { cleanup.forget(); }
          for (i, e) in vec152.into_iter().enumerate() {
            let base = result152.add(i * (16+64*::core::mem::size_of::<*const u8>()));
            {
              let super::super::super::super::greentic::messaging::session_api::ChannelMessageEnvelope{ id:id110, tenant:tenant110, channel:channel110, session_id:session_id110, user_id:user_id110, text:text110, attachments:attachments110, metadata:metadata110, } = e;
              let vec111 = (id110.into_bytes()).into_boxed_slice();
              let ptr111 = vec111.as_ptr().cast::<u8>();
              let len111 = vec111.len();
              ::core::mem::forget(vec111);
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len111;
              *base.add(0).cast::<*mut u8>() = ptr111.cast_mut();
              let super::super::super::super::greentic::interfaces_types::types::TenantCtx{ env:env112, tenant:tenant112, tenant_id:tenant_id112, team:team112, team_id:team_id112, user:user112, user_id:user_id112, trace_id:trace_id112, correlation_id:correlation_id112, attributes:attributes112, session_id:session_id112, flow_id:flow_id112, node_id:node_id112, provider_id:provider_id112, deadline_ms:deadline_ms112, attempt:attempt112, idempotency_key:idempotency_key112, impersonation:impersonation112, } = tenant110;
              let vec113 = (env112.into_bytes()).into_boxed_slice();
              let ptr113 = vec113.as_ptr().cast::<u8>();
              let len113 = vec113.len();
              ::core::mem::forget(vec113);
              *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len113;
              *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr113.cast_mut();
              let vec114 = (tenant112.into_bytes()).into_boxed_slice();
              let ptr114 = vec114.as_ptr().cast::<u8>();
              let len114 = vec114.len();
              ::core::mem::forget(vec114);
              *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len114;
              *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr114.cast_mut();
              let vec115 = (tenant_id112.into_bytes()).into_boxed_slice();
              let ptr115 = vec115.as_ptr().cast::<u8>();
              let len115 = vec115.len();
              ::core::mem::forget(vec115);
              *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len115;
              *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr115.cast_mut();
              match team112 {
                Some(e) => {
                  *base.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec116 = (e.into_bytes()).into_boxed_slice();
                  let ptr116 = vec116.as_ptr().cast::<u8>();
                  let len116 = vec116.len();
                  ::core::mem::forget(vec116);
                  *base.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len116;
                  *base.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr116.cast_mut();
                },
                None => {
                  {
                    *base.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match team_id112 {
                Some(e) => {
                  *base.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec117 = (e.into_bytes()).into_boxed_slice();
                  let ptr117 = vec117.as_ptr().cast::<u8>();
                  let len117 = vec117.len();
                  ::core::mem::forget(vec117);
                  *base.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len117;
                  *base.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr117.cast_mut();
                },
                None => {
                  {
                    *base.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match user112 {
                Some(e) => {
                  *base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec118 = (e.into_bytes()).into_boxed_slice();
                  let ptr118 = vec118.as_ptr().cast::<u8>();
                  let len118 = vec118.len();
                  ::core::mem::forget(vec118);
                  *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>() = len118;
                  *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr118.cast_mut();
                },
                None => {
                  {
                    *base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match user_id112 {
                Some(e) => {
                  *base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec119 = (e.into_bytes()).into_boxed_slice();
                  let ptr119 = vec119.as_ptr().cast::<u8>();
                  let len119 = vec119.len();
                  ::core::mem::forget(vec119);
                  *base.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>() = len119;
                  *base.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr119.cast_mut();
                },
                None => {
                  {
                    *base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match trace_id112 {
                Some(e) => {
                  *base.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec120 = (e.into_bytes()).into_boxed_slice();
                  let ptr120 = vec120.as_ptr().cast::<u8>();
                  let len120 = vec120.len();
                  ::core::mem::forget(vec120);
                  *base.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len120;
                  *base.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr120.cast_mut();
                },
                None => {
                  {
                    *base.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match correlation_id112 {
                Some(e) => {
                  *base.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec121 = (e.into_bytes()).into_boxed_slice();
                  let ptr121 = vec121.as_ptr().cast::<u8>();
                  let len121 = vec121.len();
                  ::core::mem::forget(vec121);
                  *base.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>() = len121;
                  *base.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr121.cast_mut();
                },
                None => {
                  {
                    *base.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let vec125 = attributes112;
              let len125 = vec125.len();
              let layout125 = _rt::alloc::Layout::from_size_align(vec125.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
              let (result125, _cleanup125) = wit_bindgen::rt::Cleanup::new(layout125);if let Some(cleanup) = _cleanup125 { cleanup.forget(); }
              for (i, e) in vec125.into_iter().enumerate() {
                let base = result125.add(i * (4*::core::mem::size_of::<*const u8>()));
                {
                  let (t122_0, t122_1, ) = e;
                  let vec123 = (t122_0.into_bytes()).into_boxed_slice();
                  let ptr123 = vec123.as_ptr().cast::<u8>();
                  let len123 = vec123.len();
                  ::core::mem::forget(vec123);
                  *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len123;
                  *base.add(0).cast::<*mut u8>() = ptr123.cast_mut();
                  let vec124 = (t122_1.into_bytes()).into_boxed_slice();
                  let ptr124 = vec124.as_ptr().cast::<u8>();
                  let len124 = vec124.len();
                  ::core::mem::forget(vec124);
                  *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len124;
                  *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr124.cast_mut();
                }
              }
              *base.add(27*::core::mem::size_of::<*const u8>()).cast::<usize>() = len125;
              *base.add(26*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result125;
              match session_id112 {
                Some(e) => {
                  *base.add(28*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec126 = (e.into_bytes()).into_boxed_slice();
                  let ptr126 = vec126.as_ptr().cast::<u8>();
                  let len126 = vec126.len();
                  ::core::mem::forget(vec126);
                  *base.add(30*::core::mem::size_of::<*const u8>()).cast::<usize>() = len126;
                  *base.add(29*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr126.cast_mut();
                },
                None => {
                  {
                    *base.add(28*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match flow_id112 {
                Some(e) => {
                  *base.add(31*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec127 = (e.into_bytes()).into_boxed_slice();
                  let ptr127 = vec127.as_ptr().cast::<u8>();
                  let len127 = vec127.len();
                  ::core::mem::forget(vec127);
                  *base.add(33*::core::mem::size_of::<*const u8>()).cast::<usize>() = len127;
                  *base.add(32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr127.cast_mut();
                },
                None => {
                  {
                    *base.add(31*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match node_id112 {
                Some(e) => {
                  *base.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec128 = (e.into_bytes()).into_boxed_slice();
                  let ptr128 = vec128.as_ptr().cast::<u8>();
                  let len128 = vec128.len();
                  ::core::mem::forget(vec128);
                  *base.add(36*::core::mem::size_of::<*const u8>()).cast::<usize>() = len128;
                  *base.add(35*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr128.cast_mut();
                },
                None => {
                  {
                    *base.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match provider_id112 {
                Some(e) => {
                  *base.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec129 = (e.into_bytes()).into_boxed_slice();
                  let ptr129 = vec129.as_ptr().cast::<u8>();
                  let len129 = vec129.len();
                  ::core::mem::forget(vec129);
                  *base.add(39*::core::mem::size_of::<*const u8>()).cast::<usize>() = len129;
                  *base.add(38*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr129.cast_mut();
                },
                None => {
                  {
                    *base.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match deadline_ms112 {
                Some(e) => {
                  *base.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *base.add(8+40*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                },
                None => {
                  {
                    *base.add(40*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };*base.add(16+40*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(attempt112);
              match idempotency_key112 {
                Some(e) => {
                  *base.add(16+41*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec130 = (e.into_bytes()).into_boxed_slice();
                  let ptr130 = vec130.as_ptr().cast::<u8>();
                  let len130 = vec130.len();
                  ::core::mem::forget(vec130);
                  *base.add(16+43*::core::mem::size_of::<*const u8>()).cast::<usize>() = len130;
                  *base.add(16+42*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr130.cast_mut();
                },
                None => {
                  {
                    *base.add(16+41*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match impersonation112 {
                Some(e) => {
                  *base.add(16+44*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let super::super::super::super::greentic::interfaces_types::types::Impersonation{ actor_id:actor_id131, reason:reason131, } = e;
                  let vec132 = (actor_id131.into_bytes()).into_boxed_slice();
                  let ptr132 = vec132.as_ptr().cast::<u8>();
                  let len132 = vec132.len();
                  ::core::mem::forget(vec132);
                  *base.add(16+46*::core::mem::size_of::<*const u8>()).cast::<usize>() = len132;
                  *base.add(16+45*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr132.cast_mut();
                  match reason131 {
                    Some(e) => {
                      *base.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec133 = (e.into_bytes()).into_boxed_slice();
                      let ptr133 = vec133.as_ptr().cast::<u8>();
                      let len133 = vec133.len();
                      ::core::mem::forget(vec133);
                      *base.add(16+49*::core::mem::size_of::<*const u8>()).cast::<usize>() = len133;
                      *base.add(16+48*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr133.cast_mut();
                    },
                    None => {
                      {
                        *base.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                  None => {
                    {
                      *base.add(16+44*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let vec134 = (channel110.into_bytes()).into_boxed_slice();
                let ptr134 = vec134.as_ptr().cast::<u8>();
                let len134 = vec134.len();
                ::core::mem::forget(vec134);
                *base.add(16+51*::core::mem::size_of::<*const u8>()).cast::<usize>() = len134;
                *base.add(16+50*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr134.cast_mut();
                let vec135 = (session_id110.into_bytes()).into_boxed_slice();
                let ptr135 = vec135.as_ptr().cast::<u8>();
                let len135 = vec135.len();
                ::core::mem::forget(vec135);
                *base.add(16+53*::core::mem::size_of::<*const u8>()).cast::<usize>() = len135;
                *base.add(16+52*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr135.cast_mut();
                match user_id110 {
                  Some(e) => {
                    *base.add(16+54*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec136 = (e.into_bytes()).into_boxed_slice();
                    let ptr136 = vec136.as_ptr().cast::<u8>();
                    let len136 = vec136.len();
                    ::core::mem::forget(vec136);
                    *base.add(16+56*::core::mem::size_of::<*const u8>()).cast::<usize>() = len136;
                    *base.add(16+55*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr136.cast_mut();
                  },
                  None => {
                    {
                      *base.add(16+54*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match text110 {
                  Some(e) => {
                    *base.add(16+57*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec137 = (e.into_bytes()).into_boxed_slice();
                    let ptr137 = vec137.as_ptr().cast::<u8>();
                    let len137 = vec137.len();
                    ::core::mem::forget(vec137);
                    *base.add(16+59*::core::mem::size_of::<*const u8>()).cast::<usize>() = len137;
                    *base.add(16+58*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr137.cast_mut();
                  },
                  None => {
                    {
                      *base.add(16+57*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let vec147 = attachments110;
                let len147 = vec147.len();
                let layout147 = _rt::alloc::Layout::from_size_align(vec147.len() * (32+10*::core::mem::size_of::<*const u8>()), 8).unwrap();
                let (result147, _cleanup147) = wit_bindgen::rt::Cleanup::new(layout147);if let Some(cleanup) = _cleanup147 { cleanup.forget(); }
                for (i, e) in vec147.into_iter().enumerate() {
                  let base = result147.add(i * (32+10*::core::mem::size_of::<*const u8>()));
                  {
                    let super::super::super::super::greentic::messaging::session_api::Attachment{ mime_type:mime_type138, url:url138, name:name138, size_bytes:size_bytes138, description:description138, metadata:metadata138, } = e;
                    let vec139 = (mime_type138.into_bytes()).into_boxed_slice();
                    let ptr139 = vec139.as_ptr().cast::<u8>();
                    let len139 = vec139.len();
                    ::core::mem::forget(vec139);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len139;
                    *base.add(0).cast::<*mut u8>() = ptr139.cast_mut();
                    let vec140 = (url138.into_bytes()).into_boxed_slice();
                    let ptr140 = vec140.as_ptr().cast::<u8>();
                    let len140 = vec140.len();
                    ::core::mem::forget(vec140);
                    *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len140;
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr140.cast_mut();
                    match name138 {
                      Some(e) => {
                        *base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec141 = (e.into_bytes()).into_boxed_slice();
                        let ptr141 = vec141.as_ptr().cast::<u8>();
                        let len141 = vec141.len();
                        ::core::mem::forget(vec141);
                        *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len141;
                        *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr141.cast_mut();
                      },
                      None => {
                        {
                          *base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match size_bytes138 {
                      Some(e) => {
                        *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        *base.add(16+6*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                      },
                      None => {
                        {
                          *base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match description138 {
                      Some(e) => {
                        *base.add(24+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec142 = (e.into_bytes()).into_boxed_slice();
                        let ptr142 = vec142.as_ptr().cast::<u8>();
                        let len142 = vec142.len();
                        ::core::mem::forget(vec142);
                        *base.add(24+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len142;
                        *base.add(24+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr142.cast_mut();
                      },
                      None => {
                        {
                          *base.add(24+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };let vec146 = metadata138;
                    let len146 = vec146.len();
                    let layout146 = _rt::alloc::Layout::from_size_align(vec146.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                    let (result146, _cleanup146) = wit_bindgen::rt::Cleanup::new(layout146);if let Some(cleanup) = _cleanup146 { cleanup.forget(); }
                    for (i, e) in vec146.into_iter().enumerate() {
                      let base = result146.add(i * (4*::core::mem::size_of::<*const u8>()));
                      {
                        let (t143_0, t143_1, ) = e;
                        let vec144 = (t143_0.into_bytes()).into_boxed_slice();
                        let ptr144 = vec144.as_ptr().cast::<u8>();
                        let len144 = vec144.len();
                        ::core::mem::forget(vec144);
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len144;
                        *base.add(0).cast::<*mut u8>() = ptr144.cast_mut();
                        let vec145 = (t143_1.into_bytes()).into_boxed_slice();
                        let ptr145 = vec145.as_ptr().cast::<u8>();
                        let len145 = vec145.len();
                        ::core::mem::forget(vec145);
                        *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len145;
                        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr145.cast_mut();
                      }
                    }
                    *base.add(24+10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len146;
                    *base.add(24+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result146;
                  }
                }
                *base.add(16+61*::core::mem::size_of::<*const u8>()).cast::<usize>() = len147;
                *base.add(16+60*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result147;
                let vec151 = metadata110;
                let len151 = vec151.len();
                let layout151 = _rt::alloc::Layout::from_size_align(vec151.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                let (result151, _cleanup151) = wit_bindgen::rt::Cleanup::new(layout151);if let Some(cleanup) = _cleanup151 { cleanup.forget(); }
                for (i, e) in vec151.into_iter().enumerate() {
                  let base = result151.add(i * (4*::core::mem::size_of::<*const u8>()));
                  {
                    let (t148_0, t148_1, ) = e;
                    let vec149 = (t148_0.into_bytes()).into_boxed_slice();
                    let ptr149 = vec149.as_ptr().cast::<u8>();
                    let len149 = vec149.len();
                    ::core::mem::forget(vec149);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len149;
                    *base.add(0).cast::<*mut u8>() = ptr149.cast_mut();
                    let vec150 = (t148_1.into_bytes()).into_boxed_slice();
                    let ptr150 = vec150.as_ptr().cast::<u8>();
                    let len150 = vec150.len();
                    ::core::mem::forget(vec150);
                    *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len150;
                    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr150.cast_mut();
                  }
                }
                *base.add(16+63*::core::mem::size_of::<*const u8>()).cast::<usize>() = len151;
                *base.add(16+62*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result151;
              }
            }
            *ptr109.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len152;
            *ptr109.add(0).cast::<*mut u8>() = result152;
            ptr109
          } }
          #[doc(hidden)]
          #[allow(non_snake_case)]
          pub unsafe fn __post_return_handle_event<T: Guest>(arg0: *mut u8,) { unsafe {
            let l0 = *arg0.add(0).cast::<*mut u8>();
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base93 = l0;
            let len93 = l1;
            for i in 0..len93 {
              let base = base93.add(i * (16+64*::core::mem::size_of::<*const u8>()));
              {
                let l2 = *base.add(0).cast::<*mut u8>();
                let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l2, l3, 1);
                let l4 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l4, l5, 1);
                let l6 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l7 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l6, l7, 1);
                let l8 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l9 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l8, l9, 1);
                let l10 = i32::from(*base.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l10 {
                  0 => (),
                  _ => {
                    let l11 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l12 = *base.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l11, l12, 1);
                  },
                }
                let l13 = i32::from(*base.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l13 {
                  0 => (),
                  _ => {
                    let l14 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l15 = *base.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l14, l15, 1);
                  },
                }
                let l16 = i32::from(*base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l16 {
                  0 => (),
                  _ => {
                    let l17 = *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l18 = *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l17, l18, 1);
                  },
                }
                let l19 = i32::from(*base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l19 {
                  0 => (),
                  _ => {
                    let l20 = *base.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l21 = *base.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l20, l21, 1);
                  },
                }
                let l22 = i32::from(*base.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l22 {
                  0 => (),
                  _ => {
                    let l23 = *base.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l24 = *base.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l23, l24, 1);
                  },
                }
                let l25 = i32::from(*base.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l25 {
                  0 => (),
                  _ => {
                    let l26 = *base.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l27 = *base.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l26, l27, 1);
                  },
                }
                let l28 = *base.add(26*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l29 = *base.add(27*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base34 = l28;
                let len34 = l29;
                for i in 0..len34 {
                  let base = base34.add(i * (4*::core::mem::size_of::<*const u8>()));
                  {
                    let l30 = *base.add(0).cast::<*mut u8>();
                    let l31 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l30, l31, 1);
                    let l32 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l33 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l32, l33, 1);
                  }
                }
                _rt::cabi_dealloc(base34, len34 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                let l35 = i32::from(*base.add(28*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l35 {
                  0 => (),
                  _ => {
                    let l36 = *base.add(29*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l37 = *base.add(30*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l36, l37, 1);
                  },
                }
                let l38 = i32::from(*base.add(31*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l38 {
                  0 => (),
                  _ => {
                    let l39 = *base.add(32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l40 = *base.add(33*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l39, l40, 1);
                  },
                }
                let l41 = i32::from(*base.add(34*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l41 {
                  0 => (),
                  _ => {
                    let l42 = *base.add(35*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l43 = *base.add(36*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l42, l43, 1);
                  },
                }
                let l44 = i32::from(*base.add(37*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l44 {
                  0 => (),
                  _ => {
                    let l45 = *base.add(38*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l46 = *base.add(39*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l45, l46, 1);
                  },
                }
                let l47 = i32::from(*base.add(16+41*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l47 {
                  0 => (),
                  _ => {
                    let l48 = *base.add(16+42*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l49 = *base.add(16+43*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l48, l49, 1);
                  },
                }
                let l50 = i32::from(*base.add(16+44*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l50 {
                  0 => (),
                  _ => {
                    let l51 = *base.add(16+45*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l52 = *base.add(16+46*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l51, l52, 1);
                    let l53 = i32::from(*base.add(16+47*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l53 {
                      0 => (),
                      _ => {
                        let l54 = *base.add(16+48*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l55 = *base.add(16+49*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l54, l55, 1);
                      },
                    }
                  },
                }
                let l56 = *base.add(16+50*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l57 = *base.add(16+51*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l56, l57, 1);
                let l58 = *base.add(16+52*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l59 = *base.add(16+53*::core::mem::size_of::<*const u8>()).cast::<usize>();
                _rt::cabi_dealloc(l58, l59, 1);
                let l60 = i32::from(*base.add(16+54*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l60 {
                  0 => (),
                  _ => {
                    let l61 = *base.add(16+55*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l62 = *base.add(16+56*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l61, l62, 1);
                  },
                }
                let l63 = i32::from(*base.add(16+57*::core::mem::size_of::<*const u8>()).cast::<u8>());
                match l63 {
                  0 => (),
                  _ => {
                    let l64 = *base.add(16+58*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l65 = *base.add(16+59*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l64, l65, 1);
                  },
                }
                let l66 = *base.add(16+60*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l67 = *base.add(16+61*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base85 = l66;
                let len85 = l67;
                for i in 0..len85 {
                  let base = base85.add(i * (32+10*::core::mem::size_of::<*const u8>()));
                  {
                    let l68 = *base.add(0).cast::<*mut u8>();
                    let l69 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l68, l69, 1);
                    let l70 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l71 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l70, l71, 1);
                    let l72 = i32::from(*base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l72 {
                      0 => (),
                      _ => {
                        let l73 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l74 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l73, l74, 1);
                      },
                    }
                    let l75 = i32::from(*base.add(24+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l75 {
                      0 => (),
                      _ => {
                        let l76 = *base.add(24+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l77 = *base.add(24+8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l76, l77, 1);
                      },
                    }
                    let l78 = *base.add(24+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l79 = *base.add(24+10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base84 = l78;
                    let len84 = l79;
                    for i in 0..len84 {
                      let base = base84.add(i * (4*::core::mem::size_of::<*const u8>()));
                      {
                        let l80 = *base.add(0).cast::<*mut u8>();
                        let l81 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l80, l81, 1);
                        let l82 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l83 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l82, l83, 1);
                      }
                    }
                    _rt::cabi_dealloc(base84, len84 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  }
                }
                _rt::cabi_dealloc(base85, len85 * (32+10*::core::mem::size_of::<*const u8>()), 8);
                let l86 = *base.add(16+62*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l87 = *base.add(16+63*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base92 = l86;
                let len92 = l87;
                for i in 0..len92 {
                  let base = base92.add(i * (4*::core::mem::size_of::<*const u8>()));
                  {
                    let l88 = *base.add(0).cast::<*mut u8>();
                    let l89 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l88, l89, 1);
                    let l90 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l91 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    _rt::cabi_dealloc(l90, l91, 1);
                  }
                }
                _rt::cabi_dealloc(base92, len92 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              }
            }
            _rt::cabi_dealloc(base93, len93 * (16+64*::core::mem::size_of::<*const u8>()), 8);
          } }
          pub trait Guest {
            /// Transform a channel message into zero or more events.
            #[allow(async_fn_in_trait)]
            fn handle_message(msg: ChannelMessageEnvelope,) -> _rt::Vec::<EventEnvelope>;
            /// Transform an event into zero or more channel messages.
            #[allow(async_fn_in_trait)]
            fn handle_event(ev: EventEnvelope,) -> _rt::Vec::<ChannelMessageEnvelope>;
          }
          #[doc(hidden)]

          macro_rules! __export_greentic_events_bridge_bridge_api_1_0_0_cabi{
            ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

              #[unsafe(export_name = "greentic:events-bridge/bridge-api@1.0.0#handle-message")]
              unsafe extern "C" fn export_handle_message(arg0: *mut u8,) -> *mut u8 {
                unsafe { $($path_to_types)*::_export_handle_message_cabi::<$ty>(arg0) }
              }
              #[unsafe(export_name = "cabi_post_greentic:events-bridge/bridge-api@1.0.0#handle-message")]
              unsafe extern "C" fn _post_return_handle_message(arg0: *mut u8,) {
                unsafe { $($path_to_types)*::__post_return_handle_message::<$ty>(arg0) }
              }
              #[unsafe(export_name = "greentic:events-bridge/bridge-api@1.0.0#handle-event")]
              unsafe extern "C" fn export_handle_event(arg0: *mut u8,) -> *mut u8 {
                unsafe { $($path_to_types)*::_export_handle_event_cabi::<$ty>(arg0) }
              }
              #[unsafe(export_name = "cabi_post_greentic:events-bridge/bridge-api@1.0.0#handle-event")]
              unsafe extern "C" fn _post_return_handle_event(arg0: *mut u8,) {
                unsafe { $($path_to_types)*::__post_return_handle_event::<$ty>(arg0) }
              }
            };);
          }
          #[doc(hidden)]
          pub(crate) use __export_greentic_events_bridge_bridge_api_1_0_0_cabi;

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct _RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);

        }

      }
    }
  }
  mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::alloc;

    pub fn as_i64<T: AsI64>(t: T) -> i64 {
      t.as_i64()
    }

    pub trait AsI64 {
      fn as_i64(self) -> i64;
    }

    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
      fn as_i64(self) -> i64 {
        (*self).as_i64()
      }
    }
    
    impl AsI64 for i64 {
      #[inline]
      fn as_i64(self) -> i64 {
        self as i64
      }
    }
    
    impl AsI64 for u64 {
      #[inline]
      fn as_i64(self) -> i64 {
        self as i64
      }
    }
    
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
      t.as_i32()
    }

    pub trait AsI32 {
      fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
      fn as_i32(self) -> i32 {
        (*self).as_i32()
      }
    }
    
    impl AsI32 for i32 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for u32 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for i16 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for u16 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for i8 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for u8 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for char {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for usize {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
      if cfg!(debug_assertions) {
        String::from_utf8(bytes).unwrap()
      } else {
        unsafe { String::from_utf8_unchecked(bytes) }
      }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
      if cfg!(debug_assertions) {
        panic!("invalid enum discriminant")
      } else {
        unsafe { core::hint::unreachable_unchecked() }
      }
    }
    
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
      wit_bindgen::rt::run_ctors_once();
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
      if size == 0 {
        return;
      }
      unsafe {
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
      }
    }
    extern crate alloc as alloc_crate;
  }

  /// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
  /// the root implementation of all generated traits.
  ///
  /// For more information see the documentation of `wit_bindgen::generate!`.
  ///
  /// ```rust
  /// # macro_rules! export{ ($($t:tt)*) => (); }
  /// # trait Guest {}
  /// struct MyType;
  ///
  /// impl Guest for MyType {
  ///     // ...
  /// }
  ///
  /// export!(MyType);
  /// ```
  #[allow(unused_macros)]
  #[doc(hidden)]

  macro_rules! __export_event_to_message_bridge_impl {
    ($ty:ident) => (self::export!($ty with_types_in self););
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
    $($path_to_types_root)*::exports::greentic::events_bridge::bridge_api::__export_greentic_events_bridge_bridge_api_1_0_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::greentic::events_bridge::bridge_api);
    )
  }
  #[doc(inline)]
  pub(crate) use __export_event_to_message_bridge_impl as export;

  #[cfg(target_arch = "wasm32")]
  #[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:events-bridge@1.0.0:event-to-message-bridge:encoded world")]
  #[doc(hidden)]
  #[allow(clippy::octal_escapes)]
  pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2629] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb7\x13\x01A\x02\x01\
A\x0b\x01B6\x01s\x04\0\x06env-id\x03\0\0\x01s\x04\0\x09tenant-id\x03\0\x02\x01s\x04\
\0\x07team-id\x03\0\x04\x01s\x04\0\x07user-id\x03\0\x06\x01s\x04\0\x09state-key\x03\
\0\x08\x01s\x04\0\x0bsession-key\x03\0\x0a\x01ks\x01r\x02\x08actor-id\x07\x06rea\
son\x0c\x04\0\x0dimpersonation\x03\0\x0d\x01k\x05\x01k\x07\x01o\x02ss\x01p\x11\x01\
kx\x01k\x0e\x01r\x12\x03env\x01\x06tenant\x03\x09tenant-id\x03\x04team\x0f\x07te\
am-id\x0f\x04user\x10\x07user-id\x10\x08trace-id\x0c\x0ecorrelation-id\x0c\x0aat\
tributes\x12\x0asession-id\x0c\x07flow-id\x0c\x07node-id\x0c\x0bprovider-id\x0c\x0b\
deadline-ms\x13\x07attempty\x0fidempotency-key\x0c\x0dimpersonation\x14\x04\0\x0a\
tenant-ctx\x03\0\x15\x01r\x03\x0cnode-pointers\x0bwait-reason\x0c\x0doutbox-mark\
er\x0c\x04\0\x0esession-cursor\x03\0\x17\x01m\x0a\x07unknown\x0dinvalid-input\x09\
not-found\x08conflict\x07timeout\x0funauthenticated\x11permission-denied\x0crate\
-limited\x0bunavailable\x08internal\x04\0\x0aerror-code\x03\0\x19\x01ps\x01k\x1b\
\x01r\x02\x06reasons\x0eexpected-input\x1c\x04\0\x0foutcome-pending\x03\0\x1d\x01\
r\x02\x04code\x1a\x07messages\x04\0\x0doutcome-error\x03\0\x1f\x01q\x03\x04done\x01\
s\0\x07pending\x01\x1e\0\x05error\x01\x20\0\x04\0\x07outcome\x03\0!\x01q\x06\x04\
http\0\0\x05https\0\0\x03tcp\0\0\x03udp\0\0\x04grpc\0\0\x06custom\x01s\0\x04\0\x08\
protocol\x03\0#\x01p{\x01p$\x01r\x03\x07domains\x1b\x05ports%\x09protocols&\x04\0\
\x0aallow-list\x03\0'\x01r\x02\x06egress(\x0cdeny-on-miss\x7f\x04\0\x0enetwork-p\
olicy\x03\0)\x01q\x02\x07ed25519\0\0\x05other\x01s\0\x04\0\x13signature-algorith\
m\x03\0+\x01p}\x01r\x03\x06key-ids\x09algorithm,\x09signature-\x04\0\x09signatur\
e\x03\0.\x01p/\x01r\x04\x07oci-urls\x07versions\x06digests\x0asignatures0\x04\0\x08\
pack-ref\x03\01\x01k\x0b\x01r\x07\x06tenant\x03\x0asession-id3\x07flow-ids\x07no\
de-id\x0c\x08providers\x08start-ms\x13\x06end-ms\x13\x04\0\x0cspan-context\x03\0\
4\x03\0%greentic:interfaces-types/types@0.1.0\x05\0\x02\x03\0\0\x0atenant-ctx\x01\
B\x1c\x02\x03\x02\x01\x01\x04\0\x0atenant-ctx\x03\0\0\x01o\x02ss\x04\0\x0emetada\
ta-entry\x03\0\x02\x01ks\x01p\x03\x01r\x0a\x02ids\x05topics\x04types\x06sources\x06\
tenant\x01\x07subject\x04\x04times\x0ecorrelation-id\x04\x0cpayload-jsons\x08met\
adata\x05\x04\0\x0eevent-envelope\x03\0\x06\x01s\x04\0\x0fsubscription-id\x03\0\x08\
\x01ps\x01k\x01\x01r\x03\x06topics\x0a\x06tenant\x0b\x06cursor\x04\x04\0\x0dsour\
ce-config\x03\0\x0c\x01r\x02\x05topics\x06tenant\x0b\x04\0\x0bsink-config\x03\0\x0e\
\x01m\x03\x02ok\x11retryable-failure\x11permanent-failure\x04\0\x0fdelivery-stat\
us\x03\0\x10\x01r\x03\x06status\x11\x0aerror-code\x04\x0derror-message\x04\x04\0\
\x0fdelivery-result\x03\0\x12\x01m\x02\x04auto\x06manual\x04\0\x08ack-mode\x03\0\
\x14\x01r\x03\x07durable\x7f\x10deliver-existing\x7f\x08ack-mode\x15\x04\0\x14su\
bscription-options\x03\0\x16\x01r\x02\x04codes\x07messages\x04\0\x0ahost-error\x03\
\0\x18\x01m\x01\x02ok\x04\0\x06op-ack\x03\0\x1a\x03\0!greentic:events/event-type\
s@1.0.0\x05\x02\x01B\x18\x02\x03\x02\x01\x01\x04\0\x0atenant-ctx\x03\0\0\x01o\x02\
ss\x04\0\x0emetadata-entry\x03\0\x02\x01ks\x01kw\x01p\x03\x01r\x06\x09mime-types\
\x03urls\x04name\x04\x0asize-bytes\x05\x0bdescription\x04\x08metadata\x06\x04\0\x0a\
attachment\x03\0\x07\x01p\x08\x01r\x08\x02ids\x06tenant\x01\x07channels\x0asessi\
on-ids\x07user-id\x04\x04text\x04\x0battachments\x09\x08metadata\x06\x04\0\x18ch\
annel-message-envelope\x03\0\x0a\x01r\x02\x04codes\x07messages\x04\0\x0ahost-err\
or\x03\0\x0c\x01m\x01\x02ok\x04\0\x06op-ack\x03\0\x0e\x01p}\x01p\x10\x01k\x11\x01\
r\x03\x05route\x04\x0cpayload-jsons\x0battachments\x12\x04\0\x10outbound-message\
\x03\0\x13\x01j\x01\x0f\x01\x0d\x01@\x02\x07message\x14\x03ctx\x01\0\x15\x04\0\x04\
send\x01\x16\x03\0$greentic:messaging/session-api@1.0.0\x05\x03\x02\x03\0\x01\x0e\
event-envelope\x02\x03\0\x02\x18channel-message-envelope\x01B\x0c\x02\x03\x02\x01\
\x01\x04\0\x0atenant-ctx\x03\0\0\x02\x03\x02\x01\x04\x04\0\x0eevent-envelope\x03\
\0\x02\x02\x03\x02\x01\x05\x04\0\x18channel-message-envelope\x03\0\x04\x01p\x03\x01\
@\x01\x03msg\x05\0\x06\x04\0\x0ehandle-message\x01\x07\x01p\x05\x01@\x01\x02ev\x03\
\0\x08\x04\0\x0chandle-event\x01\x09\x04\0'greentic:events-bridge/bridge-api@1.0\
.0\x05\x06\x04\04greentic:events-bridge/event-to-message-bridge@1.0.0\x04\0\x0b\x1d\
\x01\0\x17event-to-message-bridge\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\
\x0dwit-component\x070.240.0\x10wit-bindgen-rust\x060.47.0";

  #[inline(never)]
  #[doc(hidden)]
  pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
  }
  
