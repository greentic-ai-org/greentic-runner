// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod greentic {
  pub mod host {
    /// Minimal HTTP client surface runner hosts expose to components.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod http_v1 {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn request(method: &str,url: &str,headers: &[_rt::String],body: Option<&[u8]>,) -> Result<_rt::Vec::<u8>,_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = method;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = url;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec3 = headers;
          let len3 = vec3.len();
          let layout3 = _rt::alloc::Layout::from_size_align(vec3.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
          let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(layout3);for (i, e) in vec3.into_iter().enumerate() {
            let base = result3.add(i * (2*::core::mem::size_of::<*const u8>()));
            {
              let vec2 = e;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
              *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
            }
          }
          let (result5_0,result5_1,result5_2,) = match body {
            Some(e) => {
              let vec4 = e;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();

              (1i32, ptr4.cast_mut(), len4)
            },
            None => {
              (0i32, ::core::ptr::null_mut(), 0usize)
            },
          };let ptr6 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "greentic:host/http-v1@1.0.0")]
          unsafe extern "C" {
            #[link_name = "request"]
            fn wit_import7(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import7(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import7(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, result3, len3, result5_0, result5_1, result5_2, ptr6);
          let l8 = i32::from(*ptr6.add(0).cast::<u8>());
          let result15 = match l8 {
            0 => {
              let e = {
                let l9 = *ptr6.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l10 = *ptr6.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len11 = l10;

                _rt::Vec::from_raw_parts(l9.cast(), len11, len11)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l12 = *ptr6.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l13 = *ptr6.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len14 = l13;
                let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                _rt::string_lift(bytes14)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result15
        }
      }

    }

    /// Secret resolution bridge so runners can plug different providers.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod secrets_v1 {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn get(name: &str,) -> Result<_rt::String,_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "greentic:host/secrets-v1@1.0.0")]
          unsafe extern "C" {
            #[link_name = "get"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result10 = match l3 {
            0 => {
              let e = {
                let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                _rt::string_lift(bytes6)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l8 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len9 = l8;
                let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                _rt::string_lift(bytes9)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result10
        }
      }

    }

    /// Host-provided key-value store scoped by namespace.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod kv_v1 {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn get(ns: &str,key: &str,) -> Option<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = ns;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = key;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "greentic:host/kv-v1@1.0.0")]
          unsafe extern "C" {
            #[link_name = "get"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l4 = i32::from(*ptr2.add(0).cast::<u8>());
          let result8 = match l4 {
            0 => None,
            1 => {
              let e = {
                let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result8
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn put(ns: &str,key: &str,val: &str,) -> (){
        unsafe {
          let vec0 = ns;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = key;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let vec2 = val;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "greentic:host/kv-v1@1.0.0")]
          unsafe extern "C" {
            #[link_name = "put"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2.cast_mut(), len2);
        }
      }

    }

  }
}
mod _rt {
  #![allow(dead_code, clippy::all)]
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::alloc;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:host@1.0.0:runner-host:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 415] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x9d\x02\x01A\x02\x01\
A\x06\x01B\x06\x01ps\x01p}\x01k\x01\x01j\x01\x01\x01s\x01@\x04\x06methods\x03url\
s\x07headers\0\x04body\x02\0\x03\x04\0\x07request\x01\x04\x03\0\x1bgreentic:host\
/http-v1@1.0.0\x05\0\x01B\x03\x01j\x01s\x01s\x01@\x01\x04names\0\0\x04\0\x03get\x01\
\x01\x03\0\x1egreentic:host/secrets-v1@1.0.0\x05\x01\x01B\x05\x01ks\x01@\x02\x02\
nss\x03keys\0\0\x04\0\x03get\x01\x01\x01@\x03\x02nss\x03keys\x03vals\x01\0\x04\0\
\x03put\x01\x02\x03\0\x19greentic:host/kv-v1@1.0.0\x05\x02\x04\0\x1fgreentic:hos\
t/runner-host@1.0.0\x04\0\x0b\x11\x01\0\x0brunner-host\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.240.0\x10wit-bindgen-rust\x060.47.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

