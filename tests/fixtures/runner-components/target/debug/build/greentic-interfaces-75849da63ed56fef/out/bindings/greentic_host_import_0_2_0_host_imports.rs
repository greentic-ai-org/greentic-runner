// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod greentic {
  pub mod host_import {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod imports {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// Supported clouds and platforms mirror the types-core package. Duplicated for independence.
      #[derive(Clone, Copy)]
      pub enum Cloud {
        Aws,
        Gcp,
        Azure,
        Hetzner,
        Local,
        Other,
      }
      impl ::core::fmt::Debug for Cloud {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Cloud::Aws => {
              f.debug_tuple("Cloud::Aws").finish()
            }
            Cloud::Gcp => {
              f.debug_tuple("Cloud::Gcp").finish()
            }
            Cloud::Azure => {
              f.debug_tuple("Cloud::Azure").finish()
            }
            Cloud::Hetzner => {
              f.debug_tuple("Cloud::Hetzner").finish()
            }
            Cloud::Local => {
              f.debug_tuple("Cloud::Local").finish()
            }
            Cloud::Other => {
              f.debug_tuple("Cloud::Other").finish()
            }
          }
        }
      }
      #[derive(Clone, Copy)]
      pub enum Platform {
        K8s,
        Nomad,
        Systemd,
        Cfworkers,
        Lambda,
        Baremetal,
        Other,
      }
      impl ::core::fmt::Debug for Platform {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Platform::K8s => {
              f.debug_tuple("Platform::K8s").finish()
            }
            Platform::Nomad => {
              f.debug_tuple("Platform::Nomad").finish()
            }
            Platform::Systemd => {
              f.debug_tuple("Platform::Systemd").finish()
            }
            Platform::Cfworkers => {
              f.debug_tuple("Platform::Cfworkers").finish()
            }
            Platform::Lambda => {
              f.debug_tuple("Platform::Lambda").finish()
            }
            Platform::Baremetal => {
              f.debug_tuple("Platform::Baremetal").finish()
            }
            Platform::Other => {
              f.debug_tuple("Platform::Other").finish()
            }
          }
        }
      }
      pub type FlowId = _rt::String;
      pub type TenantId = _rt::String;
      pub type TeamId = _rt::String;
      pub type UserId = _rt::String;
      #[derive(Clone)]
      pub struct DeploymentCtx {
        pub cloud: Cloud,
        pub region: Option<_rt::String>,
        pub platform: Platform,
        pub runtime: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for DeploymentCtx {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeploymentCtx").field("cloud", &self.cloud).field("region", &self.region).field("platform", &self.platform).field("runtime", &self.runtime).finish()
        }
      }
      #[derive(Clone)]
      pub struct TenantCtx {
        pub tenant: TenantId,
        pub team: Option<TeamId>,
        pub user: Option<UserId>,
        pub deployment: DeploymentCtx,
        pub trace_id: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for TenantCtx {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TenantCtx").field("tenant", &self.tenant).field("team", &self.team).field("user", &self.user).field("deployment", &self.deployment).field("trace-id", &self.trace_id).finish()
        }
      }
      #[derive(Clone, Copy)]
      pub enum IfaceError {
        InvalidArg,
        NotFound,
        Denied,
        Unavailable,
        Internal,
      }
      impl ::core::fmt::Debug for IfaceError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            IfaceError::InvalidArg => {
              f.debug_tuple("IfaceError::InvalidArg").finish()
            }
            IfaceError::NotFound => {
              f.debug_tuple("IfaceError::NotFound").finish()
            }
            IfaceError::Denied => {
              f.debug_tuple("IfaceError::Denied").finish()
            }
            IfaceError::Unavailable => {
              f.debug_tuple("IfaceError::Unavailable").finish()
            }
            IfaceError::Internal => {
              f.debug_tuple("IfaceError::Internal").finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for IfaceError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }

      impl ::core::error::Error for IfaceError {}
      #[derive(Clone)]
      pub struct HttpRequest {
        pub method: _rt::String,
        pub url: _rt::String,
        pub headers_json: Option<_rt::String>,
        pub body: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for HttpRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("HttpRequest").field("method", &self.method).field("url", &self.url).field("headers-json", &self.headers_json).field("body", &self.body).finish()
        }
      }
      #[derive(Clone)]
      pub struct HttpResponse {
        pub status: u16,
        pub headers_json: Option<_rt::String>,
        pub body: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for HttpResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("HttpResponse").field("status", &self.status).field("headers-json", &self.headers_json).field("body", &self.body).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Secret management hook exposed by the host.
      #[allow(async_fn_in_trait)]
      pub fn secrets_get(key: &str,ctx: Option<&TenantCtx>,) -> Result<_rt::String,IfaceError>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 22*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 22*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = key;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
          *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
          match ctx {
            Some(e) => {
              *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let TenantCtx{ tenant:tenant2, team:team2, user:user2, deployment:deployment2, trace_id:trace_id2, } = e;
              let vec3 = tenant2;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
              *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
              match team2 {
                Some(e) => {
                  *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();
                  *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                  *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match user2 {
                Some(e) => {
                  *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec5 = e;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let DeploymentCtx{ cloud:cloud6, region:region6, platform:platform6, runtime:runtime6, } = deployment2;
              match cloud6 {
                Cloud::Aws=> {
                  {
                    *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                }
                Cloud::Gcp=> {
                  {
                    *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  }
                }
                Cloud::Azure=> {
                  {
                    *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                  }
                }
                Cloud::Hetzner=> {
                  {
                    *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                  }
                }
                Cloud::Local=> {
                  {
                    *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                  }
                }
                Cloud::Other=> {
                  {
                    *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                  }
                }
              }
              match region6 {
                Some(e) => {
                  *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec7 = e;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                  *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match platform6 {
                Platform::K8s=> {
                  {
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                }
                Platform::Nomad=> {
                  {
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  }
                }
                Platform::Systemd=> {
                  {
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                  }
                }
                Platform::Cfworkers=> {
                  {
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                  }
                }
                Platform::Lambda=> {
                  {
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                  }
                }
                Platform::Baremetal=> {
                  {
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                  }
                }
                Platform::Other=> {
                  {
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32) as u8;
                  }
                }
              }
              match runtime6 {
                Some(e) => {
                  *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec8 = e;
                  let ptr8 = vec8.as_ptr().cast::<u8>();
                  let len8 = vec8.len();
                  *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                  *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match trace_id2 {
                Some(e) => {
                  *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec9 = e;
                  let ptr9 = vec9.as_ptr().cast::<u8>();
                  let len9 = vec9.len();
                  *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                  *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };},
              None => {
                {
                  *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };let ptr10 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "greentic:host-import/imports@0.2.0")]
            unsafe extern "C" {
              #[link_name = "secrets-get"]
              fn wit_import11(_: *mut u8, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import11(_: *mut u8, _: *mut u8, ) { unreachable!() }
            wit_import11(ptr0, ptr10);
            let l12 = i32::from(*ptr10.add(0).cast::<u8>());
            let result18 = match l12 {
              0 => {
                let e = {
                  let l13 = *ptr10.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l14 = *ptr10.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len15 = l14;
                  let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                  _rt::string_lift(bytes15)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l16 = i32::from(*ptr10.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let v17 = match l16 {
                    0 => {
                      IfaceError::InvalidArg
                    }
                    1 => {
                      IfaceError::NotFound
                    }
                    2 => {
                      IfaceError::Denied
                    }
                    3 => {
                      IfaceError::Unavailable
                    }
                    n => {
                      debug_assert_eq!(n, 4, "invalid enum discriminant");
                      IfaceError::Internal
                    }
                  };

                  v17
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result18
          }
        }
        #[allow(unused_unsafe, clippy::all)]
        /// Telemetry emission hook.
        #[allow(async_fn_in_trait)]
        pub fn telemetry_emit(span_json: &str,ctx: Option<&TenantCtx>,) -> (){
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 22*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 22*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = span_json;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
            *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
            match ctx {
              Some(e) => {
                *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let TenantCtx{ tenant:tenant2, team:team2, user:user2, deployment:deployment2, trace_id:trace_id2, } = e;
                let vec3 = tenant2;
                let ptr3 = vec3.as_ptr().cast::<u8>();
                let len3 = vec3.len();
                *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                match team2 {
                  Some(e) => {
                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec4 = e;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match user2 {
                  Some(e) => {
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec5 = e;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let DeploymentCtx{ cloud:cloud6, region:region6, platform:platform6, runtime:runtime6, } = deployment2;
                match cloud6 {
                  Cloud::Aws=> {
                    {
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  }
                  Cloud::Gcp=> {
                    {
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    }
                  }
                  Cloud::Azure=> {
                    {
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                    }
                  }
                  Cloud::Hetzner=> {
                    {
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                    }
                  }
                  Cloud::Local=> {
                    {
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                    }
                  }
                  Cloud::Other=> {
                    {
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                    }
                  }
                }
                match region6 {
                  Some(e) => {
                    *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec7 = e;
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match platform6 {
                  Platform::K8s=> {
                    {
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  }
                  Platform::Nomad=> {
                    {
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    }
                  }
                  Platform::Systemd=> {
                    {
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                    }
                  }
                  Platform::Cfworkers=> {
                    {
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                    }
                  }
                  Platform::Lambda=> {
                    {
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                    }
                  }
                  Platform::Baremetal=> {
                    {
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                    }
                  }
                  Platform::Other=> {
                    {
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32) as u8;
                    }
                  }
                }
                match runtime6 {
                  Some(e) => {
                    *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec8 = e;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                    *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match trace_id2 {
                  Some(e) => {
                    *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec9 = e;
                    let ptr9 = vec9.as_ptr().cast::<u8>();
                    let len9 = vec9.len();
                    *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };},
                None => {
                  {
                    *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "greentic:host-import/imports@0.2.0")]
              unsafe extern "C" {
                #[link_name = "telemetry-emit"]
                fn wit_import10(_: *mut u8, );
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn wit_import10(_: *mut u8, ) { unreachable!() }
              wit_import10(ptr0);
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          /// Tool invocation hook for side-effecting operations.
          #[allow(async_fn_in_trait)]
          pub fn tool_invoke(tool: &str,action: &str,args_json: &str,ctx: Option<&TenantCtx>,) -> Result<_rt::String,IfaceError>{
            unsafe {

              #[cfg_attr(target_pointer_width="64", repr(align(8)))]
              #[cfg_attr(target_pointer_width="32", repr(align(4)))]
              struct RetArea([::core::mem::MaybeUninit::<u8>; 26*::core::mem::size_of::<*const u8>()]);
              let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 26*::core::mem::size_of::<*const u8>()]);
              let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = tool;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();
              *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
              *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
              let vec2 = action;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
              *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
              let vec3 = args_json;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
              *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
              match ctx {
                Some(e) => {
                  *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let TenantCtx{ tenant:tenant4, team:team4, user:user4, deployment:deployment4, trace_id:trace_id4, } = e;
                  let vec5 = tenant4;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                  match team4 {
                    Some(e) => {
                      *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec6 = e;
                      let ptr6 = vec6.as_ptr().cast::<u8>();
                      let len6 = vec6.len();
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                      *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match user4 {
                    Some(e) => {
                      *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec7 = e;
                      let ptr7 = vec7.as_ptr().cast::<u8>();
                      let len7 = vec7.len();
                      *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                      *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let DeploymentCtx{ cloud:cloud8, region:region8, platform:platform8, runtime:runtime8, } = deployment4;
                  match cloud8 {
                    Cloud::Aws=> {
                      {
                        *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    }
                    Cloud::Gcp=> {
                      {
                        *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      }
                    }
                    Cloud::Azure=> {
                      {
                        *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                      }
                    }
                    Cloud::Hetzner=> {
                      {
                        *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                      }
                    }
                    Cloud::Local=> {
                      {
                        *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                      }
                    }
                    Cloud::Other=> {
                      {
                        *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                      }
                    }
                  }
                  match region8 {
                    Some(e) => {
                      *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec9 = e;
                      let ptr9 = vec9.as_ptr().cast::<u8>();
                      let len9 = vec9.len();
                      *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                      *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match platform8 {
                    Platform::K8s=> {
                      {
                        *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    }
                    Platform::Nomad=> {
                      {
                        *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      }
                    }
                    Platform::Systemd=> {
                      {
                        *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                      }
                    }
                    Platform::Cfworkers=> {
                      {
                        *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                      }
                    }
                    Platform::Lambda=> {
                      {
                        *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                      }
                    }
                    Platform::Baremetal=> {
                      {
                        *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                      }
                    }
                    Platform::Other=> {
                      {
                        *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32) as u8;
                      }
                    }
                  }
                  match runtime8 {
                    Some(e) => {
                      *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec10 = e;
                      let ptr10 = vec10.as_ptr().cast::<u8>();
                      let len10 = vec10.len();
                      *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                      *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match trace_id4 {
                    Some(e) => {
                      *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec11 = e;
                      let ptr11 = vec11.as_ptr().cast::<u8>();
                      let len11 = vec11.len();
                      *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                      *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                  None => {
                    {
                      *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let ptr12 = ret_area.0.as_mut_ptr().cast::<u8>();
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "greentic:host-import/imports@0.2.0")]
                unsafe extern "C" {
                  #[link_name = "tool-invoke"]
                  fn wit_import13(_: *mut u8, _: *mut u8, );
                }

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn wit_import13(_: *mut u8, _: *mut u8, ) { unreachable!() }
                wit_import13(ptr0, ptr12);
                let l14 = i32::from(*ptr12.add(0).cast::<u8>());
                let result20 = match l14 {
                  0 => {
                    let e = {
                      let l15 = *ptr12.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l16 = *ptr12.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len17 = l16;
                      let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                      _rt::string_lift(bytes17)
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l18 = i32::from(*ptr12.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let v19 = match l18 {
                        0 => {
                          IfaceError::InvalidArg
                        }
                        1 => {
                          IfaceError::NotFound
                        }
                        2 => {
                          IfaceError::Denied
                        }
                        3 => {
                          IfaceError::Unavailable
                        }
                        n => {
                          debug_assert_eq!(n, 4, "invalid enum discriminant");
                          IfaceError::Internal
                        }
                      };

                      v19
                    };
                    Err(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                };
                result20
              }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// HTTP fetch helper for components that need outbound calls.
            #[allow(async_fn_in_trait)]
            pub fn http_fetch(req: &HttpRequest,ctx: Option<&TenantCtx>,) -> Result<HttpResponse,IfaceError>{
              unsafe {

                #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                struct RetArea([::core::mem::MaybeUninit::<u8>; 30*::core::mem::size_of::<*const u8>()]);
                let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 30*::core::mem::size_of::<*const u8>()]);
                let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let HttpRequest{ method:method1, url:url1, headers_json:headers_json1, body:body1, } = req;
                let vec2 = method1;
                let ptr2 = vec2.as_ptr().cast::<u8>();
                let len2 = vec2.len();
                *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                let vec3 = url1;
                let ptr3 = vec3.as_ptr().cast::<u8>();
                let len3 = vec3.len();
                *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                match headers_json1 {
                  Some(e) => {
                    *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec4 = e;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match body1 {
                  Some(e) => {
                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec5 = e;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match ctx {
                  Some(e) => {
                    *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let TenantCtx{ tenant:tenant6, team:team6, user:user6, deployment:deployment6, trace_id:trace_id6, } = e;
                    let vec7 = tenant6;
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                    match team6 {
                      Some(e) => {
                        *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec8 = e;
                        let ptr8 = vec8.as_ptr().cast::<u8>();
                        let len8 = vec8.len();
                        *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                        *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match user6 {
                      Some(e) => {
                        *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec9 = e;
                        let ptr9 = vec9.as_ptr().cast::<u8>();
                        let len9 = vec9.len();
                        *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                        *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };let DeploymentCtx{ cloud:cloud10, region:region10, platform:platform10, runtime:runtime10, } = deployment6;
                    match cloud10 {
                      Cloud::Aws=> {
                        {
                          *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      }
                      Cloud::Gcp=> {
                        {
                          *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        }
                      }
                      Cloud::Azure=> {
                        {
                          *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                        }
                      }
                      Cloud::Hetzner=> {
                        {
                          *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                        }
                      }
                      Cloud::Local=> {
                        {
                          *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                        }
                      }
                      Cloud::Other=> {
                        {
                          *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                        }
                      }
                    }
                    match region10 {
                      Some(e) => {
                        *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec11 = e;
                        let ptr11 = vec11.as_ptr().cast::<u8>();
                        let len11 = vec11.len();
                        *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                        *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match platform10 {
                      Platform::K8s=> {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      }
                      Platform::Nomad=> {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        }
                      }
                      Platform::Systemd=> {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                        }
                      }
                      Platform::Cfworkers=> {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                        }
                      }
                      Platform::Lambda=> {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                        }
                      }
                      Platform::Baremetal=> {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
                        }
                      }
                      Platform::Other=> {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32) as u8;
                        }
                      }
                    }
                    match runtime10 {
                      Some(e) => {
                        *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec12 = e;
                        let ptr12 = vec12.as_ptr().cast::<u8>();
                        let len12 = vec12.len();
                        *ptr0.add(26*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                        *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match trace_id6 {
                      Some(e) => {
                        *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec13 = e;
                        let ptr13 = vec13.as_ptr().cast::<u8>();
                        let len13 = vec13.len();
                        *ptr0.add(29*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                        *ptr0.add(28*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr13.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };},
                    None => {
                      {
                        *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let ptr14 = ret_area.0.as_mut_ptr().cast::<u8>();
                  #[cfg(target_arch = "wasm32")]
                  #[link(wasm_import_module = "greentic:host-import/imports@0.2.0")]
                  unsafe extern "C" {
                    #[link_name = "http-fetch"]
                    fn wit_import15(_: *mut u8, _: *mut u8, );
                  }

                  #[cfg(not(target_arch = "wasm32"))]
                  unsafe extern "C" fn wit_import15(_: *mut u8, _: *mut u8, ) { unreachable!() }
                  wit_import15(ptr0, ptr14);
                  let l16 = i32::from(*ptr14.add(0).cast::<u8>());
                  let result28 = match l16 {
                    0 => {
                      let e = {
                        let l17 = i32::from(*ptr14.add(::core::mem::size_of::<*const u8>()).cast::<u16>());
                        let l18 = i32::from(*ptr14.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let l22 = i32::from(*ptr14.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                        HttpResponse{
                          status: l17 as u16,
                          headers_json: match l18 {
                            0 => None,
                            1 => {
                              let e = {
                                let l19 = *ptr14.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l20 = *ptr14.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len21 = l20;
                                let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);

                                _rt::string_lift(bytes21)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                          body: match l22 {
                            0 => None,
                            1 => {
                              let e = {
                                let l23 = *ptr14.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                let l24 = *ptr14.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                let len25 = l24;
                                let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);

                                _rt::string_lift(bytes25)
                              };
                              Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                          },
                        }
                      };
                      Ok(e)
                    }
                    1 => {
                      let e = {
                        let l26 = i32::from(*ptr14.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                        let v27 = match l26 {
                          0 => {
                            IfaceError::InvalidArg
                          }
                          1 => {
                            IfaceError::NotFound
                          }
                          2 => {
                            IfaceError::Denied
                          }
                          3 => {
                            IfaceError::Unavailable
                          }
                          n => {
                            debug_assert_eq!(n, 4, "invalid enum discriminant");
                            IfaceError::Internal
                          }
                        };

                        v27
                      };
                      Err(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  };
                  result28
                }
              }

            }

          }
        }
        mod _rt {
          #![allow(dead_code, clippy::all)]
          pub use alloc_crate::string::String;
          pub use alloc_crate::vec::Vec;
          pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
            if cfg!(debug_assertions) {
              String::from_utf8(bytes).unwrap()
            } else {
              unsafe { String::from_utf8_unchecked(bytes) }
            }
          }
          pub unsafe fn invalid_enum_discriminant<T>() -> T {
            if cfg!(debug_assertions) {
              panic!("invalid enum discriminant")
            } else {
              unsafe { core::hint::unreachable_unchecked() }
            }
          }
          extern crate alloc as alloc_crate;
        }

        #[cfg(target_arch = "wasm32")]
        #[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:host-import@0.2.0:host-imports:encoded world")]
        #[doc(hidden)]
        #[allow(clippy::octal_escapes)]
        pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 905] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x86\x06\x01A\x02\x01\
A\x02\x01B$\x01q\x06\x03aws\0\0\x03gcp\0\0\x05azure\0\0\x07hetzner\0\0\x05local\0\
\0\x05other\0\0\x04\0\x05cloud\x03\0\0\x01q\x07\x03k8s\0\0\x05nomad\0\0\x07syste\
md\0\0\x09cfworkers\0\0\x06lambda\0\0\x09baremetal\0\0\x05other\0\0\x04\0\x08pla\
tform\x03\0\x02\x01s\x04\0\x07flow-id\x03\0\x04\x01s\x04\0\x09tenant-id\x03\0\x06\
\x01s\x04\0\x07team-id\x03\0\x08\x01s\x04\0\x07user-id\x03\0\x0a\x01ks\x01r\x04\x05\
cloud\x01\x06region\x0c\x08platform\x03\x07runtime\x0c\x04\0\x0edeployment-ctx\x03\
\0\x0d\x01k\x09\x01k\x0b\x01r\x05\x06tenant\x07\x04team\x0f\x04user\x10\x0adeplo\
yment\x0e\x08trace-id\x0c\x04\0\x0atenant-ctx\x03\0\x11\x01q\x05\x0binvalid-arg\0\
\0\x09not-found\0\0\x06denied\0\0\x0bunavailable\0\0\x08internal\0\0\x04\0\x0bif\
ace-error\x03\0\x13\x01r\x04\x06methods\x03urls\x0cheaders-json\x0c\x04body\x0c\x04\
\0\x0chttp-request\x03\0\x15\x01r\x03\x06status{\x0cheaders-json\x0c\x04body\x0c\
\x04\0\x0dhttp-response\x03\0\x17\x01k\x12\x01j\x01s\x01\x14\x01@\x02\x03keys\x03\
ctx\x19\0\x1a\x04\0\x0bsecrets-get\x01\x1b\x01@\x02\x09span-jsons\x03ctx\x19\x01\
\0\x04\0\x0etelemetry-emit\x01\x1c\x01@\x04\x04tools\x06actions\x09args-jsons\x03\
ctx\x19\0\x1a\x04\0\x0btool-invoke\x01\x1d\x01j\x01\x18\x01\x14\x01@\x02\x03req\x16\
\x03ctx\x19\0\x1e\x04\0\x0ahttp-fetch\x01\x1f\x03\0\"greentic:host-import/import\
s@0.2.0\x05\0\x04\0'greentic:host-import/host-imports@0.2.0\x04\0\x0b\x12\x01\0\x0c\
host-imports\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x07\
0.240.0\x10wit-bindgen-rust\x060.47.0";

        #[inline(never)]
        #[doc(hidden)]
        pub fn __link_custom_section_describing_imports() {
          wit_bindgen::rt::maybe_link_cabi_realloc();
        }
        
