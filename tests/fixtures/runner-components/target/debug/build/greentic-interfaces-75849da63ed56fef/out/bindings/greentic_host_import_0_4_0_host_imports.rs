// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod greentic {
  pub mod host_import {
    /// secret management helpers
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod secrets {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
      pub type IfaceError = super::super::super::greentic::types_core::types::IfaceError;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn get(key: &str,ctx: Option<&TenantCtx>,) -> Result<_rt::String,IfaceError>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 22*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 22*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = key;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
          *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
          match ctx {
            Some(e) => {
              *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant2, team:team2, user:user2, deployment:deployment2, trace_id:trace_id2, } = e;
              let vec3 = tenant2;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
              *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
              match team2 {
                Some(e) => {
                  *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();
                  *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                  *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match user2 {
                Some(e) => {
                  *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec5 = e;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud6, region:region6, platform:platform6, runtime:runtime6, } = deployment2;
              *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud6.clone() as i32) as u8;
              match region6 {
                Some(e) => {
                  *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec7 = e;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                  *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };*ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform6.clone() as i32) as u8;
              match runtime6 {
                Some(e) => {
                  *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec8 = e;
                  let ptr8 = vec8.as_ptr().cast::<u8>();
                  let len8 = vec8.len();
                  *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                  *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match trace_id2 {
                Some(e) => {
                  *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec9 = e;
                  let ptr9 = vec9.as_ptr().cast::<u8>();
                  let len9 = vec9.len();
                  *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                  *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };},
              None => {
                {
                  *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };let ptr10 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "greentic:host-import/secrets@0.4.0")]
            unsafe extern "C" {
              #[link_name = "get"]
              fn wit_import11(_: *mut u8, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import11(_: *mut u8, _: *mut u8, ) { unreachable!() }
            wit_import11(ptr0, ptr10);
            let l12 = i32::from(*ptr10.add(0).cast::<u8>());
            let result17 = match l12 {
              0 => {
                let e = {
                  let l13 = *ptr10.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l14 = *ptr10.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len15 = l14;
                  let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                  _rt::string_lift(bytes15)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l16 = i32::from(*ptr10.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                  super::super::super::greentic::types_core::types::IfaceError::_lift(l16 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result17
          }
        }

      }

      /// telemetry emission
      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod telemetry {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::__link_custom_section_describing_imports;
        
        pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn emit(span_json: &str,ctx: Option<&TenantCtx>,) -> (){
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 22*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 22*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = span_json;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
            *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
            match ctx {
              Some(e) => {
                *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant2, team:team2, user:user2, deployment:deployment2, trace_id:trace_id2, } = e;
                let vec3 = tenant2;
                let ptr3 = vec3.as_ptr().cast::<u8>();
                let len3 = vec3.len();
                *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                match team2 {
                  Some(e) => {
                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec4 = e;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match user2 {
                  Some(e) => {
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec5 = e;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud6, region:region6, platform:platform6, runtime:runtime6, } = deployment2;
                *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud6.clone() as i32) as u8;
                match region6 {
                  Some(e) => {
                    *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec7 = e;
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };*ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform6.clone() as i32) as u8;
                match runtime6 {
                  Some(e) => {
                    *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec8 = e;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                    *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match trace_id2 {
                  Some(e) => {
                    *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec9 = e;
                    let ptr9 = vec9.as_ptr().cast::<u8>();
                    let len9 = vec9.len();
                    *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };},
                None => {
                  {
                    *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "greentic:host-import/telemetry@0.4.0")]
              unsafe extern "C" {
                #[link_name = "emit"]
                fn wit_import10(_: *mut u8, );
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn wit_import10(_: *mut u8, ) { unreachable!() }
              wit_import10(ptr0);
            }
          }

        }

        /// outbound HTTP helper
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod http {
          #[used]
          #[doc(hidden)]
          static __FORCE_SECTION_REF: fn() =
          super::super::super::__link_custom_section_describing_imports;
          
          use super::super::super::_rt;
          pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
          pub type IfaceError = super::super::super::greentic::types_core::types::IfaceError;
          /// HTTP request payload issued by packs/components
          #[derive(Clone)]
          pub struct HttpRequest {
            pub method: _rt::String,
            pub url: _rt::String,
            pub headers_json: Option<_rt::String>,
            pub body: Option<_rt::String>,
          }
          impl ::core::fmt::Debug for HttpRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
              f.debug_struct("HttpRequest").field("method", &self.method).field("url", &self.url).field("headers-json", &self.headers_json).field("body", &self.body).finish()
            }
          }
          /// HTTP response returned by the host
          #[derive(Clone)]
          pub struct HttpResponse {
            pub status: u16,
            pub headers_json: Option<_rt::String>,
            pub body: Option<_rt::String>,
          }
          impl ::core::fmt::Debug for HttpResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
              f.debug_struct("HttpResponse").field("status", &self.status).field("headers-json", &self.headers_json).field("body", &self.body).finish()
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          #[allow(async_fn_in_trait)]
          pub fn fetch(req: &HttpRequest,ctx: Option<&TenantCtx>,) -> Result<HttpResponse,IfaceError>{
            unsafe {

              #[cfg_attr(target_pointer_width="64", repr(align(8)))]
              #[cfg_attr(target_pointer_width="32", repr(align(4)))]
              struct RetArea([::core::mem::MaybeUninit::<u8>; 30*::core::mem::size_of::<*const u8>()]);
              let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 30*::core::mem::size_of::<*const u8>()]);
              let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let HttpRequest{ method:method1, url:url1, headers_json:headers_json1, body:body1, } = req;
              let vec2 = method1;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
              *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
              let vec3 = url1;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
              *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
              match headers_json1 {
                Some(e) => {
                  *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();
                  *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                  *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match body1 {
                Some(e) => {
                  *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec5 = e;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match ctx {
                Some(e) => {
                  *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant6, team:team6, user:user6, deployment:deployment6, trace_id:trace_id6, } = e;
                  let vec7 = tenant6;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                  *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                  match team6 {
                    Some(e) => {
                      *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec8 = e;
                      let ptr8 = vec8.as_ptr().cast::<u8>();
                      let len8 = vec8.len();
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                      *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match user6 {
                    Some(e) => {
                      *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec9 = e;
                      let ptr9 = vec9.as_ptr().cast::<u8>();
                      let len9 = vec9.len();
                      *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                      *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud10, region:region10, platform:platform10, runtime:runtime10, } = deployment6;
                  *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud10.clone() as i32) as u8;
                  match region10 {
                    Some(e) => {
                      *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec11 = e;
                      let ptr11 = vec11.as_ptr().cast::<u8>();
                      let len11 = vec11.len();
                      *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                      *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };*ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform10.clone() as i32) as u8;
                  match runtime10 {
                    Some(e) => {
                      *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec12 = e;
                      let ptr12 = vec12.as_ptr().cast::<u8>();
                      let len12 = vec12.len();
                      *ptr0.add(26*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                      *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match trace_id6 {
                    Some(e) => {
                      *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec13 = e;
                      let ptr13 = vec13.as_ptr().cast::<u8>();
                      let len13 = vec13.len();
                      *ptr0.add(29*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                      *ptr0.add(28*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr13.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                  None => {
                    {
                      *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let ptr14 = ret_area.0.as_mut_ptr().cast::<u8>();
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "greentic:host-import/http@0.4.0")]
                unsafe extern "C" {
                  #[link_name = "fetch"]
                  fn wit_import15(_: *mut u8, _: *mut u8, );
                }

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn wit_import15(_: *mut u8, _: *mut u8, ) { unreachable!() }
                wit_import15(ptr0, ptr14);
                let l16 = i32::from(*ptr14.add(0).cast::<u8>());
                let result27 = match l16 {
                  0 => {
                    let e = {
                      let l17 = i32::from(*ptr14.add(::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l18 = i32::from(*ptr14.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l22 = i32::from(*ptr14.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      HttpResponse{
                        status: l17 as u16,
                        headers_json: match l18 {
                          0 => None,
                          1 => {
                            let e = {
                              let l19 = *ptr14.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l20 = *ptr14.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len21 = l20;
                              let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);

                              _rt::string_lift(bytes21)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        body: match l22 {
                          0 => None,
                          1 => {
                            let e = {
                              let l23 = *ptr14.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l24 = *ptr14.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len25 = l24;
                              let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);

                              _rt::string_lift(bytes25)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l26 = i32::from(*ptr14.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                      super::super::super::greentic::types_core::types::IfaceError::_lift(l26 as u8)
                    };
                    Err(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                };
                result27
              }
            }

          }

        }
        pub mod types_core {

          #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
          pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() =
            super::super::super::__link_custom_section_describing_imports;
            
            use super::super::super::_rt;
            /// identifiers
            pub type FlowId = _rt::String;
            pub type TenantId = _rt::String;
            pub type TeamId = _rt::String;
            pub type UserId = _rt::String;
            /// clouds & platforms (keep enums stable; add variants only in minor bumps)
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Cloud {
              Aws,
              Gcp,
              Azure,
              Hetzner,
              Local,
              Other,
            }
            impl ::core::fmt::Debug for Cloud {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                match self {
                  Cloud::Aws => {
                    f.debug_tuple("Cloud::Aws").finish()
                  }
                  Cloud::Gcp => {
                    f.debug_tuple("Cloud::Gcp").finish()
                  }
                  Cloud::Azure => {
                    f.debug_tuple("Cloud::Azure").finish()
                  }
                  Cloud::Hetzner => {
                    f.debug_tuple("Cloud::Hetzner").finish()
                  }
                  Cloud::Local => {
                    f.debug_tuple("Cloud::Local").finish()
                  }
                  Cloud::Other => {
                    f.debug_tuple("Cloud::Other").finish()
                  }
                }
              }
            }

            impl Cloud{
              #[doc(hidden)]
              pub unsafe fn _lift(val: u8) -> Cloud{
                if !cfg!(debug_assertions) {
                  return unsafe { ::core::mem::transmute(val) };
                }

                match val {
                  0 => Cloud::Aws,
                  1 => Cloud::Gcp,
                  2 => Cloud::Azure,
                  3 => Cloud::Hetzner,
                  4 => Cloud::Local,
                  5 => Cloud::Other,

                  _ => panic!("invalid enum discriminant"),
                }
              }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Platform {
              K8s,
              Nomad,
              Systemd,
              Cfworkers,
              Lambda,
              Baremetal,
              Other,
            }
            impl ::core::fmt::Debug for Platform {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                match self {
                  Platform::K8s => {
                    f.debug_tuple("Platform::K8s").finish()
                  }
                  Platform::Nomad => {
                    f.debug_tuple("Platform::Nomad").finish()
                  }
                  Platform::Systemd => {
                    f.debug_tuple("Platform::Systemd").finish()
                  }
                  Platform::Cfworkers => {
                    f.debug_tuple("Platform::Cfworkers").finish()
                  }
                  Platform::Lambda => {
                    f.debug_tuple("Platform::Lambda").finish()
                  }
                  Platform::Baremetal => {
                    f.debug_tuple("Platform::Baremetal").finish()
                  }
                  Platform::Other => {
                    f.debug_tuple("Platform::Other").finish()
                  }
                }
              }
            }

            impl Platform{
              #[doc(hidden)]
              pub unsafe fn _lift(val: u8) -> Platform{
                if !cfg!(debug_assertions) {
                  return unsafe { ::core::mem::transmute(val) };
                }

                match val {
                  0 => Platform::K8s,
                  1 => Platform::Nomad,
                  2 => Platform::Systemd,
                  3 => Platform::Cfworkers,
                  4 => Platform::Lambda,
                  5 => Platform::Baremetal,
                  6 => Platform::Other,

                  _ => panic!("invalid enum discriminant"),
                }
              }
            }

            /// flow deployment context supplied by hosts
            #[derive(Clone)]
            pub struct DeploymentCtx {
              pub cloud: Cloud,
              pub region: Option<_rt::String>,
              pub platform: Platform,
              pub runtime: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for DeploymentCtx {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("DeploymentCtx").field("cloud", &self.cloud).field("region", &self.region).field("platform", &self.platform).field("runtime", &self.runtime).finish()
              }
            }
            /// tenant identity and invocation metadata
            #[derive(Clone)]
            pub struct TenantCtx {
              pub tenant: TenantId,
              pub team: Option<TeamId>,
              pub user: Option<UserId>,
              pub deployment: DeploymentCtx,
              pub trace_id: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for TenantCtx {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("TenantCtx").field("tenant", &self.tenant).field("team", &self.team).field("user", &self.user).field("deployment", &self.deployment).field("trace-id", &self.trace_id).finish()
              }
            }
            /// flow registration information
            #[derive(Clone)]
            pub struct FlowInfo {
              pub id: FlowId,
              /// human-readable name
              pub profile: _rt::String,
              /// semver identifier
              pub version: _rt::String,
              /// "messaging" | "webhook" | "timer" | ...
              pub type_: _rt::String,
              pub private: bool,
            }
            impl ::core::fmt::Debug for FlowInfo {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("FlowInfo").field("id", &self.id).field("profile", &self.profile).field("version", &self.version).field("type", &self.type_).field("private", &self.private).finish()
              }
            }
            /// execution modifiers supplied when running a flow
            #[derive(Clone)]
            pub struct RunOpts {
              pub tenant: Option<TenantCtx>,
              pub timeout_ms: Option<u32>,
              /// Wasm "fuel" if host enforces
              pub fuel_units: Option<u64>,
            }
            impl ::core::fmt::Debug for RunOpts {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("RunOpts").field("tenant", &self.tenant).field("timeout-ms", &self.timeout_ms).field("fuel-units", &self.fuel_units).finish()
              }
            }
            /// JSON schema documents describing flow IO
            #[derive(Clone)]
            pub struct SchemaDoc {
              pub input_jsonschema: _rt::String,
              pub output_jsonschema: _rt::String,
            }
            impl ::core::fmt::Debug for SchemaDoc {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("SchemaDoc").field("input-jsonschema", &self.input_jsonschema).field("output-jsonschema", &self.output_jsonschema).finish()
              }
            }
            /// result returned by a flow execution
            #[derive(Clone)]
            pub struct RunResult {
              /// "ok" | "error" | "deferred"
              pub status: _rt::String,
              pub output_json: Option<_rt::String>,
              pub error: Option<_rt::String>,
              pub logs_json: Option<_rt::String>,
              pub metrics_json: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for RunResult {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("RunResult").field("status", &self.status).field("output-json", &self.output_json).field("error", &self.error).field("logs-json", &self.logs_json).field("metrics-json", &self.metrics_json).finish()
              }
            }
            /// A2A search candidate
            #[derive(Clone)]
            pub struct A2aCandidate {
              pub flow: FlowId,
              pub score: f32,
            }
            impl ::core::fmt::Debug for A2aCandidate {
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("A2aCandidate").field("flow", &self.flow).field("score", &self.score).finish()
              }
            }
            /// standardized interface errors
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum IfaceError {
              InvalidArg,
              NotFound,
              Denied,
              Unavailable,
              Internal,
            }
            impl IfaceError{
              pub fn name(&self) -> &'static str {
                match self {
                  IfaceError::InvalidArg => "invalid-arg",
                  IfaceError::NotFound => "not-found",
                  IfaceError::Denied => "denied",
                  IfaceError::Unavailable => "unavailable",
                  IfaceError::Internal => "internal",
                }
              }
              pub fn message(&self) -> &'static str {
                match self {
                  IfaceError::InvalidArg => "",
                  IfaceError::NotFound => "",
                  IfaceError::Denied => "",
                  IfaceError::Unavailable => "",
                  IfaceError::Internal => "",
                }
              }
            }
            impl ::core::fmt::Debug for IfaceError{
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                f.debug_struct("IfaceError")
                .field("code", &(*self as i32))
                .field("name", &self.name())
                .field("message", &self.message())
                .finish()
              }
            }
            impl ::core::fmt::Display for IfaceError{
              fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "{} (error {})", self.name(), *self as i32)
              }
            }

            impl ::core::error::Error for IfaceError {}

            impl IfaceError{
              #[doc(hidden)]
              pub unsafe fn _lift(val: u8) -> IfaceError{
                if !cfg!(debug_assertions) {
                  return unsafe { ::core::mem::transmute(val) };
                }

                match val {
                  0 => IfaceError::InvalidArg,
                  1 => IfaceError::NotFound,
                  2 => IfaceError::Denied,
                  3 => IfaceError::Unavailable,
                  4 => IfaceError::Internal,

                  _ => panic!("invalid enum discriminant"),
                }
              }
            }


          }

        }
      }
      mod _rt {
        #![allow(dead_code, clippy::all)]
        pub use alloc_crate::string::String;
        pub use alloc_crate::vec::Vec;
        pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
          if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
          } else {
            unsafe { String::from_utf8_unchecked(bytes) }
          }
        }
        pub unsafe fn invalid_enum_discriminant<T>() -> T {
          if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
          } else {
            unsafe { core::hint::unreachable_unchecked() }
          }
        }
        extern crate alloc as alloc_crate;
      }

      #[cfg(target_arch = "wasm32")]
      #[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:host-import@0.4.0:host-imports:encoded world")]
      #[doc(hidden)]
      #[allow(clippy::octal_escapes)]
      pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1340] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb9\x09\x01A\x02\x01\
A\x0a\x01B\"\x01s\x04\0\x07flow-id\x03\0\0\x01s\x04\0\x09tenant-id\x03\0\x02\x01\
s\x04\0\x07team-id\x03\0\x04\x01s\x04\0\x07user-id\x03\0\x06\x01m\x06\x03aws\x03\
gcp\x05azure\x07hetzner\x05local\x05other\x04\0\x05cloud\x03\0\x08\x01m\x07\x03k\
8s\x05nomad\x07systemd\x09cfworkers\x06lambda\x09baremetal\x05other\x04\0\x08pla\
tform\x03\0\x0a\x01ks\x01r\x04\x05cloud\x09\x06region\x0c\x08platform\x0b\x07run\
time\x0c\x04\0\x0edeployment-ctx\x03\0\x0d\x01k\x05\x01k\x07\x01r\x05\x06tenant\x03\
\x04team\x0f\x04user\x10\x0adeployment\x0e\x08trace-id\x0c\x04\0\x0atenant-ctx\x03\
\0\x11\x01r\x05\x02id\x01\x07profiles\x07versions\x04types\x07private\x7f\x04\0\x09\
flow-info\x03\0\x13\x01k\x12\x01ky\x01kw\x01r\x03\x06tenant\x15\x0atimeout-ms\x16\
\x0afuel-units\x17\x04\0\x08run-opts\x03\0\x18\x01r\x02\x10input-jsonschemas\x11\
output-jsonschemas\x04\0\x0aschema-doc\x03\0\x1a\x01r\x05\x06statuss\x0boutput-j\
son\x0c\x05error\x0c\x09logs-json\x0c\x0cmetrics-json\x0c\x04\0\x0arun-result\x03\
\0\x1c\x01r\x02\x04flow\x01\x05scorev\x04\0\x0da2a-candidate\x03\0\x1e\x01m\x05\x0b\
invalid-arg\x09not-found\x06denied\x0bunavailable\x08internal\x04\0\x0biface-err\
or\x03\0\x20\x03\0\x1fgreentic:types-core/types@0.4.0\x05\0\x02\x03\0\0\x0atenan\
t-ctx\x02\x03\0\0\x0biface-error\x01B\x08\x02\x03\x02\x01\x01\x04\0\x0atenant-ct\
x\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0biface-error\x03\0\x02\x01k\x01\x01j\x01s\x01\
\x03\x01@\x02\x03keys\x03ctx\x04\0\x05\x04\0\x03get\x01\x06\x03\0\"greentic:host\
-import/secrets@0.4.0\x05\x03\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0atenant-ctx\x03\
\0\0\x01k\x01\x01@\x02\x09span-jsons\x03ctx\x02\x01\0\x04\0\x04emit\x01\x03\x03\0\
$greentic:host-import/telemetry@0.4.0\x05\x04\x01B\x0d\x02\x03\x02\x01\x01\x04\0\
\x0atenant-ctx\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0biface-error\x03\0\x02\x01ks\x01\
r\x04\x06methods\x03urls\x0cheaders-json\x04\x04body\x04\x04\0\x0chttp-request\x03\
\0\x05\x01r\x03\x06status{\x0cheaders-json\x04\x04body\x04\x04\0\x0dhttp-respons\
e\x03\0\x07\x01k\x01\x01j\x01\x08\x01\x03\x01@\x02\x03req\x06\x03ctx\x09\0\x0a\x04\
\0\x05fetch\x01\x0b\x03\0\x1fgreentic:host-import/http@0.4.0\x05\x05\x04\0'green\
tic:host-import/host-imports@0.4.0\x04\0\x0b\x12\x01\0\x0chost-imports\x03\0\0\0\
G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.240.0\x10wit-bindge\
n-rust\x060.47.0";

      #[inline(never)]
      #[doc(hidden)]
      pub fn __link_custom_section_describing_imports() {
        wit_bindgen::rt::maybe_link_cabi_realloc();
      }
      
