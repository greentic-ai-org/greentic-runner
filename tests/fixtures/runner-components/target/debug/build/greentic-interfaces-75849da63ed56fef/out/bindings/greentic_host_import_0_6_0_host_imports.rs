// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod greentic {
  pub mod host_import {
    /// secret management helpers
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod secrets {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
      pub type IfaceError = super::super::super::greentic::types_core::types::IfaceError;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn get(key: &str,ctx: Option<&TenantCtx>,) -> Result<_rt::String,IfaceError>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 22*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 22*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = key;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
          *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
          match ctx {
            Some(e) => {
              *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant2, team:team2, user:user2, deployment:deployment2, trace_id:trace_id2, } = e;
              let vec3 = tenant2;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
              *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
              match team2 {
                Some(e) => {
                  *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();
                  *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                  *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match user2 {
                Some(e) => {
                  *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec5 = e;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud6, region:region6, platform:platform6, runtime:runtime6, } = deployment2;
              *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud6.clone() as i32) as u8;
              match region6 {
                Some(e) => {
                  *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec7 = e;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                  *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };*ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform6.clone() as i32) as u8;
              match runtime6 {
                Some(e) => {
                  *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec8 = e;
                  let ptr8 = vec8.as_ptr().cast::<u8>();
                  let len8 = vec8.len();
                  *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                  *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match trace_id2 {
                Some(e) => {
                  *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec9 = e;
                  let ptr9 = vec9.as_ptr().cast::<u8>();
                  let len9 = vec9.len();
                  *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                  *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };},
              None => {
                {
                  *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };let ptr10 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "greentic:host-import/secrets@0.6.0")]
            unsafe extern "C" {
              #[link_name = "get"]
              fn wit_import11(_: *mut u8, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import11(_: *mut u8, _: *mut u8, ) { unreachable!() }
            wit_import11(ptr0, ptr10);
            let l12 = i32::from(*ptr10.add(0).cast::<u8>());
            let result17 = match l12 {
              0 => {
                let e = {
                  let l13 = *ptr10.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l14 = *ptr10.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len15 = l14;
                  let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                  _rt::string_lift(bytes15)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l16 = i32::from(*ptr10.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                  super::super::super::greentic::types_core::types::IfaceError::_lift(l16 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result17
          }
        }

      }

      /// telemetry emission
      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod telemetry {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::__link_custom_section_describing_imports;
        
        pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn emit(span_json: &str,ctx: Option<&TenantCtx>,) -> (){
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 22*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 22*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = span_json;
            let ptr1 = vec1.as_ptr().cast::<u8>();
            let len1 = vec1.len();
            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
            *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
            match ctx {
              Some(e) => {
                *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant2, team:team2, user:user2, deployment:deployment2, trace_id:trace_id2, } = e;
                let vec3 = tenant2;
                let ptr3 = vec3.as_ptr().cast::<u8>();
                let len3 = vec3.len();
                *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                match team2 {
                  Some(e) => {
                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec4 = e;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match user2 {
                  Some(e) => {
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec5 = e;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud6, region:region6, platform:platform6, runtime:runtime6, } = deployment2;
                *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud6.clone() as i32) as u8;
                match region6 {
                  Some(e) => {
                    *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec7 = e;
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };*ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform6.clone() as i32) as u8;
                match runtime6 {
                  Some(e) => {
                    *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec8 = e;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                    *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match trace_id2 {
                  Some(e) => {
                    *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec9 = e;
                    let ptr9 = vec9.as_ptr().cast::<u8>();
                    let len9 = vec9.len();
                    *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };},
                None => {
                  {
                    *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "greentic:host-import/telemetry@0.6.0")]
              unsafe extern "C" {
                #[link_name = "emit"]
                fn wit_import10(_: *mut u8, );
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn wit_import10(_: *mut u8, ) { unreachable!() }
              wit_import10(ptr0);
            }
          }

        }

        /// outbound HTTP helper
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod http {
          #[used]
          #[doc(hidden)]
          static __FORCE_SECTION_REF: fn() =
          super::super::super::__link_custom_section_describing_imports;
          
          use super::super::super::_rt;
          pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
          pub type IfaceError = super::super::super::greentic::types_core::types::IfaceError;
          /// HTTP request payload issued by packs/components
          #[derive(Clone)]
          pub struct HttpRequest {
            pub method: _rt::String,
            pub url: _rt::String,
            pub headers_json: Option<_rt::String>,
            pub body: Option<_rt::String>,
          }
          impl ::core::fmt::Debug for HttpRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
              f.debug_struct("HttpRequest").field("method", &self.method).field("url", &self.url).field("headers-json", &self.headers_json).field("body", &self.body).finish()
            }
          }
          /// HTTP response returned by the host
          #[derive(Clone)]
          pub struct HttpResponse {
            pub status: u16,
            pub headers_json: Option<_rt::String>,
            pub body: Option<_rt::String>,
          }
          impl ::core::fmt::Debug for HttpResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
              f.debug_struct("HttpResponse").field("status", &self.status).field("headers-json", &self.headers_json).field("body", &self.body).finish()
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          #[allow(async_fn_in_trait)]
          pub fn fetch(req: &HttpRequest,ctx: Option<&TenantCtx>,) -> Result<HttpResponse,IfaceError>{
            unsafe {

              #[cfg_attr(target_pointer_width="64", repr(align(8)))]
              #[cfg_attr(target_pointer_width="32", repr(align(4)))]
              struct RetArea([::core::mem::MaybeUninit::<u8>; 30*::core::mem::size_of::<*const u8>()]);
              let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 30*::core::mem::size_of::<*const u8>()]);
              let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let HttpRequest{ method:method1, url:url1, headers_json:headers_json1, body:body1, } = req;
              let vec2 = method1;
              let ptr2 = vec2.as_ptr().cast::<u8>();
              let len2 = vec2.len();
              *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
              *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
              let vec3 = url1;
              let ptr3 = vec3.as_ptr().cast::<u8>();
              let len3 = vec3.len();
              *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
              *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
              match headers_json1 {
                Some(e) => {
                  *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec4 = e;
                  let ptr4 = vec4.as_ptr().cast::<u8>();
                  let len4 = vec4.len();
                  *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                  *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match body1 {
                Some(e) => {
                  *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec5 = e;
                  let ptr5 = vec5.as_ptr().cast::<u8>();
                  let len5 = vec5.len();
                  *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                },
                None => {
                  {
                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match ctx {
                Some(e) => {
                  *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant6, team:team6, user:user6, deployment:deployment6, trace_id:trace_id6, } = e;
                  let vec7 = tenant6;
                  let ptr7 = vec7.as_ptr().cast::<u8>();
                  let len7 = vec7.len();
                  *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                  *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                  match team6 {
                    Some(e) => {
                      *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec8 = e;
                      let ptr8 = vec8.as_ptr().cast::<u8>();
                      let len8 = vec8.len();
                      *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                      *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match user6 {
                    Some(e) => {
                      *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec9 = e;
                      let ptr9 = vec9.as_ptr().cast::<u8>();
                      let len9 = vec9.len();
                      *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                      *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud10, region:region10, platform:platform10, runtime:runtime10, } = deployment6;
                  *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud10.clone() as i32) as u8;
                  match region10 {
                    Some(e) => {
                      *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec11 = e;
                      let ptr11 = vec11.as_ptr().cast::<u8>();
                      let len11 = vec11.len();
                      *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                      *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };*ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform10.clone() as i32) as u8;
                  match runtime10 {
                    Some(e) => {
                      *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec12 = e;
                      let ptr12 = vec12.as_ptr().cast::<u8>();
                      let len12 = vec12.len();
                      *ptr0.add(26*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                      *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match trace_id6 {
                    Some(e) => {
                      *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec13 = e;
                      let ptr13 = vec13.as_ptr().cast::<u8>();
                      let len13 = vec13.len();
                      *ptr0.add(29*::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                      *ptr0.add(28*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr13.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                  None => {
                    {
                      *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let ptr14 = ret_area.0.as_mut_ptr().cast::<u8>();
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "greentic:host-import/http@0.6.0")]
                unsafe extern "C" {
                  #[link_name = "fetch"]
                  fn wit_import15(_: *mut u8, _: *mut u8, );
                }

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn wit_import15(_: *mut u8, _: *mut u8, ) { unreachable!() }
                wit_import15(ptr0, ptr14);
                let l16 = i32::from(*ptr14.add(0).cast::<u8>());
                let result27 = match l16 {
                  0 => {
                    let e = {
                      let l17 = i32::from(*ptr14.add(::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l18 = i32::from(*ptr14.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l22 = i32::from(*ptr14.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      HttpResponse{
                        status: l17 as u16,
                        headers_json: match l18 {
                          0 => None,
                          1 => {
                            let e = {
                              let l19 = *ptr14.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l20 = *ptr14.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len21 = l20;
                              let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);

                              _rt::string_lift(bytes21)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        body: match l22 {
                          0 => None,
                          1 => {
                            let e = {
                              let l23 = *ptr14.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l24 = *ptr14.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len25 = l24;
                              let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);

                              _rt::string_lift(bytes25)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      }
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l26 = i32::from(*ptr14.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                      super::super::super::greentic::types_core::types::IfaceError::_lift(l26 as u8)
                    };
                    Err(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                };
                result27
              }
            }

          }

          /// MCP/tool execution helper
          #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
          pub mod mcp {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() =
            super::super::super::__link_custom_section_describing_imports;
            
            use super::super::super::_rt;
            pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
            pub type IfaceError = super::super::super::greentic::types_core::types::IfaceError;
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn exec(component: &str,action: &str,args_json: &str,ctx: Option<&TenantCtx>,) -> Result<_rt::String,IfaceError>{
              unsafe {

                #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                struct RetArea([::core::mem::MaybeUninit::<u8>; 26*::core::mem::size_of::<*const u8>()]);
                let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 26*::core::mem::size_of::<*const u8>()]);
                let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = component;
                let ptr1 = vec1.as_ptr().cast::<u8>();
                let len1 = vec1.len();
                *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
                *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                let vec2 = action;
                let ptr2 = vec2.as_ptr().cast::<u8>();
                let len2 = vec2.len();
                *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
                let vec3 = args_json;
                let ptr3 = vec3.as_ptr().cast::<u8>();
                let len3 = vec3.len();
                *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                match ctx {
                  Some(e) => {
                    *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant4, team:team4, user:user4, deployment:deployment4, trace_id:trace_id4, } = e;
                    let vec5 = tenant4;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                    match team4 {
                      Some(e) => {
                        *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec6 = e;
                        let ptr6 = vec6.as_ptr().cast::<u8>();
                        let len6 = vec6.len();
                        *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                        *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match user4 {
                      Some(e) => {
                        *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec7 = e;
                        let ptr7 = vec7.as_ptr().cast::<u8>();
                        let len7 = vec7.len();
                        *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                        *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud8, region:region8, platform:platform8, runtime:runtime8, } = deployment4;
                    *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud8.clone() as i32) as u8;
                    match region8 {
                      Some(e) => {
                        *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec9 = e;
                        let ptr9 = vec9.as_ptr().cast::<u8>();
                        let len9 = vec9.len();
                        *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                        *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };*ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform8.clone() as i32) as u8;
                    match runtime8 {
                      Some(e) => {
                        *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec10 = e;
                        let ptr10 = vec10.as_ptr().cast::<u8>();
                        let len10 = vec10.len();
                        *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                        *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match trace_id4 {
                      Some(e) => {
                        *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec11 = e;
                        let ptr11 = vec11.as_ptr().cast::<u8>();
                        let len11 = vec11.len();
                        *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                        *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                      },
                      None => {
                        {
                          *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };},
                    None => {
                      {
                        *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };let ptr12 = ret_area.0.as_mut_ptr().cast::<u8>();
                  #[cfg(target_arch = "wasm32")]
                  #[link(wasm_import_module = "greentic:host-import/mcp@0.6.0")]
                  unsafe extern "C" {
                    #[link_name = "exec"]
                    fn wit_import13(_: *mut u8, _: *mut u8, );
                  }

                  #[cfg(not(target_arch = "wasm32"))]
                  unsafe extern "C" fn wit_import13(_: *mut u8, _: *mut u8, ) { unreachable!() }
                  wit_import13(ptr0, ptr12);
                  let l14 = i32::from(*ptr12.add(0).cast::<u8>());
                  let result19 = match l14 {
                    0 => {
                      let e = {
                        let l15 = *ptr12.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l16 = *ptr12.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len17 = l16;
                        let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                        _rt::string_lift(bytes17)
                      };
                      Ok(e)
                    }
                    1 => {
                      let e = {
                        let l18 = i32::from(*ptr12.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                        super::super::super::greentic::types_core::types::IfaceError::_lift(l18 as u8)
                      };
                      Err(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  };
                  result19
                }
              }

            }

            /// persistent state helpers
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod state {
              #[used]
              #[doc(hidden)]
              static __FORCE_SECTION_REF: fn() =
              super::super::super::__link_custom_section_describing_imports;
              
              use super::super::super::_rt;
              pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
              pub type IfaceError = super::super::super::greentic::types_core::types::IfaceError;
              pub type StateKey = super::super::super::greentic::interfaces_types::types::StateKey;
              /// Trivial acknowledgment returned by write-only operations.
              #[repr(u8)]
              #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
              pub enum OpAck {
                Ok,
              }
              impl ::core::fmt::Debug for OpAck {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                  match self {
                    OpAck::Ok => {
                      f.debug_tuple("OpAck::Ok").finish()
                    }
                  }
                }
              }

              impl OpAck{
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> OpAck{
                  if !cfg!(debug_assertions) {
                    return unsafe { ::core::mem::transmute(val) };
                  }

                  match val {
                    0 => OpAck::Ok,

                    _ => panic!("invalid enum discriminant"),
                  }
                }
              }

              #[allow(unused_unsafe, clippy::all)]
              #[allow(async_fn_in_trait)]
              pub fn get(key: &str,ctx: Option<&TenantCtx>,) -> Result<_rt::String,IfaceError>{
                unsafe {

                  #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                  #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                  struct RetArea([::core::mem::MaybeUninit::<u8>; 22*::core::mem::size_of::<*const u8>()]);
                  let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 22*::core::mem::size_of::<*const u8>()]);
                  let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = key;
                  let ptr1 = vec1.as_ptr().cast::<u8>();
                  let len1 = vec1.len();
                  *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
                  *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                  match ctx {
                    Some(e) => {
                      *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant2, team:team2, user:user2, deployment:deployment2, trace_id:trace_id2, } = e;
                      let vec3 = tenant2;
                      let ptr3 = vec3.as_ptr().cast::<u8>();
                      let len3 = vec3.len();
                      *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                      *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                      match team2 {
                        Some(e) => {
                          *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec4 = e;
                          let ptr4 = vec4.as_ptr().cast::<u8>();
                          let len4 = vec4.len();
                          *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                          *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                        },
                        None => {
                          {
                            *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match user2 {
                        Some(e) => {
                          *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec5 = e;
                          let ptr5 = vec5.as_ptr().cast::<u8>();
                          let len5 = vec5.len();
                          *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                          *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                        },
                        None => {
                          {
                            *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud6, region:region6, platform:platform6, runtime:runtime6, } = deployment2;
                      *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud6.clone() as i32) as u8;
                      match region6 {
                        Some(e) => {
                          *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec7 = e;
                          let ptr7 = vec7.as_ptr().cast::<u8>();
                          let len7 = vec7.len();
                          *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                          *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                        },
                        None => {
                          {
                            *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };*ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform6.clone() as i32) as u8;
                      match runtime6 {
                        Some(e) => {
                          *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec8 = e;
                          let ptr8 = vec8.as_ptr().cast::<u8>();
                          let len8 = vec8.len();
                          *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                          *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                        },
                        None => {
                          {
                            *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match trace_id2 {
                        Some(e) => {
                          *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec9 = e;
                          let ptr9 = vec9.as_ptr().cast::<u8>();
                          let len9 = vec9.len();
                          *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                          *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                        },
                        None => {
                          {
                            *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      None => {
                        {
                          *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };let ptr10 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "greentic:host-import/state@0.6.0")]
                    unsafe extern "C" {
                      #[link_name = "get"]
                      fn wit_import11(_: *mut u8, _: *mut u8, );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import11(_: *mut u8, _: *mut u8, ) { unreachable!() }
                    wit_import11(ptr0, ptr10);
                    let l12 = i32::from(*ptr10.add(0).cast::<u8>());
                    let result17 = match l12 {
                      0 => {
                        let e = {
                          let l13 = *ptr10.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l14 = *ptr10.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len15 = l14;
                          let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);

                          _rt::string_lift(bytes15)
                        };
                        Ok(e)
                      }
                      1 => {
                        let e = {
                          let l16 = i32::from(*ptr10.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                          super::super::super::greentic::types_core::types::IfaceError::_lift(l16 as u8)
                        };
                        Err(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    };
                    result17
                  }
                }
                #[allow(unused_unsafe, clippy::all)]
                #[allow(async_fn_in_trait)]
                pub fn set(key: &str,value_json: &str,ctx: Option<&TenantCtx>,) -> Result<OpAck,IfaceError>{
                  unsafe {

                    #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                    struct RetArea([::core::mem::MaybeUninit::<u8>; 24*::core::mem::size_of::<*const u8>()]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24*::core::mem::size_of::<*const u8>()]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
                    *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                    let vec2 = value_json;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
                    match ctx {
                      Some(e) => {
                        *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant3, team:team3, user:user3, deployment:deployment3, trace_id:trace_id3, } = e;
                        let vec4 = tenant3;
                        let ptr4 = vec4.as_ptr().cast::<u8>();
                        let len4 = vec4.len();
                        *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                        *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                        match team3 {
                          Some(e) => {
                            *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec5 = e;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                            *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
                          },
                          None => {
                            {
                              *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };match user3 {
                          Some(e) => {
                            *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec6 = e;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                            *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                          },
                          None => {
                            {
                              *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud7, region:region7, platform:platform7, runtime:runtime7, } = deployment3;
                        *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud7.clone() as i32) as u8;
                        match region7 {
                          Some(e) => {
                            *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec8 = e;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                            *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                          },
                          None => {
                            {
                              *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };*ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform7.clone() as i32) as u8;
                        match runtime7 {
                          Some(e) => {
                            *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                            *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                          },
                          None => {
                            {
                              *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };match trace_id3 {
                          Some(e) => {
                            *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec10 = e;
                            let ptr10 = vec10.as_ptr().cast::<u8>();
                            let len10 = vec10.len();
                            *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                            *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                          },
                          None => {
                            {
                              *ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };},
                        None => {
                          {
                            *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };let ptr11 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "greentic:host-import/state@0.6.0")]
                      unsafe extern "C" {
                        #[link_name = "set"]
                        fn wit_import12(_: *mut u8, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import12(_: *mut u8, _: *mut u8, ) { unreachable!() }
                      wit_import12(ptr0, ptr11);
                      let l13 = i32::from(*ptr11.add(0).cast::<u8>());
                      let result16 = match l13 {
                        0 => {
                          let e = {
                            let l14 = i32::from(*ptr11.add(1).cast::<u8>());

                            OpAck::_lift(l14 as u8)
                          };
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l15 = i32::from(*ptr11.add(1).cast::<u8>());

                            super::super::super::greentic::types_core::types::IfaceError::_lift(l15 as u8)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result16
                    }
                  }

                }

                /// session pause/resume helpers
                #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
                pub mod session {
                  #[used]
                  #[doc(hidden)]
                  static __FORCE_SECTION_REF: fn() =
                  super::super::super::__link_custom_section_describing_imports;
                  
                  use super::super::super::_rt;
                  pub type TenantCtx = super::super::super::greentic::types_core::types::TenantCtx;
                  pub type IfaceError = super::super::super::greentic::types_core::types::IfaceError;
                  pub type SessionCursor = super::super::super::greentic::interfaces_types::types::SessionCursor;
                  #[allow(unused_unsafe, clippy::all)]
                  #[allow(async_fn_in_trait)]
                  pub fn update(cursor: &SessionCursor,ctx: Option<&TenantCtx>,) -> Result<_rt::String,IfaceError>{
                    unsafe {

                      #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                      #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                      struct RetArea([::core::mem::MaybeUninit::<u8>; 28*::core::mem::size_of::<*const u8>()]);
                      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28*::core::mem::size_of::<*const u8>()]);
                      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let super::super::super::greentic::interfaces_types::types::SessionCursor{ node_pointer:node_pointer1, wait_reason:wait_reason1, outbox_marker:outbox_marker1, } = cursor;
                      let vec2 = node_pointer1;
                      let ptr2 = vec2.as_ptr().cast::<u8>();
                      let len2 = vec2.len();
                      *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                      *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                      match wait_reason1 {
                        Some(e) => {
                          *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec3 = e;
                          let ptr3 = vec3.as_ptr().cast::<u8>();
                          let len3 = vec3.len();
                          *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                          *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                        },
                        None => {
                          {
                            *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match outbox_marker1 {
                        Some(e) => {
                          *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec4 = e;
                          let ptr4 = vec4.as_ptr().cast::<u8>();
                          let len4 = vec4.len();
                          *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                          *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                        },
                        None => {
                          {
                            *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match ctx {
                        Some(e) => {
                          *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let super::super::super::greentic::types_core::types::TenantCtx{ tenant:tenant5, team:team5, user:user5, deployment:deployment5, trace_id:trace_id5, } = e;
                          let vec6 = tenant5;
                          let ptr6 = vec6.as_ptr().cast::<u8>();
                          let len6 = vec6.len();
                          *ptr0.add(10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                          *ptr0.add(9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
                          match team5 {
                            Some(e) => {
                              *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let vec7 = e;
                              let ptr7 = vec7.as_ptr().cast::<u8>();
                              let len7 = vec7.len();
                              *ptr0.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                              *ptr0.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                            },
                            None => {
                              {
                                *ptr0.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };match user5 {
                            Some(e) => {
                              *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let vec8 = e;
                              let ptr8 = vec8.as_ptr().cast::<u8>();
                              let len8 = vec8.len();
                              *ptr0.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                              *ptr0.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
                            },
                            None => {
                              {
                                *ptr0.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };let super::super::super::greentic::types_core::types::DeploymentCtx{ cloud:cloud9, region:region9, platform:platform9, runtime:runtime9, } = deployment5;
                          *ptr0.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (cloud9.clone() as i32) as u8;
                          match region9 {
                            Some(e) => {
                              *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let vec10 = e;
                              let ptr10 = vec10.as_ptr().cast::<u8>();
                              let len10 = vec10.len();
                              *ptr0.add(20*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                              *ptr0.add(19*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
                            },
                            None => {
                              {
                                *ptr0.add(18*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };*ptr0.add(21*::core::mem::size_of::<*const u8>()).cast::<u8>() = (platform9.clone() as i32) as u8;
                          match runtime9 {
                            Some(e) => {
                              *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let vec11 = e;
                              let ptr11 = vec11.as_ptr().cast::<u8>();
                              let len11 = vec11.len();
                              *ptr0.add(24*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                              *ptr0.add(23*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
                            },
                            None => {
                              {
                                *ptr0.add(22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };match trace_id5 {
                            Some(e) => {
                              *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                              let vec12 = e;
                              let ptr12 = vec12.as_ptr().cast::<u8>();
                              let len12 = vec12.len();
                              *ptr0.add(27*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                              *ptr0.add(26*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr12.cast_mut();
                            },
                            None => {
                              {
                                *ptr0.add(25*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };},
                          None => {
                            {
                              *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };let ptr13 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "greentic:host-import/session@0.6.0")]
                        unsafe extern "C" {
                          #[link_name = "update"]
                          fn wit_import14(_: *mut u8, _: *mut u8, );
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import14(_: *mut u8, _: *mut u8, ) { unreachable!() }
                        wit_import14(ptr0, ptr13);
                        let l15 = i32::from(*ptr13.add(0).cast::<u8>());
                        let result20 = match l15 {
                          0 => {
                            let e = {
                              let l16 = *ptr13.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l17 = *ptr13.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let len18 = l17;
                              let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                              _rt::string_lift(bytes18)
                            };
                            Ok(e)
                          }
                          1 => {
                            let e = {
                              let l19 = i32::from(*ptr13.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                              super::super::super::greentic::types_core::types::IfaceError::_lift(l19 as u8)
                            };
                            Err(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        };
                        result20
                      }
                    }

                  }

                }
                pub mod interfaces_types {

                  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
                  pub mod types {
                    #[used]
                    #[doc(hidden)]
                    static __FORCE_SECTION_REF: fn() =
                    super::super::super::__link_custom_section_describing_imports;
                    
                    use super::super::super::_rt;
                    /// Environment identifier.
                    pub type EnvId = _rt::String;
                    /// Tenant identifier propagated across providers.
                    pub type TenantId = _rt::String;
                    /// Team identifier scoped to a tenant.
                    pub type TeamId = _rt::String;
                    /// User identifier scoped to a tenant.
                    pub type UserId = _rt::String;
                    /// Stable key referencing persisted state blobs.
                    pub type StateKey = _rt::String;
                    /// Stable key referencing sessions.
                    pub type SessionKey = _rt::String;
                    /// Impersonation context propagated with a tenant.
                    #[derive(Clone)]
                    pub struct Impersonation {
                      pub actor_id: UserId,
                      pub reason: Option<_rt::String>,
                    }
                    impl ::core::fmt::Debug for Impersonation {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Impersonation").field("actor-id", &self.actor_id).field("reason", &self.reason).finish()
                      }
                    }
                    /// Invocation tenant context shared across Greentic surfaces.
                    #[derive(Clone)]
                    pub struct TenantCtx {
                      pub env: EnvId,
                      pub tenant: TenantId,
                      pub tenant_id: TenantId,
                      pub team: Option<TeamId>,
                      pub team_id: Option<TeamId>,
                      pub user: Option<UserId>,
                      pub user_id: Option<UserId>,
                      pub trace_id: Option<_rt::String>,
                      pub correlation_id: Option<_rt::String>,
                      pub attributes: _rt::Vec::<(_rt::String,_rt::String,)>,
                      pub session_id: Option<_rt::String>,
                      pub flow_id: Option<_rt::String>,
                      pub node_id: Option<_rt::String>,
                      pub provider_id: Option<_rt::String>,
                      pub deadline_ms: Option<i64>,
                      pub attempt: u32,
                      pub idempotency_key: Option<_rt::String>,
                      pub impersonation: Option<Impersonation>,
                    }
                    impl ::core::fmt::Debug for TenantCtx {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("TenantCtx").field("env", &self.env).field("tenant", &self.tenant).field("tenant-id", &self.tenant_id).field("team", &self.team).field("team-id", &self.team_id).field("user", &self.user).field("user-id", &self.user_id).field("trace-id", &self.trace_id).field("correlation-id", &self.correlation_id).field("attributes", &self.attributes).field("session-id", &self.session_id).field("flow-id", &self.flow_id).field("node-id", &self.node_id).field("provider-id", &self.provider_id).field("deadline-ms", &self.deadline_ms).field("attempt", &self.attempt).field("idempotency-key", &self.idempotency_key).field("impersonation", &self.impersonation).finish()
                      }
                    }
                    /// Cursor describing a session position.
                    #[derive(Clone)]
                    pub struct SessionCursor {
                      pub node_pointer: _rt::String,
                      pub wait_reason: Option<_rt::String>,
                      pub outbox_marker: Option<_rt::String>,
                    }
                    impl ::core::fmt::Debug for SessionCursor {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("SessionCursor").field("node-pointer", &self.node_pointer).field("wait-reason", &self.wait_reason).field("outbox-marker", &self.outbox_marker).finish()
                      }
                    }
                    /// Canonical error codes surfaced by the platform.
                    #[repr(u8)]
                    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                    pub enum ErrorCode {
                      Unknown,
                      InvalidInput,
                      NotFound,
                      Conflict,
                      Timeout,
                      Unauthenticated,
                      PermissionDenied,
                      RateLimited,
                      Unavailable,
                      Internal,
                    }
                    impl ::core::fmt::Debug for ErrorCode {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          ErrorCode::Unknown => {
                            f.debug_tuple("ErrorCode::Unknown").finish()
                          }
                          ErrorCode::InvalidInput => {
                            f.debug_tuple("ErrorCode::InvalidInput").finish()
                          }
                          ErrorCode::NotFound => {
                            f.debug_tuple("ErrorCode::NotFound").finish()
                          }
                          ErrorCode::Conflict => {
                            f.debug_tuple("ErrorCode::Conflict").finish()
                          }
                          ErrorCode::Timeout => {
                            f.debug_tuple("ErrorCode::Timeout").finish()
                          }
                          ErrorCode::Unauthenticated => {
                            f.debug_tuple("ErrorCode::Unauthenticated").finish()
                          }
                          ErrorCode::PermissionDenied => {
                            f.debug_tuple("ErrorCode::PermissionDenied").finish()
                          }
                          ErrorCode::RateLimited => {
                            f.debug_tuple("ErrorCode::RateLimited").finish()
                          }
                          ErrorCode::Unavailable => {
                            f.debug_tuple("ErrorCode::Unavailable").finish()
                          }
                          ErrorCode::Internal => {
                            f.debug_tuple("ErrorCode::Internal").finish()
                          }
                        }
                      }
                    }

                    impl ErrorCode{
                      #[doc(hidden)]
                      pub unsafe fn _lift(val: u8) -> ErrorCode{
                        if !cfg!(debug_assertions) {
                          return unsafe { ::core::mem::transmute(val) };
                        }

                        match val {
                          0 => ErrorCode::Unknown,
                          1 => ErrorCode::InvalidInput,
                          2 => ErrorCode::NotFound,
                          3 => ErrorCode::Conflict,
                          4 => ErrorCode::Timeout,
                          5 => ErrorCode::Unauthenticated,
                          6 => ErrorCode::PermissionDenied,
                          7 => ErrorCode::RateLimited,
                          8 => ErrorCode::Unavailable,
                          9 => ErrorCode::Internal,

                          _ => panic!("invalid enum discriminant"),
                        }
                      }
                    }

                    /// Pending outcome payload.
                    #[derive(Clone)]
                    pub struct OutcomePending {
                      pub reason: _rt::String,
                      pub expected_input: Option<_rt::Vec::<_rt::String>>,
                    }
                    impl ::core::fmt::Debug for OutcomePending {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("OutcomePending").field("reason", &self.reason).field("expected-input", &self.expected_input).finish()
                      }
                    }
                    /// Error outcome payload.
                    #[derive(Clone)]
                    pub struct OutcomeError {
                      pub code: ErrorCode,
                      pub message: _rt::String,
                    }
                    impl ::core::fmt::Debug for OutcomeError {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("OutcomeError").field("code", &self.code).field("message", &self.message).finish()
                      }
                    }
                    /// Execution outcome for string payloads.
                    #[derive(Clone)]
                    pub enum Outcome {
                      Done(_rt::String),
                      Pending(OutcomePending),
                      Error(OutcomeError),
                    }
                    impl ::core::fmt::Debug for Outcome {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          Outcome::Done(e) => {
                            f.debug_tuple("Outcome::Done").field(e).finish()
                          }
                          Outcome::Pending(e) => {
                            f.debug_tuple("Outcome::Pending").field(e).finish()
                          }
                          Outcome::Error(e) => {
                            f.debug_tuple("Outcome::Error").field(e).finish()
                          }
                        }
                      }
                    }
                    /// Supported network protocols.
                    #[derive(Clone)]
                    pub enum Protocol {
                      Http,
                      Https,
                      Tcp,
                      Udp,
                      Grpc,
                      Custom(_rt::String),
                    }
                    impl ::core::fmt::Debug for Protocol {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          Protocol::Http => {
                            f.debug_tuple("Protocol::Http").finish()
                          }
                          Protocol::Https => {
                            f.debug_tuple("Protocol::Https").finish()
                          }
                          Protocol::Tcp => {
                            f.debug_tuple("Protocol::Tcp").finish()
                          }
                          Protocol::Udp => {
                            f.debug_tuple("Protocol::Udp").finish()
                          }
                          Protocol::Grpc => {
                            f.debug_tuple("Protocol::Grpc").finish()
                          }
                          Protocol::Custom(e) => {
                            f.debug_tuple("Protocol::Custom").field(e).finish()
                          }
                        }
                      }
                    }
                    /// Allow list describing permitted connectivity.
                    #[derive(Clone)]
                    pub struct AllowList {
                      pub domains: _rt::Vec::<_rt::String>,
                      pub ports: _rt::Vec::<u16>,
                      pub protocols: _rt::Vec::<Protocol>,
                    }
                    impl ::core::fmt::Debug for AllowList {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("AllowList").field("domains", &self.domains).field("ports", &self.ports).field("protocols", &self.protocols).finish()
                      }
                    }
                    /// Network policy composed of allow lists.
                    #[derive(Clone)]
                    pub struct NetworkPolicy {
                      pub egress: AllowList,
                      pub deny_on_miss: bool,
                    }
                    impl ::core::fmt::Debug for NetworkPolicy {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("NetworkPolicy").field("egress", &self.egress).field("deny-on-miss", &self.deny_on_miss).finish()
                      }
                    }
                    /// Detached signature accompanying a pack.
                    #[derive(Clone)]
                    pub enum SignatureAlgorithm {
                      Ed25519,
                      Other(_rt::String),
                    }
                    impl ::core::fmt::Debug for SignatureAlgorithm {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          SignatureAlgorithm::Ed25519 => {
                            f.debug_tuple("SignatureAlgorithm::Ed25519").finish()
                          }
                          SignatureAlgorithm::Other(e) => {
                            f.debug_tuple("SignatureAlgorithm::Other").field(e).finish()
                          }
                        }
                      }
                    }
                    #[derive(Clone)]
                    pub struct Signature {
                      pub key_id: _rt::String,
                      pub algorithm: SignatureAlgorithm,
                      pub signature: _rt::Vec::<u8>,
                    }
                    impl ::core::fmt::Debug for Signature {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Signature").field("key-id", &self.key_id).field("algorithm", &self.algorithm).field("signature", &self.signature).finish()
                      }
                    }
                    /// Pack reference stored in registries.
                    #[derive(Clone)]
                    pub struct PackRef {
                      pub oci_url: _rt::String,
                      pub version: _rt::String,
                      pub digest: _rt::String,
                      pub signatures: _rt::Vec::<Signature>,
                    }
                    impl ::core::fmt::Debug for PackRef {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("PackRef").field("oci-url", &self.oci_url).field("version", &self.version).field("digest", &self.digest).field("signatures", &self.signatures).finish()
                      }
                    }
                    /// Minimal telemetry span context.
                    #[derive(Clone)]
                    pub struct SpanContext {
                      pub tenant: TenantId,
                      pub session_id: Option<SessionKey>,
                      pub flow_id: _rt::String,
                      pub node_id: Option<_rt::String>,
                      pub provider: _rt::String,
                      pub start_ms: Option<i64>,
                      pub end_ms: Option<i64>,
                    }
                    impl ::core::fmt::Debug for SpanContext {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("SpanContext").field("tenant", &self.tenant).field("session-id", &self.session_id).field("flow-id", &self.flow_id).field("node-id", &self.node_id).field("provider", &self.provider).field("start-ms", &self.start_ms).field("end-ms", &self.end_ms).finish()
                      }
                    }

                  }

                }
                pub mod types_core {

                  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
                  pub mod types {
                    #[used]
                    #[doc(hidden)]
                    static __FORCE_SECTION_REF: fn() =
                    super::super::super::__link_custom_section_describing_imports;
                    
                    use super::super::super::_rt;
                    /// identifiers
                    pub type FlowId = _rt::String;
                    pub type TenantId = _rt::String;
                    pub type TeamId = _rt::String;
                    pub type UserId = _rt::String;
                    /// clouds & platforms (keep enums stable; add variants only in minor bumps)
                    #[repr(u8)]
                    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                    pub enum Cloud {
                      Aws,
                      Gcp,
                      Azure,
                      Hetzner,
                      Local,
                      Other,
                    }
                    impl ::core::fmt::Debug for Cloud {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          Cloud::Aws => {
                            f.debug_tuple("Cloud::Aws").finish()
                          }
                          Cloud::Gcp => {
                            f.debug_tuple("Cloud::Gcp").finish()
                          }
                          Cloud::Azure => {
                            f.debug_tuple("Cloud::Azure").finish()
                          }
                          Cloud::Hetzner => {
                            f.debug_tuple("Cloud::Hetzner").finish()
                          }
                          Cloud::Local => {
                            f.debug_tuple("Cloud::Local").finish()
                          }
                          Cloud::Other => {
                            f.debug_tuple("Cloud::Other").finish()
                          }
                        }
                      }
                    }

                    impl Cloud{
                      #[doc(hidden)]
                      pub unsafe fn _lift(val: u8) -> Cloud{
                        if !cfg!(debug_assertions) {
                          return unsafe { ::core::mem::transmute(val) };
                        }

                        match val {
                          0 => Cloud::Aws,
                          1 => Cloud::Gcp,
                          2 => Cloud::Azure,
                          3 => Cloud::Hetzner,
                          4 => Cloud::Local,
                          5 => Cloud::Other,

                          _ => panic!("invalid enum discriminant"),
                        }
                      }
                    }

                    #[repr(u8)]
                    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                    pub enum Platform {
                      K8s,
                      Nomad,
                      Systemd,
                      Cfworkers,
                      Lambda,
                      Baremetal,
                      Other,
                    }
                    impl ::core::fmt::Debug for Platform {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          Platform::K8s => {
                            f.debug_tuple("Platform::K8s").finish()
                          }
                          Platform::Nomad => {
                            f.debug_tuple("Platform::Nomad").finish()
                          }
                          Platform::Systemd => {
                            f.debug_tuple("Platform::Systemd").finish()
                          }
                          Platform::Cfworkers => {
                            f.debug_tuple("Platform::Cfworkers").finish()
                          }
                          Platform::Lambda => {
                            f.debug_tuple("Platform::Lambda").finish()
                          }
                          Platform::Baremetal => {
                            f.debug_tuple("Platform::Baremetal").finish()
                          }
                          Platform::Other => {
                            f.debug_tuple("Platform::Other").finish()
                          }
                        }
                      }
                    }

                    impl Platform{
                      #[doc(hidden)]
                      pub unsafe fn _lift(val: u8) -> Platform{
                        if !cfg!(debug_assertions) {
                          return unsafe { ::core::mem::transmute(val) };
                        }

                        match val {
                          0 => Platform::K8s,
                          1 => Platform::Nomad,
                          2 => Platform::Systemd,
                          3 => Platform::Cfworkers,
                          4 => Platform::Lambda,
                          5 => Platform::Baremetal,
                          6 => Platform::Other,

                          _ => panic!("invalid enum discriminant"),
                        }
                      }
                    }

                    /// flow deployment context supplied by hosts
                    #[derive(Clone)]
                    pub struct DeploymentCtx {
                      pub cloud: Cloud,
                      pub region: Option<_rt::String>,
                      pub platform: Platform,
                      pub runtime: Option<_rt::String>,
                    }
                    impl ::core::fmt::Debug for DeploymentCtx {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("DeploymentCtx").field("cloud", &self.cloud).field("region", &self.region).field("platform", &self.platform).field("runtime", &self.runtime).finish()
                      }
                    }
                    /// tenant identity and invocation metadata
                    #[derive(Clone)]
                    pub struct TenantCtx {
                      pub tenant: TenantId,
                      pub team: Option<TeamId>,
                      pub user: Option<UserId>,
                      pub deployment: DeploymentCtx,
                      pub trace_id: Option<_rt::String>,
                    }
                    impl ::core::fmt::Debug for TenantCtx {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("TenantCtx").field("tenant", &self.tenant).field("team", &self.team).field("user", &self.user).field("deployment", &self.deployment).field("trace-id", &self.trace_id).finish()
                      }
                    }
                    /// flow registration information
                    #[derive(Clone)]
                    pub struct FlowInfo {
                      pub id: FlowId,
                      /// human-readable name
                      pub profile: _rt::String,
                      /// semver identifier
                      pub version: _rt::String,
                      /// "messaging" | "webhook" | "timer" | ...
                      pub type_: _rt::String,
                      pub private: bool,
                    }
                    impl ::core::fmt::Debug for FlowInfo {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("FlowInfo").field("id", &self.id).field("profile", &self.profile).field("version", &self.version).field("type", &self.type_).field("private", &self.private).finish()
                      }
                    }
                    /// execution modifiers supplied when running a flow
                    #[derive(Clone)]
                    pub struct RunOpts {
                      pub tenant: Option<TenantCtx>,
                      pub timeout_ms: Option<u32>,
                      /// Wasm "fuel" if host enforces
                      pub fuel_units: Option<u64>,
                    }
                    impl ::core::fmt::Debug for RunOpts {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("RunOpts").field("tenant", &self.tenant).field("timeout-ms", &self.timeout_ms).field("fuel-units", &self.fuel_units).finish()
                      }
                    }
                    /// JSON schema documents describing flow IO
                    #[derive(Clone)]
                    pub struct SchemaDoc {
                      pub input_jsonschema: _rt::String,
                      pub output_jsonschema: _rt::String,
                    }
                    impl ::core::fmt::Debug for SchemaDoc {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("SchemaDoc").field("input-jsonschema", &self.input_jsonschema).field("output-jsonschema", &self.output_jsonschema).finish()
                      }
                    }
                    /// result returned by a flow execution
                    #[derive(Clone)]
                    pub struct RunResult {
                      /// "ok" | "error" | "deferred"
                      pub status: _rt::String,
                      pub output_json: Option<_rt::String>,
                      pub error: Option<_rt::String>,
                      pub logs_json: Option<_rt::String>,
                      pub metrics_json: Option<_rt::String>,
                    }
                    impl ::core::fmt::Debug for RunResult {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("RunResult").field("status", &self.status).field("output-json", &self.output_json).field("error", &self.error).field("logs-json", &self.logs_json).field("metrics-json", &self.metrics_json).finish()
                      }
                    }
                    /// A2A search candidate
                    #[derive(Clone)]
                    pub struct A2aCandidate {
                      pub flow: FlowId,
                      pub score: f32,
                    }
                    impl ::core::fmt::Debug for A2aCandidate {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("A2aCandidate").field("flow", &self.flow).field("score", &self.score).finish()
                      }
                    }
                    /// standardized interface errors
                    #[repr(u8)]
                    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                    pub enum IfaceError {
                      InvalidArg,
                      NotFound,
                      Denied,
                      Unavailable,
                      Internal,
                    }
                    impl IfaceError{
                      pub fn name(&self) -> &'static str {
                        match self {
                          IfaceError::InvalidArg => "invalid-arg",
                          IfaceError::NotFound => "not-found",
                          IfaceError::Denied => "denied",
                          IfaceError::Unavailable => "unavailable",
                          IfaceError::Internal => "internal",
                        }
                      }
                      pub fn message(&self) -> &'static str {
                        match self {
                          IfaceError::InvalidArg => "",
                          IfaceError::NotFound => "",
                          IfaceError::Denied => "",
                          IfaceError::Unavailable => "",
                          IfaceError::Internal => "",
                        }
                      }
                    }
                    impl ::core::fmt::Debug for IfaceError{
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("IfaceError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                      }
                    }
                    impl ::core::fmt::Display for IfaceError{
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        write!(f, "{} (error {})", self.name(), *self as i32)
                      }
                    }

                    impl ::core::error::Error for IfaceError {}

                    impl IfaceError{
                      #[doc(hidden)]
                      pub unsafe fn _lift(val: u8) -> IfaceError{
                        if !cfg!(debug_assertions) {
                          return unsafe { ::core::mem::transmute(val) };
                        }

                        match val {
                          0 => IfaceError::InvalidArg,
                          1 => IfaceError::NotFound,
                          2 => IfaceError::Denied,
                          3 => IfaceError::Unavailable,
                          4 => IfaceError::Internal,

                          _ => panic!("invalid enum discriminant"),
                        }
                      }
                    }


                  }

                }
              }
              mod _rt {
                #![allow(dead_code, clippy::all)]
                pub use alloc_crate::string::String;
                pub use alloc_crate::vec::Vec;
                pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
                  if cfg!(debug_assertions) {
                    String::from_utf8(bytes).unwrap()
                  } else {
                    unsafe { String::from_utf8_unchecked(bytes) }
                  }
                }
                pub unsafe fn invalid_enum_discriminant<T>() -> T {
                  if cfg!(debug_assertions) {
                    panic!("invalid enum discriminant")
                  } else {
                    unsafe { core::hint::unreachable_unchecked() }
                  }
                }
                extern crate alloc as alloc_crate;
              }

              #[cfg(target_arch = "wasm32")]
              #[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:host-import@0.6.0:host-imports:encoded world")]
              #[doc(hidden)]
              #[allow(clippy::octal_escapes)]
              pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3007] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xbc\x16\x01A\x02\x01\
A\x14\x01B\"\x01s\x04\0\x07flow-id\x03\0\0\x01s\x04\0\x09tenant-id\x03\0\x02\x01\
s\x04\0\x07team-id\x03\0\x04\x01s\x04\0\x07user-id\x03\0\x06\x01m\x06\x03aws\x03\
gcp\x05azure\x07hetzner\x05local\x05other\x04\0\x05cloud\x03\0\x08\x01m\x07\x03k\
8s\x05nomad\x07systemd\x09cfworkers\x06lambda\x09baremetal\x05other\x04\0\x08pla\
tform\x03\0\x0a\x01ks\x01r\x04\x05cloud\x09\x06region\x0c\x08platform\x0b\x07run\
time\x0c\x04\0\x0edeployment-ctx\x03\0\x0d\x01k\x05\x01k\x07\x01r\x05\x06tenant\x03\
\x04team\x0f\x04user\x10\x0adeployment\x0e\x08trace-id\x0c\x04\0\x0atenant-ctx\x03\
\0\x11\x01r\x05\x02id\x01\x07profiles\x07versions\x04types\x07private\x7f\x04\0\x09\
flow-info\x03\0\x13\x01k\x12\x01ky\x01kw\x01r\x03\x06tenant\x15\x0atimeout-ms\x16\
\x0afuel-units\x17\x04\0\x08run-opts\x03\0\x18\x01r\x02\x10input-jsonschemas\x11\
output-jsonschemas\x04\0\x0aschema-doc\x03\0\x1a\x01r\x05\x06statuss\x0boutput-j\
son\x0c\x05error\x0c\x09logs-json\x0c\x0cmetrics-json\x0c\x04\0\x0arun-result\x03\
\0\x1c\x01r\x02\x04flow\x01\x05scorev\x04\0\x0da2a-candidate\x03\0\x1e\x01m\x05\x0b\
invalid-arg\x09not-found\x06denied\x0bunavailable\x08internal\x04\0\x0biface-err\
or\x03\0\x20\x03\0\x1fgreentic:types-core/types@0.4.0\x05\0\x02\x03\0\0\x0atenan\
t-ctx\x02\x03\0\0\x0biface-error\x01B\x08\x02\x03\x02\x01\x01\x04\0\x0atenant-ct\
x\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0biface-error\x03\0\x02\x01k\x01\x01j\x01s\x01\
\x03\x01@\x02\x03keys\x03ctx\x04\0\x05\x04\0\x03get\x01\x06\x03\0\"greentic:host\
-import/secrets@0.6.0\x05\x03\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0atenant-ctx\x03\
\0\0\x01k\x01\x01@\x02\x09span-jsons\x03ctx\x02\x01\0\x04\0\x04emit\x01\x03\x03\0\
$greentic:host-import/telemetry@0.6.0\x05\x04\x01B\x0d\x02\x03\x02\x01\x01\x04\0\
\x0atenant-ctx\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0biface-error\x03\0\x02\x01ks\x01\
r\x04\x06methods\x03urls\x0cheaders-json\x04\x04body\x04\x04\0\x0chttp-request\x03\
\0\x05\x01r\x03\x06status{\x0cheaders-json\x04\x04body\x04\x04\0\x0dhttp-respons\
e\x03\0\x07\x01k\x01\x01j\x01\x08\x01\x03\x01@\x02\x03req\x06\x03ctx\x09\0\x0a\x04\
\0\x05fetch\x01\x0b\x03\0\x1fgreentic:host-import/http@0.6.0\x05\x05\x01B\x08\x02\
\x03\x02\x01\x01\x04\0\x0atenant-ctx\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0biface-\
error\x03\0\x02\x01k\x01\x01j\x01s\x01\x03\x01@\x04\x09components\x06actions\x09\
args-jsons\x03ctx\x04\0\x05\x04\0\x04exec\x01\x06\x03\0\x1egreentic:host-import/\
mcp@0.6.0\x05\x06\x01B6\x01s\x04\0\x06env-id\x03\0\0\x01s\x04\0\x09tenant-id\x03\
\0\x02\x01s\x04\0\x07team-id\x03\0\x04\x01s\x04\0\x07user-id\x03\0\x06\x01s\x04\0\
\x09state-key\x03\0\x08\x01s\x04\0\x0bsession-key\x03\0\x0a\x01ks\x01r\x02\x08ac\
tor-id\x07\x06reason\x0c\x04\0\x0dimpersonation\x03\0\x0d\x01k\x05\x01k\x07\x01o\
\x02ss\x01p\x11\x01kx\x01k\x0e\x01r\x12\x03env\x01\x06tenant\x03\x09tenant-id\x03\
\x04team\x0f\x07team-id\x0f\x04user\x10\x07user-id\x10\x08trace-id\x0c\x0ecorrel\
ation-id\x0c\x0aattributes\x12\x0asession-id\x0c\x07flow-id\x0c\x07node-id\x0c\x0b\
provider-id\x0c\x0bdeadline-ms\x13\x07attempty\x0fidempotency-key\x0c\x0dimperso\
nation\x14\x04\0\x0atenant-ctx\x03\0\x15\x01r\x03\x0cnode-pointers\x0bwait-reaso\
n\x0c\x0doutbox-marker\x0c\x04\0\x0esession-cursor\x03\0\x17\x01m\x0a\x07unknown\
\x0dinvalid-input\x09not-found\x08conflict\x07timeout\x0funauthenticated\x11perm\
ission-denied\x0crate-limited\x0bunavailable\x08internal\x04\0\x0aerror-code\x03\
\0\x19\x01ps\x01k\x1b\x01r\x02\x06reasons\x0eexpected-input\x1c\x04\0\x0foutcome\
-pending\x03\0\x1d\x01r\x02\x04code\x1a\x07messages\x04\0\x0doutcome-error\x03\0\
\x1f\x01q\x03\x04done\x01s\0\x07pending\x01\x1e\0\x05error\x01\x20\0\x04\0\x07ou\
tcome\x03\0!\x01q\x06\x04http\0\0\x05https\0\0\x03tcp\0\0\x03udp\0\0\x04grpc\0\0\
\x06custom\x01s\0\x04\0\x08protocol\x03\0#\x01p{\x01p$\x01r\x03\x07domains\x1b\x05\
ports%\x09protocols&\x04\0\x0aallow-list\x03\0'\x01r\x02\x06egress(\x0cdeny-on-m\
iss\x7f\x04\0\x0enetwork-policy\x03\0)\x01q\x02\x07ed25519\0\0\x05other\x01s\0\x04\
\0\x13signature-algorithm\x03\0+\x01p}\x01r\x03\x06key-ids\x09algorithm,\x09sign\
ature-\x04\0\x09signature\x03\0.\x01p/\x01r\x04\x07oci-urls\x07versions\x06diges\
ts\x0asignatures0\x04\0\x08pack-ref\x03\01\x01k\x0b\x01r\x07\x06tenant\x03\x0ase\
ssion-id3\x07flow-ids\x07node-id\x0c\x08providers\x08start-ms\x13\x06end-ms\x13\x04\
\0\x0cspan-context\x03\04\x03\0%greentic:interfaces-types/types@0.1.0\x05\x07\x02\
\x03\0\x05\x09state-key\x01B\x0f\x02\x03\x02\x01\x01\x04\0\x0atenant-ctx\x03\0\0\
\x02\x03\x02\x01\x02\x04\0\x0biface-error\x03\0\x02\x02\x03\x02\x01\x08\x04\0\x09\
state-key\x03\0\x04\x01m\x01\x02ok\x04\0\x06op-ack\x03\0\x06\x01k\x01\x01j\x01s\x01\
\x03\x01@\x02\x03key\x05\x03ctx\x08\0\x09\x04\0\x03get\x01\x0a\x01j\x01\x07\x01\x03\
\x01@\x03\x03key\x05\x0avalue-jsons\x03ctx\x08\0\x0b\x04\0\x03set\x01\x0c\x03\0\x20\
greentic:host-import/state@0.6.0\x05\x09\x02\x03\0\x05\x0esession-cursor\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x0atenant-ctx\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0bif\
ace-error\x03\0\x02\x02\x03\x02\x01\x0a\x04\0\x0esession-cursor\x03\0\x04\x01k\x01\
\x01j\x01s\x01\x03\x01@\x02\x06cursor\x05\x03ctx\x06\0\x07\x04\0\x06update\x01\x08\
\x03\0\"greentic:host-import/session@0.6.0\x05\x0b\x04\0'greentic:host-import/ho\
st-imports@0.6.0\x04\0\x0b\x12\x01\0\x0chost-imports\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.240.0\x10wit-bindgen-rust\x060.47.0";

              #[inline(never)]
              #[doc(hidden)]
              pub fn __link_custom_section_describing_imports() {
                wit_bindgen::rt::maybe_link_cabi_realloc();
              }
              
