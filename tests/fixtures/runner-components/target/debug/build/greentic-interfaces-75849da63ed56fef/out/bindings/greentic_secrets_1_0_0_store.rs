// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod greentic {
  pub mod secrets {
    /// Secrets interface exposed by Greentic hosts.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod secret_store {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// Canonical host error payload.
      #[derive(Clone)]
      pub struct HostError {
        pub code: _rt::String,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for HostError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("HostError").field("code", &self.code).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for HostError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for HostError {}
      /// Trivial acknowledgment returned by write/delete operations.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum OpAck {
        Ok,
      }
      impl ::core::fmt::Debug for OpAck {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            OpAck::Ok => {
              f.debug_tuple("OpAck::Ok").finish()
            }
          }
        }
      }

      impl OpAck{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> OpAck{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => OpAck::Ok,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[allow(unused_unsafe, clippy::all)]
      /// Reads a secret value.
      #[allow(async_fn_in_trait)]
      pub fn read(name: &str,) -> Result<_rt::Vec::<u8>,HostError>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 5*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 5*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "greentic:secrets/secret-store@1.0.0")]
          unsafe extern "C" {
            #[link_name = "read"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result13 = match l3 {
            0 => {
              let e = {
                let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len6 = l5;

                _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l8 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len9 = l8;
                let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                let l10 = *ptr1.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l11 = *ptr1.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len12 = l11;
                let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                HostError{
                  code: _rt::string_lift(bytes9),
                  message: _rt::string_lift(bytes12),
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result13
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Persists or updates a secret value.
      #[allow(async_fn_in_trait)]
      pub fn write(name: &str,bytes: &[u8],) -> Result<OpAck,HostError>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 5*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 5*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = bytes;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "greentic:secrets/secret-store@1.0.0")]
          unsafe extern "C" {
            #[link_name = "write"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l4 = i32::from(*ptr2.add(0).cast::<u8>());
          let result12 = match l4 {
            0 => {
              let e = {
                let l5 = i32::from(*ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                OpAck::_lift(l5 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l7 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len8 = l7;
                let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                let l9 = *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l10 = *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len11 = l10;
                let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                HostError{
                  code: _rt::string_lift(bytes8),
                  message: _rt::string_lift(bytes11),
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result12
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Deletes a secret.
      #[allow(async_fn_in_trait)]
      pub fn delete(name: &str,) -> Result<OpAck,HostError>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 5*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 5*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "greentic:secrets/secret-store@1.0.0")]
          unsafe extern "C" {
            #[link_name = "delete"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result11 = match l3 {
            0 => {
              let e = {
                let l4 = i32::from(*ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                OpAck::_lift(l4 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = *ptr1.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l9 = *ptr1.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len10 = l9;
                let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                HostError{
                  code: _rt::string_lift(bytes7),
                  message: _rt::string_lift(bytes10),
                }
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result11
        }
      }

    }

  }
}
mod _rt {
  #![allow(dead_code, clippy::all)]
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:secrets@1.0.0:store:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 343] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xdb\x01\x01A\x02\x01\
A\x02\x01B\x0d\x01r\x02\x04codes\x07messages\x04\0\x0ahost-error\x03\0\0\x01m\x01\
\x02ok\x04\0\x06op-ack\x03\0\x02\x01p}\x01j\x01\x04\x01\x01\x01@\x01\x04names\0\x05\
\x04\0\x04read\x01\x06\x01j\x01\x03\x01\x01\x01@\x02\x04names\x05bytes\x04\0\x07\
\x04\0\x05write\x01\x08\x01@\x01\x04names\0\x07\x04\0\x06delete\x01\x09\x03\0#gr\
eentic:secrets/secret-store@1.0.0\x05\0\x04\0\x1cgreentic:secrets/store@1.0.0\x04\
\0\x0b\x0b\x01\0\x05store\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit\
-component\x070.240.0\x10wit-bindgen-rust\x060.47.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

