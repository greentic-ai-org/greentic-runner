// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod greentic {
    pub mod types_core {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod shared {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        /// Unique identifier for a flow definition.
        pub type FlowId = _rt::String;
        /// Identifiers for tenant-scoped access control.
        pub type TenantId = _rt::String;
        pub type TeamId = _rt::String;
        pub type UserId = _rt::String;
        /// Supported cloud providers.
        #[derive(Clone, Copy)]
        pub enum Cloud {
          Aws,
          Gcp,
          Azure,
          Hetzner,
          Local,
          Other,
        }
        impl ::core::fmt::Debug for Cloud {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Cloud::Aws => {
                f.debug_tuple("Cloud::Aws").finish()
              }
              Cloud::Gcp => {
                f.debug_tuple("Cloud::Gcp").finish()
              }
              Cloud::Azure => {
                f.debug_tuple("Cloud::Azure").finish()
              }
              Cloud::Hetzner => {
                f.debug_tuple("Cloud::Hetzner").finish()
              }
              Cloud::Local => {
                f.debug_tuple("Cloud::Local").finish()
              }
              Cloud::Other => {
                f.debug_tuple("Cloud::Other").finish()
              }
            }
          }
        }
        /// Supported runtime platforms.
        #[derive(Clone, Copy)]
        pub enum Platform {
          K8s,
          Nomad,
          Systemd,
          Cfworkers,
          Lambda,
          Baremetal,
          Other,
        }
        impl ::core::fmt::Debug for Platform {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Platform::K8s => {
                f.debug_tuple("Platform::K8s").finish()
              }
              Platform::Nomad => {
                f.debug_tuple("Platform::Nomad").finish()
              }
              Platform::Systemd => {
                f.debug_tuple("Platform::Systemd").finish()
              }
              Platform::Cfworkers => {
                f.debug_tuple("Platform::Cfworkers").finish()
              }
              Platform::Lambda => {
                f.debug_tuple("Platform::Lambda").finish()
              }
              Platform::Baremetal => {
                f.debug_tuple("Platform::Baremetal").finish()
              }
              Platform::Other => {
                f.debug_tuple("Platform::Other").finish()
              }
            }
          }
        }
        /// Deployment information where the flow executes.
        #[derive(Clone)]
        pub struct DeploymentCtx {
          pub cloud: Cloud,
          pub region: Option<_rt::String>,
          pub platform: Platform,
          pub runtime: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for DeploymentCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("DeploymentCtx").field("cloud", &self.cloud).field("region", &self.region).field("platform", &self.platform).field("runtime", &self.runtime).finish()
          }
        }
        /// Tenant identity and invocation metadata.
        #[derive(Clone)]
        pub struct TenantCtx {
          pub tenant: TenantId,
          pub team: Option<TeamId>,
          pub user: Option<UserId>,
          pub deployment: DeploymentCtx,
          pub trace_id: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for TenantCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("TenantCtx").field("tenant", &self.tenant).field("team", &self.team).field("user", &self.user).field("deployment", &self.deployment).field("trace-id", &self.trace_id).finish()
          }
        }
        /// Describes a flow that can be invoked by the pack.
        #[derive(Clone)]
        pub struct FlowInfo {
          pub id: FlowId,
          pub profile: _rt::String,
          pub version: _rt::String,
          pub flow_type: _rt::String,
          pub private: bool,
        }
        impl ::core::fmt::Debug for FlowInfo {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("FlowInfo").field("id", &self.id).field("profile", &self.profile).field("version", &self.version).field("flow-type", &self.flow_type).field("private", &self.private).finish()
          }
        }
        /// Runtime configuration when executing a flow.
        #[derive(Clone)]
        pub struct RunOpts {
          pub tenant: Option<TenantCtx>,
          pub timeout_ms: Option<u32>,
          pub fuel_units: Option<u64>,
        }
        impl ::core::fmt::Debug for RunOpts {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RunOpts").field("tenant", &self.tenant).field("timeout-ms", &self.timeout_ms).field("fuel-units", &self.fuel_units).finish()
          }
        }
        /// Schema description for flow inputs and outputs.
        #[derive(Clone)]
        pub struct SchemaDoc {
          pub input_jsonschema: _rt::String,
          pub output_jsonschema: _rt::String,
        }
        impl ::core::fmt::Debug for SchemaDoc {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("SchemaDoc").field("input-jsonschema", &self.input_jsonschema).field("output-jsonschema", &self.output_jsonschema).finish()
          }
        }
        /// Result returned from executing a flow.
        #[derive(Clone)]
        pub struct RunResult {
          pub status: _rt::String,
          pub output_json: Option<_rt::String>,
          pub error: Option<_rt::String>,
          pub logs_json: Option<_rt::String>,
          pub metrics_json: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for RunResult {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RunResult").field("status", &self.status).field("output-json", &self.output_json).field("error", &self.error).field("logs-json", &self.logs_json).field("metrics-json", &self.metrics_json).finish()
          }
        }
        /// Candidate returned from an A2A search.
        #[derive(Clone)]
        pub struct A2aCandidate {
          pub flow: FlowId,
          pub score: f32,
        }
        impl ::core::fmt::Debug for A2aCandidate {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("A2aCandidate").field("flow", &self.flow).field("score", &self.score).finish()
          }
        }
        /// Standard error codes returned by host services.
        #[derive(Clone, Copy)]
        pub enum IfaceError {
          InvalidArg,
          NotFound,
          Denied,
          Unavailable,
          Internal,
        }
        impl ::core::fmt::Debug for IfaceError {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              IfaceError::InvalidArg => {
                f.debug_tuple("IfaceError::InvalidArg").finish()
              }
              IfaceError::NotFound => {
                f.debug_tuple("IfaceError::NotFound").finish()
              }
              IfaceError::Denied => {
                f.debug_tuple("IfaceError::Denied").finish()
              }
              IfaceError::Unavailable => {
                f.debug_tuple("IfaceError::Unavailable").finish()
              }
              IfaceError::Internal => {
                f.debug_tuple("IfaceError::Internal").finish()
              }
            }
          }
        }
        #[doc(hidden)]

        macro_rules! __export_greentic_types_core_shared_0_2_0_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          };);
        }
        #[doc(hidden)]
        pub(crate) use __export_greentic_types_core_shared_0_2_0_cabi;

      }

    }
  }
}
mod _rt {
  #![allow(dead_code, clippy::all)]
  pub use alloc_crate::string::String;
  extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_core_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::greentic::types_core::shared::__export_greentic_types_core_shared_0_2_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::greentic::types_core::shared);
  )
}
#[doc(inline)]
pub(crate) use __export_core_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:types-core@0.2.0:core:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 896] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x85\x06\x01A\x02\x01\
A\x02\x01B\"\x01s\x04\0\x07flow-id\x03\0\0\x01s\x04\0\x09tenant-id\x03\0\x02\x01\
s\x04\0\x07team-id\x03\0\x04\x01s\x04\0\x07user-id\x03\0\x06\x01q\x06\x03aws\0\0\
\x03gcp\0\0\x05azure\0\0\x07hetzner\0\0\x05local\0\0\x05other\0\0\x04\0\x05cloud\
\x03\0\x08\x01q\x07\x03k8s\0\0\x05nomad\0\0\x07systemd\0\0\x09cfworkers\0\0\x06l\
ambda\0\0\x09baremetal\0\0\x05other\0\0\x04\0\x08platform\x03\0\x0a\x01ks\x01r\x04\
\x05cloud\x09\x06region\x0c\x08platform\x0b\x07runtime\x0c\x04\0\x0edeployment-c\
tx\x03\0\x0d\x01k\x05\x01k\x07\x01r\x05\x06tenant\x03\x04team\x0f\x04user\x10\x0a\
deployment\x0e\x08trace-id\x0c\x04\0\x0atenant-ctx\x03\0\x11\x01r\x05\x02id\x01\x07\
profiles\x07versions\x09flow-types\x07private\x7f\x04\0\x09flow-info\x03\0\x13\x01\
k\x12\x01ky\x01kw\x01r\x03\x06tenant\x15\x0atimeout-ms\x16\x0afuel-units\x17\x04\
\0\x08run-opts\x03\0\x18\x01r\x02\x10input-jsonschemas\x11output-jsonschemas\x04\
\0\x0aschema-doc\x03\0\x1a\x01r\x05\x06statuss\x0boutput-json\x0c\x05error\x0c\x09\
logs-json\x0c\x0cmetrics-json\x0c\x04\0\x0arun-result\x03\0\x1c\x01r\x02\x04flow\
\x01\x05scorev\x04\0\x0da2a-candidate\x03\0\x1e\x01q\x05\x0binvalid-arg\0\0\x09n\
ot-found\0\0\x06denied\0\0\x0bunavailable\0\0\x08internal\0\0\x04\0\x0biface-err\
or\x03\0\x20\x04\0\x20greentic:types-core/shared@0.2.0\x05\0\x04\0\x1egreentic:t\
ypes-core/core@0.2.0\x04\0\x0b\x0a\x01\0\x04core\x03\0\0\0G\x09producers\x01\x0c\
processed-by\x02\x0dwit-component\x070.240.0\x10wit-bindgen-rust\x060.47.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

