// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
// Options used:
//   * generate_unused_types
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod greentic {
    pub mod types_core {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod types {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        /// identifiers
        pub type FlowId = _rt::String;
        pub type TenantId = _rt::String;
        pub type TeamId = _rt::String;
        pub type UserId = _rt::String;
        /// clouds & platforms (keep enums stable; add variants only in minor bumps)
        #[repr(u8)]
        #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
        pub enum Cloud {
          Aws,
          Gcp,
          Azure,
          Hetzner,
          Local,
          Other,
        }
        impl ::core::fmt::Debug for Cloud {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Cloud::Aws => {
                f.debug_tuple("Cloud::Aws").finish()
              }
              Cloud::Gcp => {
                f.debug_tuple("Cloud::Gcp").finish()
              }
              Cloud::Azure => {
                f.debug_tuple("Cloud::Azure").finish()
              }
              Cloud::Hetzner => {
                f.debug_tuple("Cloud::Hetzner").finish()
              }
              Cloud::Local => {
                f.debug_tuple("Cloud::Local").finish()
              }
              Cloud::Other => {
                f.debug_tuple("Cloud::Other").finish()
              }
            }
          }
        }

        impl Cloud{
          #[doc(hidden)]
          pub unsafe fn _lift(val: u8) -> Cloud{
            if !cfg!(debug_assertions) {
              return unsafe { ::core::mem::transmute(val) };
            }

            match val {
              0 => Cloud::Aws,
              1 => Cloud::Gcp,
              2 => Cloud::Azure,
              3 => Cloud::Hetzner,
              4 => Cloud::Local,
              5 => Cloud::Other,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        #[repr(u8)]
        #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
        pub enum Platform {
          K8s,
          Nomad,
          Systemd,
          Cfworkers,
          Lambda,
          Baremetal,
          Other,
        }
        impl ::core::fmt::Debug for Platform {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Platform::K8s => {
                f.debug_tuple("Platform::K8s").finish()
              }
              Platform::Nomad => {
                f.debug_tuple("Platform::Nomad").finish()
              }
              Platform::Systemd => {
                f.debug_tuple("Platform::Systemd").finish()
              }
              Platform::Cfworkers => {
                f.debug_tuple("Platform::Cfworkers").finish()
              }
              Platform::Lambda => {
                f.debug_tuple("Platform::Lambda").finish()
              }
              Platform::Baremetal => {
                f.debug_tuple("Platform::Baremetal").finish()
              }
              Platform::Other => {
                f.debug_tuple("Platform::Other").finish()
              }
            }
          }
        }

        impl Platform{
          #[doc(hidden)]
          pub unsafe fn _lift(val: u8) -> Platform{
            if !cfg!(debug_assertions) {
              return unsafe { ::core::mem::transmute(val) };
            }

            match val {
              0 => Platform::K8s,
              1 => Platform::Nomad,
              2 => Platform::Systemd,
              3 => Platform::Cfworkers,
              4 => Platform::Lambda,
              5 => Platform::Baremetal,
              6 => Platform::Other,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        /// flow deployment context supplied by hosts
        #[derive(Clone)]
        pub struct DeploymentCtx {
          pub cloud: Cloud,
          pub region: Option<_rt::String>,
          pub platform: Platform,
          pub runtime: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for DeploymentCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("DeploymentCtx").field("cloud", &self.cloud).field("region", &self.region).field("platform", &self.platform).field("runtime", &self.runtime).finish()
          }
        }
        /// tenant identity and invocation metadata
        #[derive(Clone)]
        pub struct TenantCtx {
          pub tenant: TenantId,
          pub team: Option<TeamId>,
          pub user: Option<UserId>,
          pub deployment: DeploymentCtx,
          pub trace_id: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for TenantCtx {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("TenantCtx").field("tenant", &self.tenant).field("team", &self.team).field("user", &self.user).field("deployment", &self.deployment).field("trace-id", &self.trace_id).finish()
          }
        }
        /// flow registration information
        #[derive(Clone)]
        pub struct FlowInfo {
          pub id: FlowId,
          /// human-readable name
          pub profile: _rt::String,
          /// semver identifier
          pub version: _rt::String,
          /// "messaging" | "webhook" | "timer" | ...
          pub type_: _rt::String,
          pub private: bool,
        }
        impl ::core::fmt::Debug for FlowInfo {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("FlowInfo").field("id", &self.id).field("profile", &self.profile).field("version", &self.version).field("type", &self.type_).field("private", &self.private).finish()
          }
        }
        /// execution modifiers supplied when running a flow
        #[derive(Clone)]
        pub struct RunOpts {
          pub tenant: Option<TenantCtx>,
          pub timeout_ms: Option<u32>,
          /// Wasm "fuel" if host enforces
          pub fuel_units: Option<u64>,
        }
        impl ::core::fmt::Debug for RunOpts {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RunOpts").field("tenant", &self.tenant).field("timeout-ms", &self.timeout_ms).field("fuel-units", &self.fuel_units).finish()
          }
        }
        /// JSON schema documents describing flow IO
        #[derive(Clone)]
        pub struct SchemaDoc {
          pub input_jsonschema: _rt::String,
          pub output_jsonschema: _rt::String,
        }
        impl ::core::fmt::Debug for SchemaDoc {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("SchemaDoc").field("input-jsonschema", &self.input_jsonschema).field("output-jsonschema", &self.output_jsonschema).finish()
          }
        }
        /// result returned by a flow execution
        #[derive(Clone)]
        pub struct RunResult {
          /// "ok" | "error" | "deferred"
          pub status: _rt::String,
          pub output_json: Option<_rt::String>,
          pub error: Option<_rt::String>,
          pub logs_json: Option<_rt::String>,
          pub metrics_json: Option<_rt::String>,
        }
        impl ::core::fmt::Debug for RunResult {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RunResult").field("status", &self.status).field("output-json", &self.output_json).field("error", &self.error).field("logs-json", &self.logs_json).field("metrics-json", &self.metrics_json).finish()
          }
        }
        /// A2A search candidate
        #[derive(Clone)]
        pub struct A2aCandidate {
          pub flow: FlowId,
          pub score: f32,
        }
        impl ::core::fmt::Debug for A2aCandidate {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("A2aCandidate").field("flow", &self.flow).field("score", &self.score).finish()
          }
        }
        /// standardized interface errors
        #[repr(u8)]
        #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
        pub enum IfaceError {
          InvalidArg,
          NotFound,
          Denied,
          Unavailable,
          Internal,
        }
        impl ::core::fmt::Debug for IfaceError {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              IfaceError::InvalidArg => {
                f.debug_tuple("IfaceError::InvalidArg").finish()
              }
              IfaceError::NotFound => {
                f.debug_tuple("IfaceError::NotFound").finish()
              }
              IfaceError::Denied => {
                f.debug_tuple("IfaceError::Denied").finish()
              }
              IfaceError::Unavailable => {
                f.debug_tuple("IfaceError::Unavailable").finish()
              }
              IfaceError::Internal => {
                f.debug_tuple("IfaceError::Internal").finish()
              }
            }
          }
        }

        impl IfaceError{
          #[doc(hidden)]
          pub unsafe fn _lift(val: u8) -> IfaceError{
            if !cfg!(debug_assertions) {
              return unsafe { ::core::mem::transmute(val) };
            }

            match val {
              0 => IfaceError::InvalidArg,
              1 => IfaceError::NotFound,
              2 => IfaceError::Denied,
              3 => IfaceError::Unavailable,
              4 => IfaceError::Internal,

              _ => panic!("invalid enum discriminant"),
            }
          }
        }

        #[doc(hidden)]

        macro_rules! __export_greentic_types_core_types_0_4_0_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          };);
        }
        #[doc(hidden)]
        pub(crate) use __export_greentic_types_core_types_0_4_0_cabi;

      }

    }
  }
}
mod _rt {
  #![allow(dead_code, clippy::all)]
  pub use alloc_crate::string::String;
  extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_core_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::greentic::types_core::types::__export_greentic_types_core_types_0_4_0_cabi!($ty with_types_in $($path_to_types_root)*::exports::greentic::types_core::types);
  )
}
#[doc(inline)]
pub(crate) use __export_core_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.47.0:greentic:types-core@0.4.0:core:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 854] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xdb\x05\x01A\x02\x01\
A\x02\x01B\"\x01s\x04\0\x07flow-id\x03\0\0\x01s\x04\0\x09tenant-id\x03\0\x02\x01\
s\x04\0\x07team-id\x03\0\x04\x01s\x04\0\x07user-id\x03\0\x06\x01m\x06\x03aws\x03\
gcp\x05azure\x07hetzner\x05local\x05other\x04\0\x05cloud\x03\0\x08\x01m\x07\x03k\
8s\x05nomad\x07systemd\x09cfworkers\x06lambda\x09baremetal\x05other\x04\0\x08pla\
tform\x03\0\x0a\x01ks\x01r\x04\x05cloud\x09\x06region\x0c\x08platform\x0b\x07run\
time\x0c\x04\0\x0edeployment-ctx\x03\0\x0d\x01k\x05\x01k\x07\x01r\x05\x06tenant\x03\
\x04team\x0f\x04user\x10\x0adeployment\x0e\x08trace-id\x0c\x04\0\x0atenant-ctx\x03\
\0\x11\x01r\x05\x02id\x01\x07profiles\x07versions\x04types\x07private\x7f\x04\0\x09\
flow-info\x03\0\x13\x01k\x12\x01ky\x01kw\x01r\x03\x06tenant\x15\x0atimeout-ms\x16\
\x0afuel-units\x17\x04\0\x08run-opts\x03\0\x18\x01r\x02\x10input-jsonschemas\x11\
output-jsonschemas\x04\0\x0aschema-doc\x03\0\x1a\x01r\x05\x06statuss\x0boutput-j\
son\x0c\x05error\x0c\x09logs-json\x0c\x0cmetrics-json\x0c\x04\0\x0arun-result\x03\
\0\x1c\x01r\x02\x04flow\x01\x05scorev\x04\0\x0da2a-candidate\x03\0\x1e\x01m\x05\x0b\
invalid-arg\x09not-found\x06denied\x0bunavailable\x08internal\x04\0\x0biface-err\
or\x03\0\x20\x04\0\x1fgreentic:types-core/types@0.4.0\x05\0\x04\0\x1egreentic:ty\
pes-core/core@0.4.0\x04\0\x0b\x0a\x01\0\x04core\x03\0\0\0G\x09producers\x01\x0cp\
rocessed-by\x02\x0dwit-component\x070.240.0\x10wit-bindgen-rust\x060.47.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

